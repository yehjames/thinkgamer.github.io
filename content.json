{"meta":{"title":"文艺与Code | Thinkgamer的博客","subtitle":"All In CTR、DL、ML、RL、NLP、KG","description":"Thinkgamer的博客","author":"Thinkgamer","url":"http://thinkgamer.cn"},"pages":[{"title":"","date":"2019-10-14T06:42:35.705Z","updated":"2019-10-14T06:42:35.705Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://thinkgamer.cn/photos/lazyload.min.js","excerpt":"","text":""},{"title":"About","date":"2019-06-21T01:18:08.000Z","updated":"2019-10-14T12:28:36.846Z","comments":true,"path":"about/index.html","permalink":"http://thinkgamer.cn/about/index.html","excerpt":"个人信息ID：Thinkgamer邮箱：&nbsp;&nbsp;&nbsp;&nbsp;thinkgamer@163.com毕业：&nbsp;&nbsp;&nbsp;&nbsp;沈阳航空航天大学-计算机学院-软件工程就职：&nbsp;&nbsp;&nbsp;&nbsp;北京 | 某厂 | 算法工程师","text":"个人信息ID：Thinkgamer邮箱：&nbsp;&nbsp;&nbsp;&nbsp;thinkgamer@163.com毕业：&nbsp;&nbsp;&nbsp;&nbsp;沈阳航空航天大学-计算机学院-软件工程就职：&nbsp;&nbsp;&nbsp;&nbsp;北京 | 某厂 | 算法工程师 技术园地： CSDN：http://blog.csdn.net/gamer_gyt Github：https://github.com/Thinkgamer 知乎: https://www.zhihu.com/people/thinkgamer/activities 公众号：搜索与推荐Wiki 工作经历2017-12～2019-06 | 京东商城 个性化消息Push 简称“种草”。针对京东用户进行消息的个性化Push，增强用户黏性和交互。负责种草整个联动方案，组织会议进行讨论和需求下发，资源安排等。基于机器学习的个性化消息push模型开发，训练，调优，上线等。深度学习模型调研，基于公司内部平台，上线基于tensorflow-serving的深度学习模型，效果较ML模型提升显著。 Plus会员个性化推荐 理解内部推荐架构原理，负责开发方案，资源安排。基于机器学习的个性化消息push模型开发，训练，调优，上线等。相关CTR预估模型研究与在plus业务数据集上的离线测试。 商品价格段模型 基于KMeans构建商品价格段模型，实现了基于MR和Spark两个版本的代码。 商品质量分模型 基于线性模型构建商品质量分模型，用户推荐架构中的召回粗排。 特征监控模型 数据和特征决定了机器学习的上限,而模型和算法只是逼近这个上限。特征对于模型来说极其重要，因为对于特征的监控十分有必要，该模型支持使用者自定义监控指标和监控字段，能够有效的减少出现问题时的排查时间提高效果，并进行预警。 基础数据开发 业务内特征开发 全站特征开发 召回数据开发 2016-10～2017-12 | 北京万维星辰科技有限公司 搭建基于 Hadoop 和 ELK 技术栈的日志分析系统 参与设计了基于 ELK 的日志分析系统，提出并搭建了 Hadoop 数据备份系统，研究了 ELK 周边的开源产品 ，学习并使用 rails 实现 es 数据的快照备份。 异常检测算法研究与实现 1：根据合作方提供的 wlan 上网数据，对用户进行肖像刻画，从而对后入数据进行异常值估计。 2：研究基于指数平滑和线性回归的异常值检测，并使用 python 的 elasticsearch 进行实现。 中彩/德州银行日志审计项目 利用公司的日志分析系统对中国福利彩票和德州银行的日志进行分析，并形成安全事件，提出相应的整改和解决意见，形成月度报告。 2016-07～2016-09 | 北京广联达软件有限公司 实习以课题形式（课题为：基于质量数据的数据分析平台搭建）展开，利用 Hadoop 等开源组件搭建了 5 台分布式系统，包含 Hadoop，Hive，Spark，Zookeeper，Sqoop 和 Hbase，在该平台上完成了豆瓣影评数据分析 Demo 技能掌握 熟练掌握基于机器学习和深度学习的CTR预估算法，包括GBDT/LR/FM/FFM/FTRL/XGBoost/Wide&amp;Deep/DeepFM/DNN/FNN等。 熟悉推荐系统的数据流和过滤，召回，排序，展示等架构。 熟练掌握相关机器学习算法并用来构建基本模型。 熟练用户画像/物品画像/特征工程。 熟练Spark/MR/Hive/Python开发，了解相关大数据产品。 了解爬虫/Web后端开发，曾开发多个基于Django的网站后端。 了解强化学习/迁移学习/NLP。 熟悉ELK技术栈/Linux/Docker。 大学经历项目经历 基于 Hadoop 和机器学习的博客统计分析平台 采用 Django 作为 Web 开发基础，Python 爬取了 CSDN 博客的部分数据，存储到 hdfs 上，利用 MapReduce 对数据进行了离线计算，将解析好的字段存储到 Hive 中，利用 python 开发实现了协同过滤算法和 PangRank 算法。最终此项目在辽宁省计算机作品大赛中获得二等奖，中国大学生计算机作品大赛中获得三等奖。 图书推荐系统 python 爬取了豆瓣图书数据，对数据进行清洗之后，使用基于 Item 和 User 的协同过滤算法对登录用户产生图书推荐，此项目为大三期间为一个网友做的毕业设计。 荣誉奖励 单项一等奖学金 * 2 综合二等奖学金 * 2 单项支援服务标兵 优秀团干 * 2 辽宁省ACM优秀志愿者 校ACM三等奖 沈阳航空航天大学计算机作品大赛二等奖【网站】 辽宁省计算机作品大赛二等奖【博客统计分析系统】 中国大学生作品大赛三等奖【博客统计分析系统】 工作经历 助理辅导员 | 2014.09-2015.07 计算机学院 2014 级新生助理辅导员，协助辅导员进行大一班级的日常管理 活动部部长 | 2014.09-2015.07 爱心联合会活动部部长，负责相关活动的宣传推广与执行 班级团支书 | 2013.09-2017.06 协助辅导员进行班级日常的管理和相关共青团工作的开展 自我评价 不服输，爱钻研，具有自学能力和解决问题能力。 喜欢看书，看文章，整理笔记。 文艺Coder。 联系我： PS：加我微信，拉你进数据与算法交流群，进行头脑风暴"},{"title":"相册","slug":"photos","date":"2019-10-14T06:42:35.704Z","updated":"2019-10-14T06:42:35.704Z","comments":false,"path":"photos/index.html","permalink":"http://thinkgamer.cn/photos/index.html","excerpt":"","text":"图片来自Thinkgamer，正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2019-10-14T06:42:35.704Z","updated":"2019-10-14T06:42:35.704Z","comments":true,"path":"photos/ins.js","permalink":"http://thinkgamer.cn/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { // var minSrc = 'https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/min_photos/' + data.link[i] + '.min.jpg'; var minSrc = 'https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); // src += '.jpg'; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './ins.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2019-10-14T06:42:35.705Z","updated":"2019-10-14T06:42:35.705Z","comments":true,"path":"photos/ins.json","permalink":"http://thinkgamer.cn/photos/ins.json","excerpt":"","text":"{\"list\":[{\"date\":\"2017-11\",\"arr\":{\"text\":[\"0009\",\"0008\",\"0006\",\"0010\"],\"type\":[\"image\",\"image\",\"image\",\"image\"],\"month\":11,\"link\":[\"2017-11-03_0009.jpg\",\"2017-11-03_0008.jpg\",\"2017-11-03_0006.jpg\",\"2017-11-03_0010.jpg\"],\"year\":2017}},{\"date\":\"2017-10\",\"arr\":{\"text\":[\"0003\",\"0000\",\"0001\",\"0005\",\"0004\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\"],\"month\":10,\"link\":[\"2017-10-22_0003.jpg\",\"2017-10-22_0000.jpg\",\"2017-10-22_0001.jpg\",\"2017-10-22_0005.jpg\",\"2017-10-22_0004.jpg\"],\"year\":2017}},{\"date\":\"2016-08\",\"arr\":{\"text\":[\"0259\",\"0331\",\"1407\"],\"type\":[\"image\",\"image\",\"image\"],\"month\":8,\"link\":[\"2016-08-24_0259.jpg\",\"2016-08-24_0331.jpg\",\"2016-08-24_1407.jpg\"],\"year\":2016}},{\"date\":\"2016-04\",\"arr\":{\"text\":[\"1319\"],\"type\":[\"image\"],\"month\":4,\"link\":[\"2016-04-04_1319.jpg\"],\"year\":2016}}]}"},{"title":"","date":"2019-10-14T06:42:35.704Z","updated":"2019-10-14T06:42:35.704Z","comments":true,"path":"photos/ins.css","permalink":"http://thinkgamer.cn/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"Tags","date":"2019-10-14T12:28:36.847Z","updated":"2019-10-14T12:28:36.847Z","comments":true,"path":"tags/index.html","permalink":"http://thinkgamer.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常见的五种神经网络(4)-深度信念网络（上）篇","slug":"TensorFlow/常见的五种神经网络(4)-深度信念网络（上）篇","date":"2019-11-26T06:32:04.000Z","updated":"2019-11-26T08:37:52.852Z","comments":true,"path":"2019/11/26/TensorFlow/常见的五种神经网络(4)-深度信念网络（上）篇/","link":"","permalink":"http://thinkgamer.cn/2019/11/26/TensorFlow/常见的五种神经网络(4)-深度信念网络（上）篇/","excerpt":"","text":"转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/103231385博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki 引言常见的五种神经网络系列第三篇，主要介绍深度信念网络。内容分为上下两篇进行介绍，本文主要是深度信念网络（上）篇，主要介绍以下内容： 背景 玻尔兹曼机 受限玻尔兹曼机 该系列的其他文章： 常见的五种神经网络(1)-前馈神经网络 常见的五种神经网络(2)-卷积神经网络 常见的五种神经网络(3)-循环神经网络(上篇) 常见的五种神经网络(3)-循环神经网络(中篇) 常见的五种神经网络(3)-循环神经网络(下篇) 常见的五种神经网络(4)-深度信念网络(上篇) 常见的五种神经网络(4)-深度信念网络(下篇) 常见的五种神经网络(5)-生成对抗网络 背景对于一个复杂的数据分布，我们往往只能观测到有限的局部特征，并且这些特征通常会包含一定的噪声。如果要对这个数据分布进行建模，就需要挖掘出可观测变量之间复杂的依赖关系，以及可观测变量背后隐藏的内部表示。 而深度信念网络可以有效的学习变量之间复杂的依赖关系。深度信念网络中包含很多层的隐变量，可以有效的学习数据的内部特征表示，也可以作为一种有效的非线性降维方法，这些学习到的内部特征表示包含了数据的更高级的、有价值的信息，因此十分有助于后续的分类和回归等任务。 玻尔兹曼机是生成模型的一种基础模型，和深度信念网络的共同问题是推断和学习，因为这两种模型都比较复杂，并且都包含隐变量，他们的推断和学习一般通过MCMC方法来进行近似估计。这两种模型和神经网络有很强的对应关系，在一定程度上也称为随机神经网络（Stochastic Neural Network，SNN）。 因为深度信念网络是有多层玻尔兹曼机组成的，所以本篇文章我们先来了解一下玻尔兹曼机和受限玻尔兹曼机。 玻尔兹曼机介绍玻尔兹曼机（Boltzmann Machine）可以看作是一种随机动力系统，每个变量的状态都以一定的概率受到其他变量的影响。玻尔兹曼机可以用概率无向图模型来描述，如下所示： BM的三个性质： 二值输出：每个随机变量可以用一个二值的随机变量表示 全连接：所有节点之间是全连接的 权重对称：每两个变量之间的相互影响是对称的 BM中的每个变量$X$的联合概率由玻尔兹曼分布得到，即： p(x) = \\frac{1}{Z} exp(\\frac{-E(x)}{T})其中$Z$为配分函数，能量函数$E(X)$的定义为： E(x) \\overset{\\bigtriangleup }{=} E(X=x) = -( \\sum_{i","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"模型的独立学习方式","slug":"TensorFlow/模型的独立学习方式","date":"2019-11-12T12:53:23.000Z","updated":"2019-11-14T02:26:37.480Z","comments":true,"path":"2019/11/12/TensorFlow/模型的独立学习方式/","link":"","permalink":"http://thinkgamer.cn/2019/11/12/TensorFlow/模型的独立学习方式/","excerpt":"","text":"概述针对一个给定的任务，通常采取的步骤是：准确一定非规模的数据集，这些数据要和真实数据集的分布一致；然后设定一个优化目标和方法；然后在训练集上训练模型。 不同的模型往往都是从零开始训练的，一切知识都需要从训练集中得到，这就意味着每个任务都需要大量的训练数据。在实际应用中，我们面对的任务很难满足上述需求，比如训练任务和目标任务的数据分布不一致，训练数据集过少等。这时机器学习的任务就会受到限制，因此人们开始关注一些新的任务学习方式。本篇文章主要介绍一些“模型独立的学习方式”，比如：集成学习、协同学习、自学习、多任务学习、迁移学习、终身学习、小样本学习、元学习等。 集成学习集成学习（Ensemble Learning）就是通过某种策略将多个模型集成起来，通过群体决策来提高决策准确率。集成学习首要的问题是如何集成多个模型，比较常用的集成策略有直接平均、加权平均等。 集成学习可以分为：Boosting、Bagging、Stacking，这三种的详细区分和流程可以参考《推荐系统开发实战》一书中第八章 点击率预估部分。本文中主要介绍集成学习中的Boosting学习和AdaBoost算法。 集成学习的思想可以采用一句古老的谚语来描述：“三个臭皮匠，顶个诸葛亮”。但是一个有效的集成需要各个基模型的差异尽可能的大。为了增加模型之间的差异性，可以采取Bagging类和Boosting类两类方法。 Bagging类方法Bagging类方法是通过随机构造训练样本、随机选择特征等方法来提高每个基模型的独立性，代表性方法有Bagging和随机森林。 Bagging（Bootstrap Aggregating）是一个通过不同模型的训练数据集的独立性来提高不同模型之间的独立性。我们在原始训练集上进行有放回的随机采样，得到M比较小的训练集并训练M个模型，然后通过投票的方法进行模型集成。 随机森林（Random Forest）是在Bagging的基础上再引入了随机特征，进一步提升每个基模型之间的独立性。在随机森林中，每个基模型都是一棵树。 随机森林的算法步骤如下： 从样本集中通过重采样的方式产生n个样本 假设样本特征数目为a，对n个样本选择a中的k个特征，用建立决策树的方式获得最佳分割点 重复m次，产生m棵决策树-多数投票机制来进行预测 需要注意的一点是，这里m是指循环的次数，n是指样本的数目，n个样本构成训练的样本集，而m次循环中又会产生m个这样的样本集 Boosting类方法Boosting类方法是按照一定的顺序来先后训练不同的基模型，每个模型都针对前续模型的错误进行专门训练。根据前序模型的结果，来提高训练样本的权重，从而增加不同基模型之间的差异性。Boosting类方法的代表性方法有AbaBoost，GBDT，XGB，LightGBM等。 关于GBDT的介绍同样可以参考《推荐系统开发实战》一书。 Boosting类集成模型的目标是学习一个加性模型（additive model） ，其表达式如下： F(x) = \\sum_{m=1}^{M} a_m f_m(x)其中$f_m(x)$为弱分类器，或基分类器，$a_m$为弱分类器的集成权重，$F(x)$称为强分类器。 Boosting类方法的关键是如何训练每个弱分类器$f_m(x)$以及对应的权重$a_m$。为了提高集成的效果，应尽可能使得每个弱分类器的差异尽可能大。一种有效的方法是采用迭代的策略来学习每个弱分类器，即按照一定的顺序依次训练每个弱分类器。 在学习了第m个弱分类器之后，增加分错样本的权重，使得第$m+1$个弱分类器“更关注”于前边弱分类器分错的样本。这样增加每个弱分类器的差异，最终提升的集成分类器的准确率。这种方法称为AdaBoost（其实其他的Boost模型采用的也是类似的策略，根据前m-1颗树的误差迭代第m颗树）。 AdaBoost算法AdaBoost算法是一种迭代式的训练算法，通过改变数据分布来提高弱分类器的差异。在每一轮训练中，增加分错样本的权重，减少对分对样本的权重，从而得到一个新的数据分布。 以两类分类为例，弱分类器$f_m(x) \\in \\{ +1, -1\\}$，AdaBoost算法的训练过程如下所示，最初赋予每个样本同样的权重。在每一轮迭代中，根据当前的样本权重训练一个新的弱分类器。然后根据这个弱分类器的错误率来计算其集成权重，并调整样本权重。 AdaBoost算法的统计学解释 AdaBoost算法可以看做是一种分步优化的加性模型，其损失函数定义为： L(F) = exp(-y F(x)) \\\\ = exp(-y \\sum_{m=1}^{M} a_m f_m(x))其中$y,f_m(x)\\in \\{ +1,-1\\}$ 假设经过$m-1$次迭代，得到： F_{m-1}(x) = \\sum_{t=1}^{T} a_t f_t(x)则第$m$次迭代的目标是找一个$a_m$和$f_m(x)$使得下面的损失函数最小。 L(a_m,f_m(x)) = \\sum_{n=1}^{N}exp(-y^{(n)} (F_{m-1} (x^{(n)}) + a_m f_m(x^{(n)})))令 $w_m^{(n)}=exp(-y^{(n)} F_{m-1}(x^{(n)}))$，则损失函数可以表示为： L(a_m,f_m(x)) = \\sum_{n=1}^{N} w_m^{(n)} exp(-y^{(n)} a_m f_m(x^{(n)}))因为$y,f_m(x) \\in {+1, -1}$，有： yf_m(x) = 1-2I(y\\neq f_m(x))其中$I(x)$为指示函数。 将损失函数在$f_m(x)=0$处进行二阶泰勒展开，有： L(a_m, f_m(x)) = \\sum_{n=1}^{N} w_m^{(n)} ( 1 - a_m y^{(n)}f_m(x^{(n)}) + \\frac{1}{2}a_m^2 ) \\\\ \\propto a_m \\sum_{n=1}^{N} w_n^{(n)} I(y^{(n} \\neq f_m(x^{(n)})从上式可以看出，当$a_m&gt;0$时，最优的分类器$f_m(x)$为使得在样本权重为$w_m^{(n)}, 1 \\leq n \\leq N$时的加权错误率最小的分类器。 在求解出$f_m(x)$之后，上述的损失函数可以写为： L(a_m, f_m(x)) = \\sum_{y^{(n)}=f_m(x^{(n)})} w_m^{(n)} exp(-a_m) + \\sum_{y^{(n)} \\neq f_m(x^{(n)})} w_m^{(n)} exp(a_m) \\\\ \\propto (1-\\epsilon _m) exp(-a_m) + \\epsilon_m exp(a_m)其中$\\epsilon_m$为分类器$f_m(x)$的加权错误率 \\epsilon_m = \\frac { \\sum_{ y^{(n)} \\neq f_m(x^{(n)}) } w_m^{(n)} } {\\sum_{n} w_m^{(n)}}求上式关于$a_m$的导数并令其为0，得到 a_m = \\frac {1}{2} log \\frac {1-\\epsilon_m}{\\epsilon_m}AdaBoost算法的优缺点优点： 作为分类器精度很高 可以使用各种算法构建子分类器，AdaBoost提供的是一个框架 使用简单分类器时，计算出的结果可理解，且构造简单 不需要做特征筛选 不同担心过拟合 缺点： 容易收到噪声干扰 训练时间长，因为需要遍历所有特征 执行效果依赖于弱分类器的选择 自训练和协同训练监督学习虽然准确度上有一定的保证，但往往需要大量的训练数据，但在一些场景中标注数据的成本是非常高的，因此如何利用大量的无标注数据提高监督学习的效率，有着十分重要的意义。这种利用少量样本标注数据和大量样本标注数据进行学习的方式称之为半监督学习（Semi-Supervised Learning，SSL）。 本节介绍两种无监督的学习算法：自训练和协同训练。 自训练自训练（Slef-Training）也叫自训练（Self-teaching）或者自举法（boostStrapping）。 自训练的思路是：利用已知的标注数据训练一个模型，利用该模型去预测无标注的样本数据，然后将置信度较高的样本以及其伪标签加入训练集，然后重新训练模型，进行迭代。下图给出了自训练的算法过程。 自训练和密度估计中EM算法有一定的相似之处，通过不断地迭代来提高模型能力。但自训练的缺点是无法保证每次加入训练集的样本的伪标签是正确的。如果选择样本的伪标签是错误的，反而会损害模型的预测能力。因此自训练最关键的步骤是如何设置挑选样本的标准。 协同训练协同训练（Co-Training）是自训练的一种改进方法，通过两个基于不同视角的分类器来相互促进。很多数据都有相对独立的不同视角。比如互联网上的每个网页都由两种视角组成：文字内容和指向其他网页的链接。如果要确定一个网页的类别，可以根据文字内容来判断，也可以根据网页之间的链条关系来判断。 假设一个样本$x=[x_1,x_2]$，其中$x_1,x_2$分别表示两种不同视角$V_1,V_2$的特征，并满足下面两个假设： （1）：条件独立性，即给定样本标签y时，两种特征条件独立$p(x_1,x_2|y)=p(x_1|y)p(x_2|y)$ （2）：充足和冗余性，即当数据充分时，每种视角的特征都可以足以单独训练出一个正确的分类器。 令$y=g(x)$为需要学习的真实映射函数，$f_1$和$f_2$分别为两个视角的分类器，有： \\exists f_1, f_2, \\forall x \\in X,\\,\\,\\,\\,\\, f_1(x_1) = f_2(x_2) = g(x)其中$X$为样本$x$的取值空间。 由于不同视角的条件独立性，在不同视角上训练出来的模型就相当于从不同的视角来理解问题，具有一定的互补性。协同训练就是利用这种互补行来进行自训练的一种方法。首先在训练集上根据不同视角分别训练两个模型$f_1$和$f_2$然后用$f_1$和$f_2$在无标记数据集上进行预测，各选取预测置信度比较高的样本加入到训练集，重新训练两个不同视角的模型，并不断重复这个过程（需要注意的是协同算法要求两种视图时条件独立的，如果两种视图完全一样，则协同训练退化成自训练算法）。 协同训练的算法过程如下： 多任务学习一般的机器学习模型是针对单个任务进行的，不同任务的模型需要在各自的训练集上单独学习得到。而多任务学习（Multi-task learning）是指同时学习多个相关任务，让 这些任务在学习的过程中共享知识，利用多个任务之间的相关性来改进模型的性能和泛化能力。 多任务学习可以看做时一种归纳迁移学习（Inductive Transfer Learning），即通过利用包含在相关任务中的信息作为归纳偏置（Inductive Bias）来提高泛化能力。 多任务学习的主要挑战在于如何设计多任务之间的共享机制，在传统的机器学习任务中很难引入共享信息，但是在神经网络中就变得简单了许多，常见的以下四种： 硬共享模式：让不同任务的神经网络模型共同使用一些共享模块来提取一些通用的特征，然后再针对每个不同的任务设置一些私有模块来提取一些任务特定的特征。 软共享模式：不显式设置共享模块，但每个任务都可以从其他任务中“窃取”一些信息来提高自己的能力。窃取的方式包括直接复制使用其他任务的隐状态，或使用注意力机制来主动选择有用的信息。 层次共享模式：一般神经网络中不同层抽取的特征类型不同，底层一般抽取一些低级的局部特征，高层抽取一些高级的抽象语义特征。因此如果多任务学习中不同任务也有级别高低之分，那么一个合理的共享模式是让低级任务在底层输出，高级任务在高层输出。 共享-私有模式：一个更加分工明确的方式是将共享模块和任务特定（私有）模块的责任分开。共享模块捕捉一些跨任务的共享特征，而私有模块只捕捉和特点任务相关的特征。最终的表示由共享特征和私有特征共同构成。 在多任务学习中，每个任务都可以有自己单独的训练集。为了让所有任务同时学习，我们通常会使用交替训练的方式来“近似”的实现同时学习，下图给出了四种常见的共享模式图 多任务学习的流程可以分为两个阶段： （1）联合训练阶段：每次迭代时，随机挑选一个任务，然后从这个任务中随机选择一些训练样本，计算梯度并更新参数 （2）单任务精调阶段：基于多任务学习到的参数，分别在每个单独任务进行精调，其中单任务精调阶段为可选阶段。当多个任务的差异性比较大时，在每个单任务上继续优化参数可以进一步提升模型能力。 假设有M个相关任务，其模型分别为$f_m(x,\\theta), 1\\leq m \\leq M$，多任务学习的联合目标函数为所有任务损失函数的线性加权： L(\\theta) = \\sum_{m=1}^{M}\\sum_{n=1}^{N_m} \\eta_m l_m(f_m(x^{(m,n)}, \\theta ), y_{(m,n)})其中$l_m$为第m个任务的损失函数，$\\eta_m$是第m个任务的权重，$\\theta$表示包含了共享模块和私有模块在内的所有参数。 多任务学习中联合训练阶段的具体过程如下所示： 多任务学习通常比单任务学习获得更好的泛化能力，主要由于以下几个原因： 1.多任务学习在多个数据集上进行训练，训练集范围更大，且多任务之间具有一定的相关性，相当于是一种隐式的数据增强，可以提高模型的泛化能力。 2.多任务学习中的共享模块需要兼顾所有任务，在一定程度上避免了模型过拟合到单个任务的训练集，可以看做是一种正则化。 3.多任务学习比单任务学习可以获得更好的表示 4.在多任务学习中，每个任务都可以“选择性”利用其他任务中学习到的隐藏特征，从而提高自身的能力。 迁移学习标准机器学习的前提假设只训练数据和测试数据的分布是相同的。如果不满足这个假设，在训练集上学习到的模型在测试集上的表现会比较差。如何将相关任务的训练数据中学习到的可泛化知识迁移到目标任务中，就是迁移学习（Transfer Learning）要解决的问题。 迁移学习根据不同的迁移方式又分为两个类型：归纳迁移学习（Inductive Transfer Learning）和推导迁移学习（Transductive Transfer Learning）。这两个类型分别对应两个机器学习的范式：归纳学习（Inductive Learning）和转导学习（Transductive Learning）。一般的机器学习任务都是指归纳学习，即希望再训练集上学习到使得期望风险最小的模型。而转导学习的目标是学习一种在给定测试集上错误率最小的模型，在训练阶段可以利用测试集的信息。 归纳迁移学习一般而言，归纳迁移学习要求源领域和目标领域时相关的，并且源领域$D_S$有大量的训练样本，这些样本可以是有标注的样本也可以时无标注的样本。 当源领域只有大量无标注数据时，源任务可以转换为无监督学习任务，比如自编码和密度估计，通过无监督任务学习一种可迁移的表示，然后将这些表示迁移到目标任务上。 当源领域有大量的标注数据时，可以直接将源领域上训练的模型迁移到目标领域上。归纳迁移学习一般有下面两种迁移方式： 基于特征的方式：将预训练模型的输出或者中间隐藏层的输出作为特征直接加入到目标任务学习模型中。目标任务的学习模型可以时一般的浅层分类器（比如支持向量机等）或一个新的神经网络模型。 精调的方式：在目标任务上复用预训练模型的部分参数，并对其参数进行精调。 假设预训练的模型是一个深层神经网络，不同层的可迁移性也不尽相同。通常来说网络的低层学习一些通用的低层特征，中层或者高层学习抽象的高级语义特征，而最后几层一般学习和特定任务相关的特征。因此根据目标任务的自身特点以及和源任务的相关性，可以针对性的选择预训练模型的不同层来迁移到目标任务中。 将预训练模型迁移到目标任务中通常会比从零开始学习的方式好，主要体现在以下三点： （1）初始模型的性能一般比随机初始化的模型要好 （2）训练时模型的学习速度比从零开始学习要快，收敛性更好 （3）模型的最终性能更好，具有更好的泛化性 归纳迁移学习和多任务学习也比较类似，但是有下面两点区别： （1）多任务学习是同时学习多个不同任务，而归纳迁移学习通常分为两个阶段，即源任务上的学习阶段，和目标任务上的迁移学习阶段 （2）归纳迁移学习是单向的知识迁移，希望提高模型在目标任务上的性能，而多任务学习时希望提高所有任务的性能。 转导迁移学习转导迁移学习是一种从样本到样本的迁移，直接利用源领域和目标领域的样本进行迁移学习。转导迁移学习可以看作是一种特殊的转导学习。转导迁移学习通常假设源领域有大量的标注数据，而目标领域没有（或少量）的标注数据，但是有大量的无标注数据。目标领域的数据在训练阶段是可见的。 转导迁移学习的一个常见子问题时领域适应（Domain Adaptation），在领域适应问题中，一般假设源领域和目标领域有相同的样本空间，但是数据分布不同$p_S(x,y) \\neq p_T(x,y)$。 根据贝叶斯公式，$p(x,y)=p(x|y)p(y) = p(y|x)p(x)$，因此数据分布的不一致通常由三种情况造成。 （1）协变量偏移（Covariate Shift）：源领域和目标领域的输入边际分布不同$p_S(x) \\neq p_T(x)$，但后验分布相同$p_S(y|x) = p_T(y|x)$，即学习任务相同$T_s = T_T$ （2）概念偏移（Concept Shift）：输入边际分布相同$p_S(x) = p_T(x)$，但后验分布不同$p_S(y|x) \\ neq p_T(y|x)$，即学习任务不同$T_S \\neq T_T$ （3）先验偏移（Prior Shift）：源领域和目标领域中的输出$y$先验分布不同$p_S(y) \\neq p_T(y)$，条件分布相同$p_S(x|y) = p_T(x|y)$。在这样的情况下，目标领域必须提供一定数量的标注样本。 终生学习终生学习（Lifelong Learning）也叫持续学习（Continuous Learning）是指像人类一样具有持续不断的学习能力，根据历史任务中学到的经验和知识来帮助学习不断出现的新任务，并且这些经验和知识是持续累积的，不会因为新的任务而忘记旧的知识。 在终生学习中，假设一个终生学习算法已经在历史人任务$T_1, T_2, …$上学习到一个模型，当出现一个新任务$T_{m+1}$时，这个算法可以根据过去在$m$个任务上学习到的知识来帮助第$m+1$个任务，同时积累所有的$m+1$个任务上的知识。 在终生学习中，一个关键的问题是如何避免灾难性遗忘（Catastrophic Forgetting），即按照一定顺序学习多个任务时，在学习新任务的同时不忘记先前学习到的历史知识。比如在神经网络模型中，一些参数对任务$T_A$非常重要，如果在学习任务$T_B$时被改变了，就可能给任务$T_A$造成不好的影响。 解决灾难性遗忘的方法有很多，比如弹性权重巩固方法（Elastic Weight Coonsolidation）。 元学习根据没有免费午餐定理，没有一种通用的学习算法在所有任务上都有效。因此当使用机器学习算法实现某个任务时，我们通常需要“就事论事”，根据任务的特定来选择合适的模型、损失函数、优化算法以及超参数。 而这种动态调整学习方式的能力，称为元学习（Meta-Learning），也称为学习的学习（Learning to Learn）。 元学习的目的时从已有的任务中学习一种学习方法或元知识，可以加速新任务的学习。从这个角度来说，元学习十分类似于归纳迁移学习，但元学习更侧重从多种不同的任务中归纳出一种学习方法。 这里主要介绍两种典型的元学习方法：基于优化器的元学习和模型无关的元学习。 基于优化器的元学习目前神经网络的的学习方法主要是定义一个目标损失函数$L(\\theta)$，并通过梯度下降算法来最小化$L(\\theta)$ \\theta_t \\leftarrow \\theta_{t-1} - \\alpha \\bigtriangledown L(\\theta_{t-1})其中$\\theta_t$为第$t$步时的模型参数，$\\bigtriangledown L(\\theta_{t-1})$为梯度，$\\alpha$为学习率。在不同的任务上，通常选择不同的学习绿以及不同的优化方法，比如动量法，Adam等。这些优化算法的本质区别在于更新参数的规则不同，因此一种很自然的元学习就是自动学习一种更新参数的规则，即通过另一个神经网络（比如循环神经网络）来建模梯度下降的过程。下图给出了基于优化器的元学习示例。 我们用函数$g_t(.)$来预测第$t$步时参数更新的差值$\\Delta \\theta_t = \\theta_t - \\theta_{t-1}$，函数$g_t(.)$称为优化器，输入是当前时刻的梯度值，输出时参数的更新差值$\\Delta \\theta_t$，这样第$t$步的更新规则可以写为： \\theta_{t+1} = \\theta_t + g_t(\\bigtriangledown L(\\theta_{t}), \\phi )其中$\\phi$为优化器$g_t(.)$的参数。 学习优化器$g_t(.)$的过程可以看做是一种元学习过程，其目标是找到一个适用于多个不同任务的优化器。在标准的梯度下降中，每步迭代的目标是使得$L(\\theta)$下降。而在优化器的元学习中，我们希望在每步迭代的目标是$L(\\theta)$最小，具体的目标函数为： L(\\phi) = E_f [ \\sum_{t=1}^{T} w_t L(\\theta_t) ] \\\\ \\theta_t = \\theta_{t-1} + g_t \\\\ [g_t: h_t] = LSTM( \\bigtriangledown L(\\theta_{t-1}), h_{t-1}, \\phi)其中$T$为最大迭代次数，$w_t&gt;0$为每一步的权重，一般可以设置$w_t=1,\\forall t$。由于LSTM网络可以记忆梯度的历史信息，学习到的优化器可以看做是一个高阶的优化方法。 模型无关的元学习模型无关的元学习（Model-Agnostic Meta-Learning， MAML）是一个简单的模型无关、任务无关的元学习算法。假设所有的任务都来自一个任务空间，其分布为$p(T)$，我们可以在这个任务空间的所有任务上学习一种通用的表示，这种表示可以经过梯度下降方法在一个特定的单任务上进行精调。假设一个模型为$f(\\theta)$，如果我们让这个模型适应到一个新任务$T_m$上，通过一步或多步的梯度下降更新，学习到的任务适配参数为： \\theta_m ' = \\theta- \\alpha \\bigtriangledown _\\theta L_{T_m}(f_\\theta)其中$\\alpha$为学习率，这里的$\\theta_m’$可以理解为关于$\\theta$的函数，而不是真正的参数更新。 MAML的目标是学习一个参数$\\theta$使得其经过一个梯度迭代就可以在新任务上达到最好的性能。 \\underset{ \\theta }{ min } \\sum_{T_m \\sim p(T)} L_{T_m}(f(\\theta'_m)) = \\sum_{T_m \\sim p(T)} L_{T_m} ( f(\\theta - \\alpha \\bigtriangledown _\\theta L_{T_m} (f_\\theta )) )即在所有任务上的元优化（Meta-Optimization）也采用梯度下降来进行优化，即： \\theta \\leftarrow \\theta - \\beta \\bigtriangledown _\\theta \\sum_{m=1}^{M} L_{T_m}(f_{\\theta_m'})其中$\\beta$为元学习率，这里为一个真正的参数更新步骤。需要计算关于$\\theta$的二阶梯度，但用一级近似通常也可以达到比较好的性能。 MAML的具体过程算法如下： 总结目前神经网路的学习机制主要是以监督学习为主，这种学习方式得到的模型往往是定向的，也是孤立的，每个任务的模型都是从零开始训练的，一切知识都需要从训练数据中得到，导致每个任务都需要大量的训练数据。本章主要介绍了一些和模型无关的学习方式，包括集成学习、自训练和协同训练、多任务学习、迁移学习、元学习，这些都是深度学习中研究的重点。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"集成学习","slug":"集成学习","permalink":"http://thinkgamer.cn/tags/集成学习/"},{"name":"迁移学习","slug":"迁移学习","permalink":"http://thinkgamer.cn/tags/迁移学习/"},{"name":"元学习","slug":"元学习","permalink":"http://thinkgamer.cn/tags/元学习/"}]},{"title":"【论文】文本相似度计算方法综述","slug":"论文/【论文】文本相似度计算方法综述","date":"2019-11-07T07:55:25.000Z","updated":"2019-11-14T02:26:37.482Z","comments":true,"path":"2019/11/07/论文/【论文】文本相似度计算方法综述/","link":"","permalink":"http://thinkgamer.cn/2019/11/07/论文/【论文】文本相似度计算方法综述/","excerpt":"","text":"概述在信息爆炸时代，人们迫切希望从海量信息中获取与自身需要和兴趣吻合度高的内容，为了满足此需求，出现了多种技术，如：搜索引擎、推荐系统、问答系统、文档分类与聚类、文献查重等，而这些应用场景的关键技术之一就是文本相似度计算技术。因此了解文本相似度的计算方法是很有必要的。 文本相似度定义文本相似度在不同领域被广泛讨论，由于应用场景不同，其内涵有所差异，故没有统一、公认的定义。 Lin从信息论的角度阐明相似度与文本之间的共性和差异有关，共性越大、差异越小、则相似度越高；共性越小、差异越大、则相似度越低。相似度最大的情况是文本完全相同。同时提出基于假设推论出相似度定理，如下所示： Sim(A,B) = \\frac{ log P(common(A,B)) } {log P(description(A,B))}其中，common(A,B)是A和B的共性信息，description(A,B)是描述A和B的全部信息，上述公式表达出相似度与文本共性成正相关。 由于没有限制领域，此定义被采用较多。 相关度与相似度是容易混淆的概念，大量学者没有对此做过对比说明。相关度体现在文本共现或者以任何形式相互关联（包括上下位关系、同义关系、反义关系、部件-整体关系、值-属性关系等）反映出文本的组合特点。而相似度是相关度的一种特殊情况，包括上下位关系和同义关系。由此得出，文本的相似度越高，则相关度越大，但是相关度越大并不能说明相似度高。 相似度一般用[0,1]表示，该实数可以通过语义距离计算获得。相似度与语义距离呈反比关系，语义距离越小，相似度越高；语义距离越大，相似度越低。通常用下面的公式表示相似度与语义距离的关系。 Sim(S_A,S_B) = \\frac {\\alpha} { Dis(S_A,S_B) + \\alpha }其中，$Dis(S_A,S_B)$表示文本$S_A,S_B$之间的非负语义距离，$\\alpha$为调节因子，保证了当语义距离为0时上述公式的意义。 文本相似度计算中还有一个重要的概念是文本表示，代表对文本的基本处理，目的是将半结构化或非结构化的文本转化为计算机可读形式。文本相似度计算方法的不同本质是文本表示方法不同 文本相似度计算方法 文本相似度计算方法可分为四大类： 基于字符串的方法（String-Based） 基于语料库的方法（Corpus-Based） 基于世界知识的方法（Knowledge-Based） 其他方法 基于字符串的方法该方法从字符串匹配度出发，以字符串共现和重复程度为相似度的衡量标准。根据计算粒度不同，可以将该方法分为基于字符的方法和基于词语的方法。下图列出两种方法常见的算法以及思路 基于字符串的方法是在字面层次上的文本比较，文本表示即为原始文本，该方法原理简单，易于实现，现已成为其他方法的计算基础。 但不足的是将字符或词语作为独立的知识单元，并未考虑词语本身的含义和词语之间的关系。以同义词为例，尽管表达不同，但具有相同的含义，而这类词语的相似度依靠基于字符串的方法并不能准确计算。 基于语料库的方法基于语料库的方法利用语料库中获取的信息计算文本相似度。基于语料库的方法可以划分为： 基于词袋模型的方法 基于神经网络的方法 基于搜索引擎的方法 基于词袋词袋模型（Bag of Words Model，BOW）建立在分布假说的基础上，即“词语所处的上下文语境相似，其语义则相似”。其基本思想是：不考虑词语在文档中出现的顺序，将文档表示成一系列词语的组合。 根据考虑的语义成程度不同，基于词袋模型的方法主要包括： 向量空间模型（Vector Space Model，VSM） 潜在语义分析（Latent Semantic Analysis，LSA） 概率潜在语义分析（Probabilistic Latent Semantic Analysis，PLSA） 潜在狄利克雷分布（Latent Dirichlet Allocation，LDA） VSMVSM模型的基本思想是将每篇文档表示成一个基于词频或者词频-逆文档频率权重的实值向量，那么N篇文档则构成n维实值空间，其中空间的每一维都对用词项，每一篇文档表示该空间的一个点或者向量。两个文档之间的相似度就是两个向量的距离，一般采用余弦相似度方法计算。 VSM有两个明显的缺点：一是该方法基于文本中的特征项进行相似度计算，当特征项较多时，产生的高维稀疏矩阵导致计算效率不高；二是向量空间模型算法的假设是文本中抽取的特征项没有关联，不符合文本语义表达。 LSA，PLSALSA算法的基本思想是将文本从稀疏的高维词汇空间映射到低维的潜在语义空间，在潜在的语义空间计算相似性。LSA是基于VSM提出的，两种方法都是采用空间向量表示文本，但LSA使用潜在语义空间，利用奇异值分解提高对高维的词条-文档矩阵进行处理，去除了原始向量空间的某些“噪音”，使数据不再稀疏。Hofmann在LSA的基础上引入主题层，采用期望最大化算法（EM）训练主题。 LSA本质上是通过降维提高计算准确度，但该算法复杂度比较高，可移植性差，比较之下，PLSA具备统计基础，多义词和同义词在PLSA中分别被训练到不同的主题和相同的主题，从而避免了多义词，同义词的影响，使得计算结构更加准确，但不适用于大规模文本。 LDALDA主题模型是一个三层的贝叶斯概率网络，包含词、主题和文档三层结构。采用LDA计算文本相似性的基本思想是对文本进行主题建模，并在主题对应的词语分布中遍历抽取文本中的词语，得到文本的主题分布，通过此分布计算文本相似度。 以上三类尽管都是采用词袋模型实现文本表示，但是不同方法考虑的语义程度有所不同。基于向量空间建模的方法语义程度居中，加入潜在语义空间概念，解决了向量空间模型方法的稀疏矩阵问题并降低了多义词，同义词的影响。基于LDA的主题模型的方法语义程度最高，基于相似词语可能属于统一主题的理论，主题经过训练得到，从而保证了文本的语义性。 基于神经网络基于神经网络生成词向量计算文本相似度是近些年提的比较多的。不少产生词向量的模型和工具也被提出，比如Word2Vec和GloVe等。词向量的本质是从未标记的非结构文本中训练出一种低维实数向量，这种表达方式使得类似的词语在距离上更为接近，同时较好的解决了词袋模型由于词语独立带来的维数灾难和语义不足问题。 基于神经网络方法与词袋模型方法的不同之处在于表达文本的方式。词向量是经过训练得到的低维实数向量，维数可以认为限制，实数值可根据文本距离调整，这种文本表示符合人理解文本的方式，所以基于词向量判断文本相似度的效果有进一步研究空间。 基于搜索引擎基本原理是给定搜索关键词$x,y$，搜索引擎返回包含 $x,y$的网页数量$f(x),f(y)$以及同时包含$x,y$的网页数量$f(x,y)$，计算谷歌相似度距离如下所示: NGD(x,y) = \\frac { G(x,y) - min(G(x),G(y)) } { max(G(x),G(y)} \\\\ = \\frac {max\\{ log \\,f(x), log\\,f(y) \\} - log \\, f(x,y)} { log \\, N - min{log \\,f(x), log \\, f(y)} }但是该方法最大的不足是计算结果完全取决于搜索引擎的查询效果, 相似度因搜索引擎而异 基于世界知识的方法基于世界知识的方法是利用具有规范组织体系的知识库计算文本相似度，一般分为两种：基于本体知识和基于网络知识。 基于本体知识文本相似度计算方法使用的本体不是严格的本体概念, 而指广泛的词典、叙词表、词汇表以及狭义的本体。由于本体能够准确地表示概念含义并能反映出概念之间的关系, 所以本体成为文本相似度的研究基础[7]。最常利用的本体是通用词典, 例如 WordNet、《知网》(HowNet)和《同义词词林》等, 除了词典还有一些领域本体, 例如医疗本体、电子商务本体、地理本体、农业本体等。 结合Hliaoutaki、Batet等的研究，将基于本体的文本相似度算法概括为四种： 基于距离 基于内容 基于属性 混合式相似度 下表列出了各种方法的基本原理、代表方法和特点 基于网络知识由于本体中词语数量的限制，有些学者开始转向基于网络知识方法的研究，原因是后者覆盖范围广泛、富含丰富的语义信息、更新速度相对较快，使用最多的网络知识是维基百科、百度百科。网络知识一般包括两种结构，分别是词条页面之间的链接和词条之间的层次结构。 基于网络知识的文本相似度计算方法大多利用页面链接或层次结构，能较好的反映出词条的语义关系。但其不足在于：词条与词条的信息完备程度差异较大，不能保证计算准确度，网络知识的生产方式是大众参与，导致文本缺少一定的专业性。 其他方法除了基于字符串、基于语料库和基于世界知识的方法, 文本相似度计算还有一些其他方法，比如： 句法分析 混合方法 总结本文总结了文本相似度计算的四种方法，以及他们的优缺点。作者认为今后文本相似度的计算方法趋势有三个方向，分别是： 基于神经网络的方法研究将更加丰富 网络资源为文本相似度计算方法研究提供更多支持 针对特定领域以及跨领域文本的相似度计算将成为今后发展的重点 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://thinkgamer.cn/tags/NLP/"},{"name":"论文","slug":"论文","permalink":"http://thinkgamer.cn/tags/论文/"},{"name":"文本相似度","slug":"文本相似度","permalink":"http://thinkgamer.cn/tags/文本相似度/"}]},{"title":"无监督学习中的无监督特征学习、聚类和密度估计","slug":"TensorFlow/无监督学习中的无监督特征学习、聚类和密度估计","date":"2019-11-05T02:58:36.000Z","updated":"2019-11-14T02:26:37.480Z","comments":true,"path":"2019/11/05/TensorFlow/无监督学习中的无监督特征学习、聚类和密度估计/","link":"","permalink":"http://thinkgamer.cn/2019/11/05/TensorFlow/无监督学习中的无监督特征学习、聚类和密度估计/","excerpt":"","text":"无监督学习概述无监督学习（Unsupervised Learning）是指从无标签的数据中学习出一些有用的模式，无监督学习一般直接从原始数据进行学习，不借助人工标签和反馈等信息。典型的无监督学习问题可以分为以下几类： 无监督特征学习（Unsupervised Feature Learning） 从无标签的训练数据中挖掘有效的特征表示，无监督特征学习一般用来进行降维，数据可视化或监督学习前期的特征预处理。 密度估计（Density Estimation） 是根据一组训练样本来估计样本空间的概率密度。密度估计可以分为：参数密度估计和非参数密度估计。参数密度估计是假设数据服从某个已知概率密度函数形式的分布，然后根据训练样本去估计该分布的参数。非参数密度估计是不假设服从某个概率分布，只利用训练样本对密度进行估计，可以进行任意形状的密度估计，非参数密度估计的方法包括：直方图、核密度估计等。 聚类（Clustering） 是将一组样本根据一定的准则划分到不同的组。一个通用的准则是组内的样本相似性要高于组间的样本相似性。常见的聚类方法包括：KMeans、谱聚类、层次聚类等。 聚类大家已经非常熟悉了，下文主要介绍无监督特征学习和概率密度估计。 无监督特征学习无监督特征学习是指从无标注的数据中自动学习有效的数据表示，从而能够帮助后续的机器学习模型达到更好的性能。无监督特征学习主要方法有： 主成分分析 稀疏编码 自编码器 主成分分析主成分分析（Principal Component Analysis，PCA）是一种最常用的数据降维方法，使得在转换后的空间中数据的方差最大。以下部分摘自于 https://zhuanlan.zhihu.com/p/32412043 PCA中的最大可分性思想PCA降维，用原始样本数据中最主要的方面代替原始数据，最简单的情况是从2维降到1维，如下图所示，我们希望找到某一个维度方向，可以代表两个维度的数据，图中列了两个方向 $u_1, u_2$，那么哪个方向可以更好的代表原始数据呢？ 从直观上看，$u_1$比$u_2$好，这就是所说的最大可分性。 基变换 其中$p_i \\in {p_1, p_2, …, p_R}$，$p_i \\in R^{1N}$是一个行向量，表示第i个基，$a_j \\in {a_1, a_2, …, a_M}$，$a_i \\in R^{N1}$是一个列向量，表示第$j$个原始数据记录，特别要注意的是，这里R可以小于N，而R决定了变维后数据的维数。 从上图和文字解释我们可以得到一种矩阵相乘的物理解释：两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。更抽象的说，一个矩阵可以表示一种线性变换。很多同学在学习矩阵相乘时，只是简单的记住了相乘的规则，但并不清楚其背后的物理意义。 方差如何考虑一个方向或者基是最优的，看下图： 我们将所有的点向两条直线做投影，基于前面PCA最大可分性思想，我们要找的是降维后损失最小，可以理解为投影后数据尽可能的分开，那么在数学中去表示数据的分散使用的是方差，我们都知道方差越大，数据越分散，方差的表达式如下： Var(a) = \\frac{1}{m} \\sum_{i=1}^{m} (a_i - \\mu)^2其中$\\mu$为样本均值，如果提前对样本做去中心化，则方差表达式为： Var(a) = \\frac{1}{m} \\sum_{i=1}^{m} (a_i)^2到现在，我们知道了以下几点： 对原始数据进行（线性变换）基变换可以对原始样本给出不同的表示 基的维度小于样本的维度可以起到降维的作用， 对基变换后新的样本求其方差，选取使其方差最大的基 那么再考虑另外一个问题？ 上面只是说明了优化目标，但并没有给出一个可行性的操作方案或者算法，因为只说明了要什么，但没说怎么做，所以继续进行探讨。 协方差从二维降到一维可以采用方差最大来选出能使基变换后数据分散最大的方向（基），但遇到高纬的基变换，当完成第一个方向（基）选择后，第二个投影方向应该和第一个“几乎重合在一起”，这样显然是没有用的，要有其他的约束，我们希望两个字段尽量表示更多的信息，使其不存在相关性。 数学上使用协方差表示其相关性。 Cov(a,b)= \\frac{1}{m} \\sum_{i=1}^{m}a_i b_i当Cov(a,b)=0时表示两个字段完全独立，也是我们优化的目标。 注意这里的 $a_i,b_i$是经过去中心化处理的。 协方差矩阵我们想要达到的目标与字段内方差及协方差有密切的关系，假如只有a、b两个字段，将他们按行组成矩阵X，表示如下： 然后用X乘以X的转置矩阵，并乘以系数 $\\frac{1}{m}$得： 可见，协方差矩阵是一个对称的矩阵，而且对角线是各个维度的方差，而其他元素是a 和 b的协方差，然后会发现两者被合并到了一个矩阵内。 协方差矩阵对角化我们的目标是使$\\frac{1}{m}\\sum_{i=1}^{m}a_ib_i=0$，根据上述的推导，可以看出优化目标是$C=\\frac{1}{m}XX^T$等价于协方差矩阵对角化。即除对角线外的其他元素（如$\\frac{1}{m} \\sum_{i=1}^{m}a_i b_i$）化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达成了优化目的。 这样说可能不是很明晰，我们进一步看下原矩阵和基变换后矩阵协方差矩阵的关系： 设原始数据矩阵为X，对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系： D=\\frac{1}{m}YY^T \\\\ = \\frac{1}{m}(PX)(PX)^T \\\\ = \\frac{1}{m} PXX^TP^T \\\\ =P(\\frac{1}{m} XX^T)P^T \\\\ = PCP^T \\\\ =P \\begin{pmatrix} \\frac{1}{m} \\sum_{i=1}^{m} a_i^2 & \\frac{1}{m} \\sum_{i=1}^{m} a_i b_i \\\\ \\frac{1}{m} \\sum_{i=1}^{m} a_ib_i & \\frac{1}{m} \\sum_{i=1}^{m} b_i^2 \\end{pmatrix} P^T可见我们要找的P不是别的，而是能让原始协方差矩阵对角化的P。换句话说，优化目标变成了寻找一个矩阵P，满足$PCP^T$是一个对角矩阵，并且对角元素按从大到小依次排列，那么P的前K行就是要寻找的基，用P的前K行组成的矩阵乘以X就使得X从N维降到了K维并满足上述优化条件。 我们希望投影后的方差最大化，于是优化目标可以改写为： \\underset{P}{max} \\, tr(PCP^T) \\\\ s.t. \\,PP^T=I利用拉格朗日函数可以得到： J(P) = tr(PCP^T) + \\lambda(PP^T - I)对P求导有$CP^T + \\lambda P^T = 0$，整理得： CP^T = (- \\lambda) P^T于是，只需对协方差矩阵C进行特征分解，对求得的特征值进行排序，再对 $P^T = (P_1, P_2, …, P_R)$取前K列组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。 PCA算法流程从上边可以看出，求样本$x_i$的$n’$维的主成分，其实就是求样本集的协方差矩阵$\\frac{1}{m}XX^T$的前$n’$维个特征值对应特征向量矩阵P，然后对于每个样本$x_i$，做如下变换$y_i = P x_i$，即达到PCA降维的目的。 具体的算法流程如下： 输入：n维的样本集 $X=(x_i, x_2,…,x_m)$，要降维到的维数$n’$ 输出：降维后的维度Y 对所有的样本集去中心化 $x_i = x_i - \\frac{1}{m} \\sum_{j=1}^{m}x_j$ 计算样本的协方差矩阵$C = \\frac{1}{m}XX^T$ 求出协方差矩阵对应的特征值和对应的特征向量 将特征向量按照特征值从大到小，从上到下按行排列成矩阵，取前k行组成矩阵P $Y=PX$即为降维到K维之后的数据 注意：有时候降维并不会指定维数，而是指定一个比例$t$，比如降维到原先的t比例。 PCA算法总结PCA算法的主要优点： 仅仅需要以方差衡量信息量，不受数据集意外因素的影响 各主成分之间正交，可消除原始数据各成分间的相互影响的因素 方法设计简单，主要运算是特征值分解，易于实现 PCA算法的主要缺点： 主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的可解释性强 方差小的非主成分也可能包含对样本差异的重要信息，因降维丢弃可能会对后续数据处理有影响 当样本特征维度较大时，需要巨大的计算量（比如，10000*10000，这时候就需要SVD[奇异值分解]，SVD不仅可以得到PCA降维的结果，而且可以大大的减小计算量） 稀疏编码稀疏编码（Sparse Coding）介绍在数学上，线性编码是指给定一组基向量$A=[a_1,a_2,…,a_p]$，将输入样本$x\\in R$表示为这些基向量的线性组合 x = \\sum _{i=1}^{p} z_i a_i = Az其中基向量的系数$z=[z_1,…,z_p]$称为输入样本x的编码，基向量A也称为字典（dictionary）。 编码是对d维空间中的样本x找到其在p维空间中的表示（或投影），其目标通常是编码的各个维度都是统计独立的，并且可以重构出输入样本。编码的关键是找到一组“完备”的基向量A，比如主成分分析等。但是是主成分分析得到的编码通常是稠密向量，没有稀疏性。 如果p个基向量刚好可以支撑p维的欧式空间，则这p个基向量是完备的，如果p个基向量可以支撑d维的欧式空间，并且p&gt;d，则这p个基向量是过完备，冗余的。“过完备”基向量一般指的是基向量个数远大于其支撑空间维度，因此这些基向量一般是不具备独立，正交等性质。 给定一组N个输入向量$x^1, …, x^N$，其稀疏编码的目标函数定义为： L(A,Z)= \\sum _{n=1}^{N}( || x^n - Az^n || ^2 + \\eta \\rho (z^n))其中$\\rho(.)$是一个稀疏性衡量函数，$\\eta$是一个超参数，用来控制稀疏性的强度。 对于一个向量$z \\in R$，其稀疏性定义为非零元素的比例。如果一个向量只有很少的几个非零元素，就说这个向量是稀疏的。稀疏性衡量函数$\\rho(z)$是给向量z一个标量分数。z越稀疏，$\\rho(z)$越小。 稀疏性衡量函数有多种选择，最直接的衡量向量z稀疏性的函数是$l_0$范式 \\rho(z) = \\sum _{i=1}^{p} I(|z_i| > 0)但$l_0$范数不满足连续可导，因此很难进行优化，在实际中，稀疏性衡量函数通常选用$l_1$范数 \\rho(z) = \\sum _{i=1}^{p} |z_i|或对数函数 \\rho(z) = \\sum _{i=1}^{p} log(1+z_i^2)或指数函数 \\rho(z) = \\sum _{i=1}^{p} -exp(-z_i^2)训练方法给定一组N个输入向量$x^1, … , x^N$，需要同时学习基向量A以及每个输入样本对应的稀疏编码$z^1, …,z^N$。 稀疏编码的训练过程一般用交替优化的方法进行（这一点和ALS很相似）。 （1）固定基向量A，对每个输入$x^n$ ，计算其对应的最优编码（原内容为减去稀疏性衡量函数，觉得不对） \\underset{x^n}{min} || x^n - Az^n ||^2 + \\eta \\rho (z^n), \\forall n \\in [1,N]（2）固定上一步得到的编码$z^1, …,z^N$，计算其最优的基向量 \\underset{A}{min} \\sum _{i=1}^{N} ( || x^n - Az^n ||^2 ) + \\lambda \\frac{1}{2} ||A||^2其中第二项为正则化项，$\\lambda$为正则化项系数。 稀疏编码优缺点稀疏编码的每一维都可以看作是一种特征，和基于稠密向量的分布式表示相比，稀疏编码具有更小的计算量和更好的可解释性等优点。 计算量 稀疏性带来的最大好处就是可以极大的降低计算量 可解释性 因为稀疏编码只有少数的非零元素，相当于将一个输入样本表示为少数几个相关的特征，这样我们可以更好的描述其特征，并易于理解 特征选择 稀疏性带来的另一个好处是可以实现特征的自动选择，只选择和输入样本相关的最少特征，从而可以更好的表示输入样本，降低噪声并减轻过拟合 自编码器自编码器（Auto-Encoder，AE）是通过无监督的方式来学习一组数据的有效编码。 假设有一组d维的样本$x^n \\in R^d, 1 \\leq n \\leq N$，自编码器将这组数据映射到特征空间得到每个样本的编码$z^n \\in R^p, 1 \\leq n \\leq N$，并且希望这组编码可以重构出原来的样本。 自编码器的结构可分为两部分：编码器（encoder）：$f: R^d -&gt; R^p$和解码器（decoder）：$R^p -&gt; R^d$ 自编码器的学习目标是最小化重构误差（reconstruction errors） L = \\sum_{n=1}^{N} || x^n -g(f(x^n)) ||^2 = \\sum || x^n -f \\cdot g(x^n) ||^2如果特征空间的维度p小雨原始空间的维度d，自编码器相当于是一种降维或特征抽取方法。如果$p \\geq d$，一定可以找到一组或多组解使得$f \\cdot g$为单位函数（Identity Function），并使得重构错误为0。但是这样的解并没有太多的意义，但是如果再加上一些附加的约束，就可以得到一些有意义的解，比如编码的稀疏性、取值范围，f和g的具体形式等。如果我们让编码只能取k个不同的值（k&lt;N），那么自编码器就可以转换为一个k类的聚类问题。 最简单的自编码器如下图所示的两层神经网络，输入层到隐藏层用来编码，隐藏层到输出层用来解码，层与层之间互相全连接。 对于样本x，中间隐藏层为编码： z = s(W^1 x + b^l)输出为重构的数据 x' = s(W^2 z + b^l)其中$W,b$为网格参数，$s(.)$为激活函数。如果令$W^2$等于$W^1$的转置，即$W^2=W^{(1)T}$，称为捆绑权重（tied weights）。 给定一组样本 $x^n \\in [0,1]^d, 1 \\leq n \\leq N$，其重构错误为： L = \\sum_{n=1}^{N} || x^n -x^{'n} ||^2 + \\lambda ||W||_F^2其中$\\lambda$为正则化系数，通过最小化重构误差，可以有效的学习网格的参数。 我们使用自编码器是为了得到有效的数据表示，因此在训练数据后，我们一般去掉解码器，只保留编码器，编码器的输出可以直接作为后续机器学习模型的输入。 稀疏自编码器自编码器除了可以学习低维编码之外，也学习高维的稀疏编码。假设中间隐藏层z的维度为p，大于输入样本的维度，并让z尽量稀疏，这就是稀疏自编码器（Sparse Auto-Encoder）。和稀疏编码一样，稀疏自编码器的优点是有很高的模型可解释性，并同时进行了隐式的特征选择。 通过给自编码器中隐藏单元z加上稀疏性限制，自编码器可以学习到数据中一些有用的结构。 堆叠自编码器对于很多数据来说，仅使用两层神经网络的自编码器还不足以获取一种好的数据表示，为了获取更好的数据表示，我们可以使用更深层的神经网络。深层神经网络作为自编码器提取的数据表示一般会更加抽象，能够很好的捕捉到数据的语义信息。在实践中经常使用逐层堆叠的方式来训练一个深层的自编码器，称为堆叠自编码器（Stacked Auto-Encoder，SAE）。堆叠自编码一般可以采用逐层训练（layer-wise training）来学习网络参数。 降噪自编码器降噪自编码器（Denoising Autoencoder）就是一种通过引入噪声来增加编码鲁棒性的自编码器。对于一个向量x，我们首先根据一个比例$\\mu$随机将x的一些维度的值设置为0，得到一个被损坏的向量$\\tilde x$。然后将被损坏的向量$\\tilde x$输入给自编码器得到编码z，并重构原始的无损输入x。 下图给出了自编码器和降噪自编码器的对比，其中$f_{\\theta}$为编码器，$g_{\\theta^’}$为解码器，$L(x,x’)$为重构错误。 降噪自编码器的思想十分简单，通过引入噪声来学习更鲁棒性的数据编码，并提高模型的泛化能力。 概率密度估计概率密度估计（Probabilistic Density Estimation）简称密度估计（Density Estimation），是基于一些观测样本来估计一个随机变量的概率密度函数。密度估计在机器学习和数学建模中应用十分广泛。 概率密度估计分为： 参数密度估计 非参数密度估计 参数密度估计参数密度估计（Parametric Density Estimation）是根据先验知识假设随机变量服从某种分布，然后通过训练样本来估计分布的参数。 令 $D = {\\{x^n\\}}_{i=1}^{N}$为某个未知分布中独立抽取的N个训练样本，假设这些样本服从一个概率分布函数$p(x|\\theta)$，其对数似然函数为： log\\,p(D|\\theta) = \\sum_{n=1}^{N}log\\,p(x^n|\\theta)要估计一个参数$\\theta ^{ML}$来使得： \\theta ^{ML} = \\underset{\\theta}{arg\\,max } \\sum_{n=1}^{N}log\\,p(x^n|\\theta)这样参数估计问题就转化为最优化问题。 正态分布中的参数密度估计假设样本$x \\in X$服从正态分布 $X \\sim N(\\mu,\\sigma^2)$，正态分布的表达式如下： X \\sim N(\\mu,\\sigma^2) = \\frac{1}{ \\sqrt{2\\pi} \\sigma^2} e^{- \\frac{(x-\\mu)^2}{2\\sigma^2}}求 $\\mu,\\sigma^2$的最大似然估计量。 $X$的概率密度为： f(x;\\mu,\\sigma^2) = \\frac{1}{ \\sqrt{2\\pi} \\sigma^2} e^{- \\frac{(x-\\mu)^2}{2\\sigma^2}}似然函数为： L(\\mu,\\sigma^2) = \\prod_{i=1}^{N} \\frac{1}{ \\sqrt{2\\pi} \\sigma^2} e^{- \\frac{(x-\\mu)^2}{2\\sigma^2}} \\\\ = (2\\pi)^{-\\frac{N}{2}} (\\sigma^2)^{-\\frac{N}{2}} e^{(-\\frac{1}{2\\sigma^2} \\sum_{i=1}^{N} (x_i - \\mu)^2)}对其求导可得对数似然函数为： Ln\\, L =-\\frac{N}{2} ln(2\\pi)-\\frac{N}{2} ln(\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{i=1}^{N}(x_i - \\mu)^2令： \\left\\{\\begin{matrix} \\frac{\\partial }{\\partial \\mu }ln\\, L = \\frac{1}{\\sigma^2} (\\sum_{i=1}^{N} x_i -N\\mu ) =0 & \\\\ \\\\ \\frac{\\partial }{\\partial \\sigma^2 }ln\\, L = - \\frac{N}{2\\sigma^2} + \\frac{1}{ (2\\sigma^2)^2} \\sum_{i=1}^{N}(x_i-\\mu)^2 =0& \\end{matrix}\\right.由前一式解得$\\tilde{\\mu}=\\frac{1}{N}\\sum_{i=1}^{N}x_i = \\bar{\\mu}$，代入后一式得$\\tilde{\\sigma^2}=\\frac{1}{N}\\sum_{i=1}^{N}(x_i-\\bar{x})^2$，因此得$\\mu,\\sigma^2$的最大似然估计为： \\tilde{\\mu} = \\bar{X},\\tilde{\\sigma^2}=\\frac{1}{N}(x_i - \\bar{x})^2多项分布中的参数密度估计假设样本服从K个状态的多态分布，令onehot向量$x\\in[0,1]^K$来表示第K个状态，即$x_k=1$，其余$x_{i,k \\neq k}=0$，则样本x的概率密度函数为： p(x|\\mu) = \\prod_{k=1}^{K}\\mu_k ^{x_K}其中$\\mu_k$为第k个状态的概率，并且满足$\\sum_{k=1}^{K} \\mu_k =1$。 数据集$D={\\{x^n\\}}_{n=1}^{N}$的对数似然函数为： log(D|\\mu) = \\sum_{n=1}^{N} \\sum_{k=1}^{K} x_n ^k log (\\mu _k)多项分布的参数估计为约束优化问题，引入拉格朗日乘子$\\lambda$，将原问题转化为无约束优化问题。 \\underset{\\mu, \\lambda}{ max} \\sum_{n=1}^{N} \\sum_{k=1}^{K} x_k ^n log(\\mu_k) + \\lambda (\\sum_{k=1}^{K} \\mu_k -1)上式分别对$\\mu_k,\\lambda$求偏，并令其等于0，得到： \\mu_k ^{ML} = \\frac{m_k}{N}, 1 \\leq N \\leq K其中$m_k = \\sum_{n=1}^{N} x_k ^n$为数据集中取值为第k个状态的样本数量。 在实际应用中，参数密度估计一般存在两个问题： （1）模型选择问题，即如何选择数据分布的密度函数，实际的数据分布往往是非常复杂的，而不是简单的正态分布或者多项分布。 （2）不可观测变量问题，即我们用来训练数据的样本只包含部分的可观测变量，还有一些非常关键的变量是无法观测的，这导致我们很难估计数据的真实分布。 （3）维度灾难问题，即高维的参数估计十分困难。随着维度的增加，估计参数所需要的样本量呈指数增加。在样本不足时会出现过拟合。 非参数密度估计非参数密度估计（Nonparametric Density Estimation）是不假设数据服从某种分布，通过将样本空间划分为不同的区域并估计每个区域的概率来近似数据的概率密度函数。 对于高纬空间中的一个随机向量x，假设其服从一个未知分布p(x)，则x落入空间中的小区域R的概率为： $P=\\int_{R} p(x)dx$。 给定N个训练样本$D=\\{x^n\\}_{n=1}^{N}$，落入区域R的样本数量K服从二项分布： P_K = \\binom{N}{K}P^K(1-P)^{1-K}其中$K/N$的期望为$E[K/N]=P$，方差为$var(K/N)=P(1-P)/N$。当N非常大时，我们可以近似认为：$P\\approx \\frac{K}{N}$，假设区域R足够小，其内部的概率密度是相同的，则有$P\\approx p(x)V$，其中V为区域R的提及，结合前边的两个公式，可得：$p(x)\\approx \\frac{K}{NV}$。 根据上式，要准确的估计p(x)需要尽量使得样本数量N足够大，区域体积V尽可能的小。但在具体的应用中吗，样本数量一般有限，过小的区域导致落入该区域的样本比较少，这样估计的概率密度就不太准确。 因此在实践中估计非参数密度通常使用两种方法： （1）固定区域大小V，统计落入不同区域的数量，这种方式包括直方图和核方法两种 （2）改变区域大小，以使得落入每个区域的样本数量为K，这种方法成为K近邻方法 直方图方法直方图（Histogram Method）是一种非常直观的估计连续变量密度函数的方法，可以表示为一种柱状图。 以一维随机变量为例，首先将其取值范围划分为M个连续的、不重叠的区间，每个区间的宽度为$\\Delta m$，给定$N$个训练样本，我们统计这些样本落入每个区间的数量$K_m$，然后将他们归一化为密度函数。 p_m = \\frac {K_m}{N\\Delta m},1 \\leq m \\leq M直方图的关键问题是如何选择一个合适的$\\Delta m$，如果该值太小，那么落入每个区间的样本会特别少，其估计的区间密度也会有很大的随机性，如果该值过大，其估计的密度函数会变得十分平滑。下图给出了两个直方图的例子，其中蓝色表示真实的密度函数，红色表示直方图估计的密度函数。 直方图通常用来处理低维随机变量，可以非常快速的对数据的分布进行可视化，但其缺点是很难扩展到高维变量，假设一个d维的随机变量，如果每一维都划分为M个空间，那么整个空间的区域数量为$M^d$，直方图估计的方法会随着空间的增大而指数增长，从而形成维度灾难（Curse Of Dimensionality） 核方法核密度估计（Kernel Density Estimation），也叫Parzen窗方法，是一种直方图方法的改进。 假设$R$为$d$维空间中的一个以点x为中心的“超立方体”，并定义核函数 \\phi (\\frac{z-x}{h}) = \\left\\{\\begin{matrix} 1 \\,\\,\\,\\,\\,\\, if \\, |z_i - x_i|< \\frac{h}{2}, 1 \\leq i \\leq d & \\\\ 0 \\,\\,\\,\\,\\,\\, else & \\end{matrix}\\right.来表示一个样本是否落入该超立方体中，其中$h$为超立方体的边长，也称为核函数的密宽度。 给定$N$个训练样本$D$，落入区域$R$的样本数量$K$为： K = \\sum_{n=1}^{K} \\phi (\\frac {x^n - x}{h})则点$x$的密度估计为： p(x) = \\frac{K}{Nh^d} =\\frac{1}{Nh^d} \\sum_{n=1}^{K} \\phi (\\frac {x^n - x}{h})其中$h^d$表示区域$R$的体积。 除了超立方体的核函数意外之外，我们还可以选择更加平滑的核函数，比如高斯核函数： \\phi (\\frac {z-x}{h}) = \\frac {1}{ (2\\pi)^{\\frac{1}{2}} h} exp(- \\frac{||z-x||^2}{2h^2})其中$h^2$可以看做是高斯核函数的方差，这样点$x$的密度估计为： p (x) = \\frac{1}{N} \\sum_{n=1}^{N} \\frac {1}{ (2\\pi)^{\\frac{1}{2}} h} exp(- \\frac{||z-x||^2}{2h^2})K近邻方法核密度估计方法中的核宽度是固定的，因此同一个宽度可能对高密度的区域过大，而对低密度的区域过小。一种更加灵活的方式是设置一种可变宽度的区域，并使得落入每个区域中的样本数量固定为K。 要估计点x的密度，首先找到一个以x为中心的球体，使得落入球体的样本数量为K，然后根据公式$p(x)\\approx \\frac{K}{NV}$就可以计算出点x的密度。因为落入球体的样本也是离x最近的K个样本，所以这种方法也称为K近邻（K-Nearest Neughbor）方法。 在K近邻方法中，K值的选择十分重要，如果K太小，无法有效的估计密度函数，而K太大也会使局部的密度不准确，并且会增加计算开销。 K近邻方法也经常用于分类问题，称为K近邻分类器。 当K=1时为最近邻分类器。 最近邻分类器的一个性质是，当 $N \\rightarrow \\infty$，其分类错误率不超过最优分类器错误率的两倍。 总结无监督学习是一种十分重要的机器学习方法，无监督学习问题主要可以分为聚类，特征学习，密度估计等几种类型。但是无监督学习并没有像有监督学习那样取得广泛的成功，主要原因在于其缺少有效客观评价的方法，导致很难衡量一个无监督学习方法的好坏。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"无监督学习","slug":"无监督学习","permalink":"http://thinkgamer.cn/tags/无监督学习/"},{"name":"密度估计","slug":"密度估计","permalink":"http://thinkgamer.cn/tags/密度估计/"}]},{"title":"冷启动中的多避老虎机问题（Multi-Armed Bandit，MAB）","slug":"RecSys/冷启动中的多避老虎机问题（Multi-Armed Bandit，MAB）","date":"2019-10-15T02:50:47.000Z","updated":"2019-10-18T08:56:37.262Z","comments":true,"path":"2019/10/15/RecSys/冷启动中的多避老虎机问题（Multi-Armed Bandit，MAB）/","link":"","permalink":"http://thinkgamer.cn/2019/10/15/RecSys/冷启动中的多避老虎机问题（Multi-Armed Bandit，MAB）/","excerpt":"","text":"转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/102560272博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki 推荐系统中有两个很重要的问题：EE问题和冷启动。在实际的场景中很好的解决这两个问题又很难，比如冷启动，我们可以基于热门、用户、第三方等信息进行半个性化的推荐，但很难去获得用户的真实兴趣分布。那么有没有一种算法可以很好的解决这个问题呢？答案就是：Bandit。 Bandit算法与推荐系统在推荐系统领域里，有两个比较经典的问题常被人提起，一个是EE问题，另一个是用户冷启动问题。 EE问题又叫Exploit-Explore。 Exploit表示的是对于用户已经确定的兴趣当然要迎合。 Explore表示的如果仅对用户进行兴趣投放，很快就会看厌，所以要不断的探索用户的新兴趣 所以在进行物品推荐时，不仅要投其所好，还要进行适当的长尾物品挖掘。 用户冷启动问题，也就是面对新用户时，如何能够通过若干次实验，猜出用户的大致兴趣。 这两个问题本质上都是如何选择用户感兴趣的主题进行推荐，比较符合Bandit算法背后的MAB问题。 比如，用Bandit算法解决冷启动的大致思路如下：用分类或者Topic来表示每个用户兴趣，也就是MAB问题中的臂（Arm），我们可以通过几次试验，来刻画出新用户心目中对每个Topic的感兴趣概率。这里，如果用户对某个Topic感兴趣（提供了显式反馈或隐式反馈），就表示我们得到了收益，如果推给了它不感兴趣的Topic，推荐系统就表示很遗憾（regret）了。如此经历“选择-观察-更新-选择”的循环，理论上是越来越逼近用户真正感兴趣的Topic的。 Bandit算法来源Bandit算法来源于历史悠久的赌博学，它要解决的问题是这样的： 一个赌徒，要去摇老虎机，走进赌场一看，一排老虎机，外表一模一样，但是每个老虎机吐钱的概率可不一样，他不知道每个老虎机吐钱的概率分布是什么，那么每次该选择哪个老虎机可以做到最大化收益呢？这就是多臂赌博机问题（Multi-armed bandit problem, K-armed bandit problem, MAB）。 怎么解决这个问题呢？最好的办法是去试一试，不是盲目地试，而是有策略地快速试一试，这些策略就是Bandit算法。 这个多臂问题，推荐系统里很多问题都与它类似： 假设一个用户对不同类别的内容感兴趣程度不同，那么我们的推荐系统初次见到这个用户时，怎么快速地知道他对每类内容的感兴趣程度？这就是推荐系统的冷启动。 假设我们有若干广告库存，怎么知道该给每个用户展示哪个广告，从而获得最大的点击收益？是每次都挑效果最好那个么？那么新广告如何才有出头之日？ 我们的算法工程师又想出了新的模型，有没有比A/B test更快的方法知道它和旧模型相比谁更靠谱？ 如果只是推荐已知的用户感兴趣的物品，如何才能科学地冒险给他推荐一些新鲜的物品？ Bandit算法需要量化一个核心问题：错误的选择到底有多大的遗憾？能不能遗憾少一些？常见Bandit算法有哪些呢？往下看 Thompson sampling1、Beta分布Thompson Sampling是基于Beta分布进行的，所以首先看下什么是Beta分布？ Beta分布可以看作是一个概率的概率分布，当你不知道一个东西的具体概率是多少时，他可以给出所有概率出现的可能性。Beta是一个非固定的公式，其表示的是一组分布（这一点和距离计算中的闵可夫斯基距离类似）。 比如： 二项分布（抛n次硬币，正面出现k次的概率） P(S=k)=\\binom{n}{k} p^k (1-p)^{n-k}几何分布（抛硬币，第一次抛出正面所需的次数的概率） P(T=t)= (1-p)^{t-1} p帕斯卡分布（抛硬币，第k次出现正面所需次数的概率） P(Y_k=t)=\\binom{t-1}{k-1} p^{k-1} (1-p)^{t-k}p去找一个统一的公式去描述这些分布，就是Beta分布： Beta(x| \\alpha,\\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha-1} (1-x)^\\beta其中 $B(\\alpha, \\beta)$是标准化函数，他的作用是使总概率和为1，$\\alpha, \\beta$为形状参数，不同的参数对应的图像形状不同，他不但可以表示常见的二项分布、几何分布等，还有一个好处就是，不需要去关系某次实验结果服从什么分布，而是利用$\\alpha, \\beta$的值就可以计算出我们想要的统计量。 常见的参数对应的图形为： $Beta(\\alpha, \\beta)$的常见的统计量为： 众数为：$\\frac {\\alpha-1}{\\alpha + \\beta -1}$ 期望为：$\\mu = E(x)= \\frac {\\alpha} {\\alpha + \\beta}$ 方差为：$Var(x) = E(x - \\mu)^2 = \\frac { \\alpha \\beta } { (\\alpha + \\beta)^2 (\\alpha + \\beta +1) }$ 2、Beta分布的例子网上资料中一个很常见的例子是棒球运动员的，这里进行借鉴。 棒球运动有一个指标是棒球击球率(batting average)，就是用一个运动员击中的球数除以击球的总数，我们一般认为0.266是正常水平的击球率，而如果击球率高达0.3就被认为是非常优秀的。 现在有一个棒球运动员，我们希望能够预测他在这一赛季中的棒球击球率是多少。你可能就会直接计算棒球击球率，用击中的数除以击球数，但是如果这个棒球运动员只打了一次，而且还命中了，那么他就击球率就是100%了，这显然是不合理的，因为根据棒球的历史信息，我们知道这个击球率应该是0.215到0.36之间才对啊。 对于这个问题，我们可以用一个二项分布表示（一系列成功或失败），一个最好的方法来表示这些经验（在统计中称为先验信息）就是用beta分布，这表示在我们没有看到这个运动员打球之前，我们就有了一个大概的范围。beta分布的定义域是(0,1)这就跟概率的范围是一样的。 接下来我们将这些先验信息转换为beta分布的参数，我们知道一个击球率应该是平均0.27左右，而他的范围是0.21到0.35，那么根据这个信息，我们可以取$\\alpha$=81,$\\beta$=219 之所以取这两个参数是因为： beta分布的均值是：$\\frac{81} {81 + 219}=0.27$ 从图中可以看到这个分布主要落在了(0.2,0.35)间，这是从经验中得出的合理的范围。 在这个例子里，我们的x轴就表示各个击球率的取值，x对应的y值就是这个击球率所对应的概率。也就是说beta分布可以看作一个概率的概率分布。 有了这样的初始值，随着运动的进行，其表达式可以表示为： Beta(\\alpha_0 + hits , \\beta_0 + misses)其中 $\\alpha_0, \\beta_0$是一开始的参数，值为81，219。当击中一次球是 hits + 1，misses不变，当未击中时，hits不变，misses+1。这样就可以在每次击球后求其最近的平均水平了。 3、Thompson SmaplingThompson sampling算法简单实用，简单介绍一下它的原理，要点如下： 假设每个臂是否产生收益，其背后有一个概率分布，产生收益的概率为p。 我们不断地试验，去估计出一个置信度较高的“概率p的概率分布”就能近似解决这个问题了。 怎么能估计“概率p的概率分布”呢？ 答案是假设概率p的概率分布符合beta(wins, lose)分布，它有两个参数: wins, lose。 每个臂都维护一个beta分布的参数。每次试验后，选中一个臂，摇一下，有收益则该臂的wins增加1，否则该臂的lose增加1。 每次选择臂的方式是：计算每个臂现有的beta分布的平均水平，选择所有臂产生的随机数中最大的那个臂去摇。 4、TS的Python实现1234567891011121314151617181920212223import numpy as npimport randomdef ThompsonSampling(wins, trials): pbeta = [0] * N for i in range(0, len(trials)): pbeta[i] = np.random.beta(wins[i] + 1, trials[i] - wins[i] + 1) choice = np.argmax(pbeta) trials[choice] += 1 if random.random() &gt; 0.5: wins[choice] += 1T = 10000 # 实验次数N = 10 # 类别个数# 臂的选择总次数trials = np.array([0] * N )# 臂的收益wins = np.array([0] * N )for i in range(0, T): ThompsonSampling(wins, trials)print(trials)print(wins)print(wins/trials) UCB1、UCB的原理UCB（Upper Confidence Bound，置信区间上界）可以理解为不确定性的程度，区间越宽，越不确定，反之就越确定，其表达式如下： score(i) = \\frac {N_i}{T} + \\sqrt{ \\frac{2 ln T}{N_i}}其中 Ni 表示第i个臂收益为 1 的次数，T表示选择的总次数 公式分为左右两部分，左侧（+左侧部分）表示的是候选臂i到目前为止的平均收益，反应的是它的效果。右侧（+右侧部分）叫做Bonus，本质上是均值的标准差，反应的是候选臂效果的不确定性，就是置信区间的上边界。 统计学中的一些统计量表达的含义 如果一个臂的收益很少，即Ni很小，那么他的不确定性就越大，在最后排序输出时就会有优势，bouns越大，候选臂的平均收益置信区间越宽，越不稳定，就需要更多的机会进行选择。反之如果平均收益很大，即+号左侧户数很大，在选择时也会有被选择的机会。 2、UCB的Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import numpy as np# 定义 T = 1000 个用户，即总共进行1000次实现T = 1000# 定义 N = 10 个标签，即 N 个 物品N = 10# 保证结果可复现，设置随机数种子np.random.seed(888)# 每个物品的累积点击率（理论概率）true_rewards = np.random.uniform(low=0, high=1, size= N)# true_rewards = np.array([0.5] * N)# 每个物品的当前点击率now_rewards = np.zeros(N)# 每个物品的点击次数chosen_count = np.zeros(N)total_reward = 0# 计算ucb的置信区间宽度def calculate_delta(T, item): if chosen_count[item] == 0: return 1 else: return np.sqrt( 2 * np.log( T ) / chosen_count[item])# 计算UCBdef ucb(t, N): # ucb得分 upper_bound_probs = [ now_rewards[item] + calculate_delta(t,item) for item in range(N) ] item = np.argmax(upper_bound_probs) # 模拟伯努利收益 # reward = sum(np.random.binomial(n =1, p = true_rewards[item], size=20000)==1 ) / 20000 reward = np.random.binomial(n =1, p = true_rewards[item]) return item, rewardfor t in range(1,T+1): # 为第 t个用户推荐一个物品 item, reward = ucb(t, N) # print(\"item is %s, reward is %s\" % (item, reward)) # 一共有多少用户接受了推荐的物品 total_reward += reward chosen_count[item] += 1 # 更新物品的当前点击率 now_rewards[item] = ( now_rewards[item] * (t-1) + reward) / t # print(\"更新后的物品点击率为：%s\" % (now_rewards[item])) # 输出当前点击率 / 累积点击率 # print(\"当前点击率为: %s\" % now_rewards) # print(\"累积点击率为: %s\" % true_rewards) diff = np.subtract( true_rewards, now_rewards) print(diff[0]) print(total_reward) 3、UCB的推导观测 1：假设一个物品被推荐了k次，获取了k次反馈（点击 or 不点击），可以计算出物品被点击的平均概率 当k 接近于正无穷时，p’ 会接近于真实的物品被点击的概率 p' = \\frac {\\sum reward_i}{k}观测 2：现实中物品被点击的次数不可能达到无穷大，因此估计出的被点击的概率 p’ 和真实的点击的概率 p 总会存在一个差值 d，即： p'-d \\leqslant p \\leqslant p'+d最后只需要解决差值 d 到底是怎么计算的？ 首先介绍霍夫丁不等式（Chernoff-Hoeffding Bound），霍夫丁不等式假设reward_1, … , reward_n 是在[0,1]之间取值的独立同分布随机变量，用p’ 表示样本的均值，用p表示分布的均值，那么有： P\\{|p'-p| \\leqslant \\delta \\} \\geqslant 1 - 2e^{-2n\\delta ^2}当 $\\delta$ 取值为$\\sqrt { 2In T /n}$ （其中 T 表示有物品被推荐的次数，n表示有物品被点击的次数），可以得到： P\\{|p'-p| \\leqslant \\sqrt { \\frac{2In T }{n}} \\} \\geqslant 1 - \\frac{ 2 }{ T^4}也就是说： p' - \\sqrt { \\frac{2In T }{n}} \\leqslant p \\leqslant p' + \\sqrt { \\frac{2In T }{n}}是以 1 - 2/T^4 的概率成立的，当T=2时，成立的概率为0.875当T=3时，成立的概率为0.975当T=4时，成立的概率为0.992可以看出 $d = \\sqrt { \\frac{2In T }{n}}$ 是一个不错的选择。 Epsilon-Greedy1、算法原理这是一个朴素的Bandit算法，有点类似模拟退火的思想： 选一个（0,1）之间较小的数作为epsilon； 每次以概率epsilon做一件事：所有臂中随机选一个； 每次以概率1-epsilon 选择截止到当前，平均收益最大的那个臂。 是不是简单粗暴？epsilon的值可以控制对Exploit和Explore的偏好程度。越接近0，越保守，只选择收益最大的。 2、Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243import randomclass EpsilonGreedy(): def __init__(self, epsilon, counts, values): self.epsilon = epsilon self.counts = counts self.values = values def initialize(self, n_arms): self.counts = [0 for col in range(n_arms)] self.values = [0.0 for col in range(n_arms)] def select_arm(self): if random.random() &gt; self.epsilon: return self.values.index( max(self.values) ) else: # 随机返回 self.values 中个的一个 return random.randrange(len(self.values)) def reward(self): return 1 if random.random() &gt; 0.5 else 0 def update(self, chosen_arm, reward): self.counts[chosen_arm] = self.counts[chosen_arm] + 1 n = self.counts[chosen_arm] value = self.values[chosen_arm] new_value = ((n - 1) * value + reward ) / float(n) self.values[chosen_arm] = round(new_value,4)n_arms = 10algo = EpsilonGreedy(0.1, [], [])algo.initialize(n_arms)for t in range(100): chosen_arm = algo.select_arm() reward = algo.reward() algo.update(chosen_arm, reward)print(algo.counts)print(algo.values) 朴素Bandit算法最朴素的Bandit算法就是：先随机试若干次，计算每个臂的平均收益，一直选均值最大那个臂。这个算法是人类在实际中最常采用的，不可否认，它还是比随机乱猜要好。 Python实现比较简单，这里就不做演示了。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"http://thinkgamer.cn/tags/推荐算法/"},{"name":"冷启动，Bandit","slug":"冷启动，Bandit","permalink":"http://thinkgamer.cn/tags/冷启动，Bandit/"}]},{"title":"神经网络中的网络优化和正则化（四）之正则化","slug":"TensorFlow/神经网络中的网络优化和正则化（四）之正则化","date":"2019-09-27T00:15:10.000Z","updated":"2019-10-14T12:28:36.844Z","comments":true,"path":"2019/09/27/TensorFlow/神经网络中的网络优化和正则化（四）之正则化/","link":"","permalink":"http://thinkgamer.cn/2019/09/27/TensorFlow/神经网络中的网络优化和正则化（四）之正则化/","excerpt":"","text":"引言神经网络中的网络优化和正则化问题介绍主要分为一，二，三，四篇进行介绍（如下所示），本篇为最后一篇主要介绍神经网络中的网络正则化。 第一篇包括 网络优化和正则化概述 优化算法介绍 第二篇包括 参数初始化 数据预处理 逐层归一化 第三篇包括 超参数优化 第四篇包括 网络正则化 机器学习模型中的关键是泛化问题，即样本在真实数据集上的期望风险最小化，而在训练集上的经验风险最小化和期望风险并不一致。由于神经网络的拟合能力很强，其在训练集上的训练误差会降的很小，从而导致过拟合。 正则化（Regularization）是一类通过限制模型复杂度，从而避免过拟合，提高模型泛化能力的一种方法，包括引入一些约束规则，增加先验，提前终止等。 在传统的机器学习模型中，提高模型泛化能力的主要方法是限制模型复杂度，比如$l_1,l_2$正则，但是在训练深层神经网络时，特别是在过度参数（OverParameterized）时，$l_1,l_2$正则化不如机器学习模型中效果明显，因此会引入其他的一些方法，比如：数据增强，提前终止，丢弃法，继承法等。 $l_1,l_2$正则$l_1,l_2$正则是机器学习中常用的正则化方法，通过约束参数的$l_1,l_2$范数来减少模型在训练数据上的过拟合现象。 通过引入$l_1,l_2$正则，优化问题变为： a\\theta ^* = \\underset{a}{ arg \\, min } \\frac{1}{N} L ( y^n, f(x^n, \\theta))+\\lambda l_p(\\theta)$L$为损失函数，$N$为训练的样本数量，$f(.)$为待学习的神经网络，$\\theta$为参数，$l_p$为$l_1,l_2$正则中的一个，$\\lambda$为正则项系数。 带正则化的优化问题等价于下面带约束条件的优化问题： \\theta ^* = \\underset{a}{ arg \\, min } \\frac{1}{N} L ( y^n, f(x^n, \\theta)) \\\\ subject \\, to \\, l_p(\\theta) \\leq 1下图给出了不同范数约束条件下的最优化问题示例： 上图中红线表示$l_p$范数，黑线表示$f(\\theta)$的等高线（简单起见，这里用直线表示） 从上图最左侧图可以看出，$l_1$范数的约束条件往往会使最优解位于坐标轴上，从而使用最终的参数为稀疏向量，此外$l_1$范数在零点不可导，常用下式来代替： l_1(\\theta) = \\sum_{i} \\sqrt{\\theta_i ^2 + \\epsilon }其中$\\epsilon$为一个非常小的常数。 一种折中的方法是弹性网络正则化（Elastic Net Regularization） ，同时加入$l_1, l_2$正则，如下： a\\theta ^* = \\underset{a}{ arg \\, min } \\frac{1}{N} L ( y^n, f(x^n, \\theta)_+\\lambda_1 l_1(\\theta) + \\lambda_2 l_2(\\theta)其中$\\lambda_1, \\lambda_2$分别是正则化项的参数。 权重衰减权重衰减（Weight Deacy） 也是一种有效的正则化方法，在每次调参时，引入一个衰减系数，表示式为： \\theta_t \\leftarrow (1-w)\\theta_{t-1} - \\alpha g_t其中$g_t$为第t次更新时的梯度，$\\alpha$为学习率，$w$为权重衰减系数，一般取值比较小，比如0.0005。在标准的随机梯度下降中，权重衰减和$l_2$正则达到的效果相同，因此，权重衰减在一些深度学习框架中用$l_2$正则来代替。但是在较为复杂的优化方法中，两者并不等价。 提前终止提前终止（early stop） 对于深层神经网络而言是一种简单有效的正则化方法，由于深层神经网络拟合能力很强，比较容易在训练集上过拟合，因此在实际操作时往往产出一个和训练集独立的验证集，并用在验证集上的错误来代表期望错误，当验证集上的错误不再下降时，停止迭代。 然而在实际操作中，验证集上的错误率变化曲线并不是一条平衡的曲线，很可能是先升高再降低，因此提前停止的具体停止标准需要根据实际任务上进行优化。 丢弃法当训练一个深层神经网络时，可以随机丢弃一部分神经元（同时丢弃其对应的连接边）来避免过拟合，这种方法称为 丢弃法（Dropout Method）。每次丢弃的神经元为随机的，对于每一个神经元都以一个概率p来判断要不要停留，对于每一个神经层 $y=f(Wx + b)$，我们可以引入一个丢弃函数$d(.)$使得$y=f(Wd(x)+b)$。丢弃函数的定义为： d(x) = \\left\\{\\begin{matrix} m \\odot x, When \\, Train\\\\ px, When \\, Test \\end{matrix}\\right.其中$m \\in \\{0,1\\}^d$是丢弃掩码（dropout mask），通过以概率为p的贝努力分布随机生成，$p$可以通过一个验证集选取一个最优值，也可以设置为0.5， 这样对大部分网络和任务比较有效。在训练时，神经元的平均数量为原来的$p$倍，而在测试时，所有的神经元都可以是激活的，这会造成训练时和测试时的网络结构不一致，为了缓解这个问题，在测试时，需要将每一个神经元的输出乘以$p$，也相当于把不同的神经网络做了一个平均。 下图给出了一个网络经过dropout的示例。 一般来讲，对于隐藏层的神经元，丢弃率$p=0.5$时最好，这样当训练时有一半的神经元是丢弃的，随机生成的网络结构具有多样性。对于输入层的神经元，其丢弃率往往设置为更接近于1的数，使得输入变化不会太大，对输入层的神经元进行丢弃时，相当于给数据增加噪声，提高网络的鲁棒性。 丢弃法一般是针对神经元进行随机丢弃，但是也可以扩展到神经元之间的连接进行随机丢弃，或每一层进行随机丢弃。 丢弃法有两种解释： （1）集成学习的解释每做一次丢弃，相当于从原始的网络中采样得到一个子网络，如果一个神经网络有n个神经元，那么可以采样出$2^n$个子网络，每次训练都相当于是训练一个不同的子网络，这些子网络都共享最开始的参数。那么最终的网络可以看成是集成了指数级个不同风格的组合模型。 （2）贝叶斯学习的解释 丢弃法也可以解释为一个贝叶斯学习的近似，用$y=f(x,\\theta)$表示一个要学习的网络，贝叶斯学习是假设参数$\\theta$为随机向量，并且先验分布为$q(\\theta)$，贝叶斯方法的预测为： E_{q(\\theta)}[y] = \\int_{q}f(x,\\theta)q(\\theta)d\\theta \\approx \\frac{1}{M}\\sum_{m=1}^{M}f(x, \\theta_m)其中$f(x, \\theta_m)$为第m次应用丢弃方法后的网络，其参数$\\theta_m$为全部参数$\\theta$的一次采样。 数据增强深层神经网络的训练需要大量的样本才能取得不错的效果，因为在数据量有限的情况下，可以通过 数据增强（Data Augmentation）来增加数据量，提高模型鲁棒性，避免过拟合。目前数据增强主要应用在图像数据上，在文本等其他类型的数据还没有太好的方法。 图像数据增强主要通过算法对图像进行转换，引入噪声方法增强数据的多样性，增强的方法主要有： 转换（Rotation）：将图像按照顺时针或者逆时针方向随机旋转一定的角度； 翻转（Flip）：将图像沿水平或者垂直方向随机翻转一定的角度； 缩放（Zoom in/out）：将图像放大或者缩小一定的比例； 平移（Shift）：将图像按照水平或者垂直的方法平移一定步长； 加噪声（Noise）：加入随机噪声。 标签平滑在数据增强中，可以通过给样本加入随机噪声来避免过拟合，同样也可以给样本的标签引入一定的噪声。假设在训练数据集中，有一些样本的标签是被错误标注的，那么最小化这些样本上的损失函数会导致过拟合。一种改善的正则化方法是标签平滑（label smothing），即在输出标签中随机加入噪声，来避免模型过拟合。 一个样本$x$的标签一般用onehot向量表示，如下： y = [0,...,0,1,.....,1]^T这种标签可以看作硬目标（hard targets），如果使用softmax分类器并使用交叉熵损失函数，最小化损失函数会使得正确类和其他类权重差异很大。根据softmax函数的性质可以知道，如果要使得某一类的输出概率接近于1，其未归一化的得分要远大于其他类的得分，这样可能会导致其权重越来越大，并导致过拟合。i 此外如果标签是错误的，会导致严重的过拟合现象，为了改善这种情况，我们可以引入一个噪声会标签进行平滑，即假设样本以$\\epsilon$的概率为其他类，平滑后的标签为： \\tilde{y} =[ \\frac{ \\epsilon }{K-1} ,...,\\frac{ \\epsilon }{K-1} ,1- \\epsilon,\\frac{ \\epsilon }{K-1},....,\\frac{ \\epsilon }{K-1}]^T其中$K$为标签数量，这种标签可以看作是软目标（soft targets）。标签平滑可以避免模型的输出过拟合到硬目标上，并且通常不会降低其分类能力。 上边的标签平滑方法是给其他$K-1$个标签相同的概率$\\frac{\\epsilon}{K-1}$，没有考虑目标之间的相关性。一种更好的做法是按照类别相关性来赋予其他标签不同的概率，比如先训练另外一个更复杂的教师网络，并使用大网络的输出作为软目标进行训练学生网络，这种方法也称为知识精炼（Knowledge Distillation）。 总结至此，神经网络中的网络优化和正则化（一）（二）（三）（四）篇已经完成，如下： 神经网络中的网络优化和正则化（一）之学习率衰减和动态梯度方向 神经网络中的网络优化和正则化（二）之参数初始化/数据预处理/逐层归一化 神经网络中的网络优化和正则化（三）之超参数优化 神经网络中的网络优化和正则化（四）之正则化 神经网络中的网络优化和正则化即是对立又统一的关系，一方面我们希望找到一个最优解使得模型误差最小，另一方面又不希望得到一个最优解，可能陷入过拟合。优化和正则化的目标是期望风险最小化。 目前在深层神经网络中泛化能力还没有很好的理论支持，在传统的机器学习上比较有效的$l_1,l_2$正则化在深层神经网络中作用也比较有限，而一些经验性的做法，比如随机梯度下降和提前终止，会更加有效。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"神经网络中的网络优化和正则化（三）之超参数优化","slug":"TensorFlow/神经网络中的网络优化和正则化（三）之超参数优化","date":"2019-09-25T12:53:25.000Z","updated":"2019-10-14T12:28:36.842Z","comments":true,"path":"2019/09/25/TensorFlow/神经网络中的网络优化和正则化（三）之超参数优化/","link":"","permalink":"http://thinkgamer.cn/2019/09/25/TensorFlow/神经网络中的网络优化和正则化（三）之超参数优化/","excerpt":"","text":"公众号标题：神经网络中的优化方法之学习率衰减和动态梯度方向 引言神经网络中的网络优化和正则化问题介绍主要分为一，二，三，四篇进行介绍。 第一篇包括 网络优化和正则化概述 优化算法介绍 第二篇包括 参数初始化 数据预处理 逐层归一化 第三篇包括 超参数优化 第四篇包括 网络正则化 无论是神经网络还是机器学习都会存在很多的超参数，在神经网络中，常见的超参数有： 网络结构：包括神经元之间的连接关系，层数，每层的神经元数量，激活函数的类型等 优化参数：包括优化方法，学习率，小批量样本数量 正则化系数 超参数优化（Hyperparamter Optimization） 主要存在两方面的困难： 超参数优化是一个组合优化问题，无法像一般参数那样通过梯度优化的方法来求解，也没有一种通用的优化方法 评估一组超参数配置时间代价很高，从而导致一些优化算法（比如时间演化算法）在超参数优化中难以应用 对于超参数的设置，一般有三种比较简单的优化方法，人工搜索，网格搜素，随机搜索 网格搜索网格搜索（grid search）是一种通过尝试所有超参数的组合来寻找一组合适的超参数组合的方法。如果参数是连续，可以将其离散化。比如“学习率”，我们可以根据经验选取几个值:$\\alpha \\in {0.01, 0.1, 0.5, 1.0}$。 一般而言，对于连续的超参数，不能采用等间隔的方式进行划分，需要根据超参数自身的特点进行离散化。 网格搜索根据不同的参数组合在测试集上的表现，选择一组最优的参数作为结果。 随机搜索不同超参数对模型的影响不同，有的超参数（比如正则项系数）对模型的影响有限，有的超参数（比如学习率）对模型的影响比较大，这时候采用网格搜索就会在影响不大的超参数上浪费时间。 一种在实践中比较有效的方法是对超参数进行随机组合（比如不太重要的参数进行随机抽取，重要的参数可以按照网格搜索的方式选择），选择表现最好的参数作为结果,这就是随机搜索（random search） 网格搜索和随机搜索没有利用超参数之间的相关性，即如果模型的超参数组合比较类似，其模型的性能表现也是比较接近的，这时候网格搜索和随机搜索就比较低效。下面介绍两种自适应的超参数优化方法：贝叶斯优化和动态资源分配。 动态资源分配在超参数优化中，每组超参数配置的评估代价很高，如果我们可以在较早的阶段就估计出该组超参数效果就比较差，然后提前终止该组参数的测试，从而将更多的资源留给其他。这个问题可以归结为多臂赌博机问题的一个泛化问题，即最优臂问题（best-arm problem），即在给定有限次数的情况下，如何获取最大收益。 动态资源分配的一种有效方法是逐层减半（successive halving），将超参数优化看作是一种非随机的最优臂问题。该方法出自2015年的一篇论文，论文下载地址为：https://arxiv.org/pdf/1502.07943.pdf 假设要尝试N组超参数配置，总共可利用的摇臂资源次数为B，我们可以通过$T= [log_2N]-1$轮逐次减半的方法来选取最优的配置，具体计算过程如下： 在逐次减半方法中，N的设置十分重要，如果N越大，得到最佳配置的机会也越大，但每组配置分配到的资源就越少，这样早期的评估结果可能不准确，反之，如果N越小，每组超参数配置的评估就会越准确，但也有可能无法得到最优的参数配置。因此如何设置N是评估“利用-探索”的一个关键因素，一种改进的方法是：HyperBrand方法，通过尝试不同的N来寻找最优的参数配置。对应的论文下载地址为：https://openreview.net/pdf?id=ry18Ww5ee 贝叶斯优化贝叶斯优化背后的思想贝叶斯优化（Bayesian optimization）是一种自适应的超参数优化方法，根据当前已经试验的超参数组合，来预测下一个可能带来最大收益的组合。 对于同一个算法来讲，不同的超参数组合其实是对应不同的模型，而贝叶斯优化可以帮助我们在众多模型中寻找性能最优的模型，虽然我们可以使用交叉验证的思想寻找更好的超参数组合，但是不知道需要多少样本才能从一系列候选模型中选择出最优的模型。这就是为什么贝叶斯优化能够减少计算任务加速优化过程的进程，同样贝叶斯优化不依赖于人为猜测需要样本量的多少，这种优化计算是基于随机性和概率分布得到的。简单来说，当我们把第一条样本送到模型中的时候，模型会根据当前的样本点构建一条直接，当把第二天样本送到模型中的时候，模型将结合这两个点并从前面的线出发绘制一条修正的线，当输送第三个样本的时候，模型绘制的就是一条非线性曲线，当样本数据增加时，模型所结合的曲线就会变得更多，这就像统计学里的抽样定理，即我们从样本参数出发估计总体参数，且希望构建出的估计量与总体参数相合，无偏估计。下图为非线性目标函数曲线图，对于给定的目标函数，在输送了所有的观察样本之后，它将搜寻到最大值，即寻找令目标函数最大的参数（arg max）。我们的目标并不是使用尽可能多的样本去完全推断未知的目标函数，而是希望能求得使目标函数最大化的参数，所以我们将注意力从曲线上移开，当目标函数组合能提升曲线形成分布时，其就可以称为采集函数（Acquisition funtion），这就是贝叶斯优化背后的思想。（灰色区域部分参考：https://www.jiqizhixin.com/articles/2017-08-18-5） 时序模型优化一种常用的贝叶斯优化方法为时序模型优化（Sequential Model-Based Optimization，SMBD），假设超参数优化的函数f(x)服从高斯过程，则$p(f(x)|x)$为一个正态分布。贝叶斯优化过程是根据已有的N组实验结果$H={x_n,y_n}, n\\in(1,N)$（$y_n$为$f(x_n)$的观测值）来建模高斯过程，并计算$f(x)$的后验分布$p(f(x)|x,H)$。 为了使得$p(f(x)|x,H)$接近其真实分布，就需要对样本空间进行足够多的采样，但是超参数优化中每一个样本的生成成本都很高，需要使用尽可能少的样本来使得$p_\\theta(f(x)|x,H)$接近于真实分布。因此需要定义一个收益函数（Acquisition funtion）$\\alpha (x, H)$来判断一个样本能否给建模$p_\\theta(f(x)|x,H)$提供更多的收益。收益越大，其修正的高斯过程会越接近目标函数的真实分布。 收益函数的定义有很多方式，一个常用的是期望改善（Expected Improvement，EI）。假设$y^* = min \\left \\{ y_n, 1 \\leq n \\leq N \\right \\}$是当前已有样本中的最优值，期望改善函数为： EI(x, H) = \\int_{-\\infty }^{ +\\infty } max (y^* - y, 0) p(y|x, H) dy期望改善是定义一个样本$x$在当前模型$p(f(x)|x,H)$下，$f(x)$超过最好结果$y^*$的期望。除了期望改善函数之外，收益函数还有其他函数的定义，比如改善概率（Probability Of Improvement），高斯过程置信上界（GP Up Confidence Bound，GP-UCB）等。 时序模型优化过程如下所示： 贝叶斯优化的缺点是高斯建模过程需要计算矩阵的逆，时间复杂度为$O(n^3)$，因此不能很好的处理高维过程，深层神经网络的参数一般比较多，需要更加高效的高斯过程建模，也有一些方法将时间复杂度从$O(n^3)$降到了$O(n)$。 至此，超参数优化部分已经介绍完成，这里并没有对超参数优化进行实现，有很多Python库已经对其进行了封装，感兴趣的可以关注下，另外贝叶斯优化在日常实践中用的比较多但是不太好理解，可以多看几遍，对比一些文章什么看下理解下。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"神经网络中的网络优化和正则化（二）之参数初始化/数据预处理/逐层归一化","slug":"TensorFlow/神经网络中的网络优化和正则化（二）之参数初始化:数据预处理:逐层归一化","date":"2019-09-22T13:32:55.000Z","updated":"2019-10-14T12:28:36.843Z","comments":true,"path":"2019/09/22/TensorFlow/神经网络中的网络优化和正则化（二）之参数初始化:数据预处理:逐层归一化/","link":"","permalink":"http://thinkgamer.cn/2019/09/22/TensorFlow/神经网络中的网络优化和正则化（二）之参数初始化:数据预处理:逐层归一化/","excerpt":"","text":"引言神经网络中的网络优化和正则化问题介绍主要分为一，二，三，四篇进行介绍。 第一篇包括 网络优化和正则化概述 优化算法介绍 第二篇包括 参数初始化 数据预处理 逐层归一化 第三篇包括 超参数优化 第四篇包括 网络正则化 参数初始化对称权重现象在上一篇文章中我们提到神经网络中的参数学习是基于梯度下降的，而梯度下降需要赋予一个初始的参数，所以这个参数的初始化就显得特别重要。 在感知器和逻辑回归中，一般将参数初始化为0，但是在神经网络中如果把参数初始化为0，就会导致在第一次前向计算时，所有隐藏层神经元的激活值都相同，这样会导致深层神经元没有区分性，这种现象称为对称权重现象 因此如果要高质量的训练一个网络，给参数选择一个合适的初始化区间是非常重要的，一般而言，参数初始化的区间应该根据神经元的性质进行差异化的设置，如果一个神经元的输入过多，权重就不要设置太大，以避免神经元的的输出过大（当激活函数为ReLU时）或者过饱和（激活函数为Sigmoid函数时）。关于神经网络中的激活函数介绍可参考： https://blog.csdn.net/Gamer_gyt/article/details/89440152 常见的参数初始化方法包括以下两种。 Gaussian初始化高斯初始化是最简单的初始化方法，参数服从一个固定均值和固定方差的高斯分布进行随机初始化。 初始化一个深度网络时，一个比较好的初始化方案是保持每个神经元输入的方差是一个常量，当一个神经元的输入连接数量为n时，可以考虑其输入连接权重以$N(0,\\sqrt{\\frac{1}{n}})$的高斯分布进行初始化，如果同时考虑神经元的输出连接数量为m时，可以按照$N(0,\\sqrt{\\frac{2}{m+n}})$进行高斯分布初始化。 均匀分布初始化 均匀初始化是指在一个给定的区间[-r,r]内采用均匀分布来初始化参数，超参数r的设置也可以根据神经元的连接数量来进行自适应调整。 Xavier初始化方法是一种自动计算超参数r的方法，参数可以在[-r,r]之间采用均匀分布进行初始化。 如果神经元激活函数为logistic函数，对于第l-1层到第l层的权重参数区间可以设置为： r = \\sqrt{ \\frac{6}{ n^{l-1} + n^l}}$n^l$ 表示第l层神经元的个数，$n^{l-1}$表示l-1层神经元的个数。 如果是tanh激活函数，权重参数区间可以设置为： r =4 \\sqrt{ \\frac{6}{ n^{l-1} + n^l}} 在实际经验中，Xavier初始化方法用的比较多。 数据预处理为什么要进行数据预处理一般情况下，在原始数据中，数据的维度往往不一致，比如在电商数据中，某个商品点击的次数往往要远大于购买的次数，即特征的分布范围差距很大，这样在一些使用余弦相似度计算的算法中，较大的特征值就会起到绝对作用，显然这样做是极其不合理的。同样在深度神经网络中，虽然可以通过参数的调整来自适应不同范围的输入，但是这样训练的效率也是很低的。 假设一个只有一层的网络 $y=tanh(w_1x_1 + w_2 x_2 +b)$，其中$x_1 \\in [0,10], x_2 \\in [0,1]$。因为激活函数 tanh的导数在[-2,2]之间是敏感的，其余的值域导数接近0，因此$w_1x_1 + w_2 x_2 +b$过大或者过小都会影响训练，为了提高训练效率，我们需要把$w_1x_1 + w_2 x_2 +b$限定在[-2,2]之间，因为$x_1,x_2$的取值范围，需要把$w_1$设置的小一些，比如在[-0.1, 0.1]之间，可以想象，如果数据维度比较多的话，我们需要精心的去设置每一个参数，但是如果把特征限定在一个范围内，比如[0,1]，我们就不需要太区别对待每一个参数。 除了参数初始化之外，不同特征取值范围差异比较大时也会影响梯度下降法的搜索效率，下图（图1-1）给出了数据归一化对梯度的影响，对比等高线图可以看出，归一化后，梯度的位置方向更加接近于最优梯度的方向。 数据预处理的方法关于原始数据归一化的方法有很多，可以参考《推荐系统开发实战》中第四章节部分内容，写的很全面，而且有对应的代码实现。该书的购买链接： 点击查看详情-京东链接 逐层归一化深层神经网络中为什么要做逐层归一化在深层神经网络中，当前层的输入是上一层的输出，因此之前层参数的变化对后续层的影响比较大，就像一栋高楼，低层很小的变化就会影响到高层。 从机器学习的角度去看，如果某个神经网络层的输入参数发生了变化，那么其参数需要重新学习，这种现象叫做内部协变量偏移（Internal Covariate Shift）。 这里补充下机器学习中的协变量偏移（Covariate Shift）。协变量是一个统计学的概念，是影响预测结果的统计变量。在机器学习中，协变量可以看作是输入，一般的机器学习都要求输入在训练集和测试集上的分布是相似的，如果不满足这个假设，在训练集上得到的模型在测试集上表现就会比较差。 为了解决内部协变量偏移问题，需要对神经网络层的每一层输入做归一化，下面介绍几种常见的方法： 批量归一化 层归一化 其他方法 批量归一化为了减少内部协变量偏移的影响，需要对神经网络每一层的净输入$z^l$进行归一化，相当于每一层都要做一次数据预处理，从而加快收敛速度，但是因为对每一层都进行操作，所以要求归一化的效率要很高，一般使用标准归一化，将净输入$z^l$的每一维都归一到标准正态分布，其公式如下： \\hat{z}^l = \\frac{ z^l - E[z^l] }{ \\sqrt{var(z^l) + \\epsilon } }$E[z^l]，var(z^l)$表示在当前参数下$z^l$的每一维在整个训练集上的期望和方差，因为深度神经网络采用的是下批量的梯度下降优化方法，基于全部样本计算期望和方差是不可能的，因为通常采用小批量进行估计。给定一个包含K个样本的集合，第$l$层神经元的净输入$z^{(1,l)},….z^{(K,l)}$的均值和方差为： \\mu _\\beta = \\frac{1 }{ K } \\sum_{k=1}^{K } z^{(k,l)} \\\\ \\sigma^2 _\\beta = \\frac{1 }{ K }\\sum_{ k=1}^{K} (z^{(k,l)} - \\mu _\\beta)^2对净输入$z^l$的标准归一化会使其取值集中在0附近，这样当使用sigmoid激活函数时，这个取值空间刚好接近线性变换的空间，减弱了神经网络的非线性性质。因此为了不使归一化对网络产生影响，需要对其进行缩放和平移处理，公式如下： \\hat{z}^l = \\frac{ z^l - \\mu _\\beta }{ \\sqrt{\\sigma^2 _\\beta+ \\epsilon } } \\odot \\gamma + \\beta其中$\\gamma , \\beta$分别代表缩放和平移的向量。 这里需要注意的是每次小批量样本的均值和方差是净输入$z^l$的函数，而不是常量因此在计算梯度时要考虑到均值和方差产生的影响，当训练完成时，用整个数据集上的均值和方差来代替每次小样本计算得到的均值和方差。在实际实践经验中，小批量样本的均值和方差也可以使用移动平均来计算。 层归一化批量归一化的操作对象是单一神经元，因此要求选择样本批量的时候，不能太小，否则难以计算单个神经元的统计信息，另外一个神经元的输入是动态变化的，比如循环神经网络，那么就无法应用批量归一化操作。 层归一化（Layer Normalization） 是和批量归一化非常类似的方法，但层归一化的操作对象是某层全部神经元。 对于深层神经网络，第$l$层神经元的净输入为$z^l$，其均值和方差为： u^l = \\frac{1}{n^l} \\sum_{i=1}^{ n^l} z_i^l \\\\ \\sigma ^2_l = \\frac{1}{n^l} \\sum_{i=1}^{ n^l} (z_i^l - u^l )其中$n^l$为第$l$层神经元的数量。则层归一化定义为： \\hat{z^l} = \\frac{z^l - u^l }{ \\sqrt {\\sigma^2 _l + \\epsilon } } \\odot \\gamma + \\beta其中$\\gamma ,\\beta$分别代表缩放和平移的向量，和$z^l$的维度相同。 循环神经网络中的层归一化为： z_t = U h_{t-1} + W x_t \\\\ h_t = f(\\hat{z^l})其中隐藏层为$h_t$，$x_t$为第$t$时刻的净输入，$U,W$为参数。 在标准循环网络中，循环神经层的输入一般就随着时间慢慢变大或者变小，从而引起梯度爆炸或者梯度消失，而层归一化的神经网络可以有效的缓解这种状况。 其他方法除了上面介绍的两种归一化方法之外，还有一些其他的一些归一化方法，感兴趣的可以自行搜索查看。 权重归一化(Weight Normalization) 局部响应归一化 至此，神经网络中的优化方法第二部分介绍完成，主要包好了三部分内容：参数初始化，数据预处理和逐层归一化。再下一篇将会重点介绍超参数优化的方法不仅适用于深度神经网络，也适用于一般的机器学习任务。如果你觉得不错，分享一下吧！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"神经网络中的网络优化和正则化（一）之学习率衰减和动态梯度方向","slug":"TensorFlow/神经网络中的网络优化和正则化（一）之学习率衰减和动态梯度方向","date":"2019-09-22T13:25:01.000Z","updated":"2019-10-14T12:28:36.841Z","comments":true,"path":"2019/09/22/TensorFlow/神经网络中的网络优化和正则化（一）之学习率衰减和动态梯度方向/","link":"","permalink":"http://thinkgamer.cn/2019/09/22/TensorFlow/神经网络中的网络优化和正则化（一）之学习率衰减和动态梯度方向/","excerpt":"","text":"引言神经网络中的网络优化和正则化问题介绍主要分为一，二，三，四篇进行介绍。 第一篇包括 网络优化和正则化概述 优化算法介绍 第二篇包括 参数初始化 数据预处理 逐层归一化 第三篇包括 超参数优化 第四篇包括 网络正则化 概述虽然神经网络有比较强的表达能力，但是应用神经网络到机器学习任务时仍存在一些问题，主要分为： 网络优化 神经网络模型是一个非凸函数，再加上神经网络中的梯度消失和梯度爆炸，很难进行优化，另外网络的参数比较多，且数据量比较大导致训练效率比较低。 正则化 神经网络拟合能力强，容易在训练集上产生过拟合，需要一些正则化的方法来提高网络的泛化能力。 从大量的实践经验看主要是从网络优化和正则化两个方面提高学习效率并得到一个好的网络模型。 在低维空间的非凸优化问题中主要是存在一些局部最优点，基于梯度下降优化算法会陷入局部最优点，因此低维空间的非凸优化的难点在于如何选择合适的参数和逃离局部最优点。 深层神经网络中参数较多，其是在高维空间的非凸优化问题中，和低维空间的非凸优化有些不同，其主要难点在于如何逃离鞍点（Saddle Point），鞍点的梯度为0，但是在一些维度上是最高点，在另一些维度上是最低点，如下图所示（图1-1）： 在高维空间中，局部最优点要求在每一维度上都是最低点，这种概率很低，假设网络有1000个参数，每一维上取得局部最优点的最小概率为p，则在整个参数空间中取得局部最优点的最小概率为$p^{1000}$，这种概率很小，也就是说在整个参数空间中，大部分梯度为0的点都是鞍点。 优化算法介绍深层神经网络的参数学习主要是通过梯度下降算法寻找一组最小结构的风险参数，梯度下降分为： 批量梯度下降 随机梯度下降 小批量梯度下降 根据不同的数据量和参数量，可以选择一种合适的梯度下降优化算法，除了在收敛效果和效率上的区别，这三种梯度下降优化算法还存在一些共同问题（具体会在下一篇进行详细介绍）： 如何初始化参数 预处理数据 如何选择合适的学习率，避免陷入局部最优 在训练深层神经网络时，通常采用小批量梯度下降算法。令$f(x,\\theta)$为一个深层神经网络，$\\theta$为网络参数，使用小批量梯度优化算法时，每次选择K个训练样本$I_t =\\left \\{ (x^t,y^t) \\right \\} , t \\in (1,T)$，第t次迭代时损失函数关于$\\theta$的偏导数为（公式1-1）： g_t(\\theta ) = \\frac{ 1 }{ K } \\sum_{ (x^t,y^t) \\in I_t} \\frac{ \\partial L(y^t,f(x^t, \\theta)) }{ \\partial \\theta }第t次更新的梯度$g’_t$定义为（公式1-2）： g_t'(\\theta)= g_t(\\theta_{t-1})使用梯度下降来更新参数（公式1-3）： \\theta_t = \\theta_{t-1} - \\alpha g'(\\theta)一般批量较小时，需要选择较小的学习率，否则模型不会收敛。下图（图1-2）给出了在Mnist数据集上批量大小对梯度的影响。从图1-2(a)可以看出，批量大小设置的越大，下降的越明显，并且下降的比较平滑，当选择批量的大小为1时，整体损失呈下降趋势，但是局部比较震荡。从图1-2(b)可以看出，如果按整个数据集上的迭代次数（Epoch）来看损失变化情况，则是批量样本数越小，下降效果越明显。 为了更加有效的训练深层神经网络，在标准的小批量梯度下降算法中，经常使用一些改进方法加快优化速度，常见的改进方法有两种： 学习率衰减 梯度方向优化 这些改进的优化方法也同样可以应用在批量梯度下降算法和随机梯度下降算法。 学习率衰减在梯度下降中，学习率的设置很重要，设置过大，则不会收敛，设置过小，则收敛太慢。从经验上看，学习率在一开始要设置的大些来保证收敛速度，在收敛到局部最优点附近时要小些来避免震荡，因此比较简单的学习率调整可以通过学习率衰减（Learning Rate Decay）的方式来实现。假设初始学习率为$\\alpha_0$，第t次迭代的学习率为$a_t$，常用的衰减方式为按照迭代次数进行衰减，例如 逆时衰减（公式1-4） a_t = a_0 \\frac{1 }{ 1 + \\beta t} 指数衰减（公式1-5） a_t = a_0\\beta^t 自然指数衰减（公式1-6） a_t = a_0 exp(-\\beta * t)其中$\\beta$为衰减率，一般为0.96 AdaGradAdaGrad（Adaptive Gradient）算法是借鉴L2正则化的思想，每次迭代时自适应的调整每个参数的学习率。AdaGrad的参数更新公式为（公式1-7）： G_t = \\sum_{t=1}^{T} g_t \\odot g_t \\\\ \\bigtriangleup \\theta_t = - \\frac{\\alpha }{ \\sqrt{G_t + \\epsilon } } \\odot g_t \\\\ g'_t(\\theta) = g_t(\\theta_{t-1}) + \\bigtriangleup \\theta_t其中$\\alpha$为学习率，$\\epsilon$是为了保证数据稳定性而设置的非常小的常数，一般取值是 $e^{-7}$到$e^{-10}$，这里的开平方，加，除运算都是按照元素进行的操作。 在AdaGrad算法中，如果某个参数的偏导数累积比较大，其学习率相对较小，相反，如果其偏导数累积比较大，其学习率相对较大。但是整体上随着迭代次数的增加，学习率逐渐减小。 AdaGrad算法的缺点是在经过一定次数的迭代后依然没有找到最优点，由于这时候的学习率已经很小了，就很难找到最优点。 RMSPropRMSProp是Geoff Hinton提出的一种自适应学习率的方法，可以在有些情况下避免AdaGrad的学习率单调递减以至于过早衰减的缺点。 RMSProp算法首先计算的是每次迭代速度$g_t$平方的指数衰减移动平均，如下所示（公式1-8）： G_t = \\beta G_{t-1} + (1-\\beta) g_t \\odot g_t = (1- \\beta) \\sum_{t=1}^{T} \\beta ^{T-t} g_t \\odot g_t其中$\\beta$为衰减率，一般取值为0.9，RMSProp算法参数更新公式为（公式1-9）： \\bigtriangleup \\theta_t = - \\frac{\\alpha }{ \\sqrt{G_t + \\epsilon } } \\odot g_t \\\\ g'_t(\\theta) = g_t(\\theta_{t-1}) + \\bigtriangleup \\theta_t其中$\\alpha$为学习率，通常为0.001。 从公式1-8 可以看出，RMSProp和AdaGrad的区别在于$G_t$的计算由累积方式变成了指数衰减移动平均，在迭代过程中，每个参数的学习率并不是呈衰减趋势，即可以变大，也可以变小。 AdaDeltaAdaDelta算法也是AdaGrad算法的一个改进，和RMSProp算法类似，AdaDelta算法通过梯度平方的指数衰减移动平均来调整学习率，除此之外，AdaDelta算法还引入了每次参数更新差$\\bigtriangleup \\theta$的平方的指数衰减移动平均。 第t次迭代时，每次参数更新差$\\bigtriangleup \\theta_t , 1&lt;t&lt;T-1$的指数衰减移动平均为（公式1-10）： \\bigtriangleup X^2_{t-1} =\\beta _1 \\bigtriangleup X^2_{t-2} + (1 - \\beta) \\bigtriangleup \\theta_{t-1} \\odot \\bigtriangleup \\theta_{t-1}其中$\\beta_1$为衰减率，AdaDelta算法的参数更新差值为（公式1-11）： \\bigtriangleup \\theta_t = - \\frac{\\sqrt {\\bigtriangleup X^2_{t-1} + \\epsilon }}{ \\sqrt {G_t + \\epsilon}} g_t 其中$G_t$的计算方式和RMSProp算法一样。从公式1-11可以看出，AdaDelta算法将RMSProp算法中的初始学习率$\\alpha$改为动态计算的$\\sqrt {\\bigtriangleup X^2_{t-1} + \\epsilon }$，在一定程度上减缓了学习旅率的波动。 梯度方向优化除了调整学习率外，还可以使用最近一段时间内的平均梯度来代替当前时刻的梯度来作为参数的更新方向，从图1-2中可以看出，在小批量梯度下降中，如果每次选取样本数量比较小，损失就会呈现震荡的方式下降，有效的缓解梯度下降中的震荡的方式是通过用梯度的移动平均来代替每次的实际梯度。并提高优化速度，这就是动量法。 动量法动量法（Momentum Method）是用之前积累的动量来替代真正的梯度，每次替代的梯度可以看作是加速度。 在第t次迭代时，计算负梯度的“加权移动平均”作为参数的更新方向，如下所示（公式1-12）： \\bigtriangleup \\theta_t = \\rho \\bigtriangleup \\theta_{t-1}-\\alpha g_t其中$\\rho$为动量因子，通常设置为0.9，$\\alpha$为学习率。 参数的实际更新值取决于最近一段时间内梯度的加权平均值。当某个参数在最近一段时间内梯度方向不一致时，参数更新的幅度变小，相反，参数更新的幅度变大，起到加速的作用。 一般而言，在迭代初期，梯度的更新方向比较一致，动量法会起到加速作用，可以更快的起到加速的作用，可以更快的到达最优点，在迭代后期，梯度的更新方向不一致，在收敛时比较动荡，动量法会起到减速作用，增加稳定性。从某种程度来讲，当前梯度叠加上部分的上次梯度，一定程度上可以看作二次梯度。 Nesterov加速梯度Nesterov加速梯度（Nesterov Accelerated Gradient， NAG）也叫Nesterov动量法（Nesterov Momentum），是一种对动量法的改进。 在动量法中，实际的参数更新方向$\\bigtriangleup \\theta_t$为上一步的参数更新方向$\\bigtriangleup \\theta_{t-1}$和当前的梯度 $-g_t$的叠加，这样，$\\bigtriangleup \\theta_t$可以拆分为两步进行，先根据$\\bigtriangleup \\theta_{t-1}$更新一次得到参数$\\tilde{\\theta }$，再用$g_t$进行更新，如下所示（公式1-13）： \\tilde{\\theta } = \\theta_{t-1} + \\rho \\bigtriangleup \\theta_{t-1} \\\\ \\theta_t = \\tilde{\\theta } - \\alpha g_t其中$g_t$为点$\\theta_{t-1}$上的梯度，所以第二步不太合理，更合理的更新方向为$\\tilde{\\theta }$上的梯度，这样合并后的更新方向为（公式1-14）： \\bigtriangleup \\theta_t = \\rho \\bigtriangleup \\theta_{t-1} -\\alpha g_t(\\theta_{t-1} + \\rho \\bigtriangleup \\theta_{t-1} )其中$g_t(\\theta_{t-1} + \\rho \\bigtriangleup \\theta_{t-1} )$表示损失函数在$\\tilde{\\theta } = \\theta_{t-1} + \\rho \\bigtriangleup \\theta_{t-1}$上的偏导数。 下图（图1-3）给出了动量法和 Nesterov 加速梯度在参数更新时的比较： AdaM算法自适应动量估计算法（Adaptive Moment Estimation，Adam）可以看作是动量法和RMSprop的结合，不但使用动量作为参数更新，而且可以自适应调整学习率（公式1-15）。 M_t = \\beta _1M_{t-1} + (1-\\beta _1)g_t \\\\ G_t = \\beta _2 G_{t-1} + (1-\\beta _2)g_t \\odot g_t其中$\\beta_1 ，\\beta_2$分别为两个移动平均的衰减率，通常取值：$\\beta_1=0.9,\\beta_2=0.99$。 $M_t$可以看作是梯度的均值（一阶矩），$G_t$可以看作是梯度的未减去均值的方差（二阶矩）。 假设$M_t =0,G_t=0$，那么在迭代初期，$M_t，G_t$的值会比真实的均值和方差要小，特别是当$\\beta_1 ，\\beta_2$都接近1时，偏差会很大，因此需要对偏差进行修正，如下所示（公式1-16）： \\tilde{M_t} = \\frac{M_t}{ 1 - \\beta^t _1} \\\\ \\tilde{G_t} = \\frac{G_t}{ 1 - \\beta^t _2}Adam算法的更新差值为（公式1-17）： \\bigtriangleup \\theta_t = - \\frac{\\alpha }{\\sqrt{ \\tilde{G_t} + \\varepsilon }} \\tilde{M_t}其中学习率$\\alpha$通常设置为0.001，并且也可以进行衰减，比如$a_t = \\frac{a_0} { \\sqrt{t}}$。 Adam算法是RMSprop与动量法的结合，因此一种自然的Adam改进方法是引入Nesterov加速梯度，称为Nadam算法。 梯度截断在深层神经网络或者循环网络中，除了梯度消失之外，梯度爆炸是影响学习效率的主要隐私，在基于梯度下降的优化过程中，如果梯度突然增大，用较大的梯度更新参数，反而会使结果远离最优点，为了避免这种情况，当梯度达到一定值的时候，要进行梯度截断（gradient clipping）。 梯度截断是一种比较简单的启发式方法，把梯度的模限定在一个范围内，当梯度的模大于或者小于某个区间时，就进行截断，一般截断的方式有以下几种： 按值截断 在第t次迭代时，梯度为$g_t$，给的一个区间[a,b]，如果梯度小于a时，令其为a，大于b时，令其为b。 按模截断将梯度的模截断到一个给定的截断阈值b。如果$||g_t||^2 \\leq b$保持梯度不变，如果$||g_t||^2 &gt; b$，则$g_t= \\frac{ b}{||g_t||} g_t$。 截断阈值 b 是一个超参数,也可以根据一段时间内的平均梯度来自动调整。实验中发现,训练过程对阈值 b 并不十分敏感,通常一个小的阈值就可以得到很好的结果。 在训练循环神经网络时，按模截断是避免梯度爆炸的有效方法。 优化算法总结本文介绍了神经网络中的网络优化和正则化概述，以及网络优化中的加快网络优化的两种方法，这些方法大体分为两类： 调整学习率，使得优化更稳定 比如：AdaGrad，RMSprop，AdaDelta 调整梯度方向，优化训练速度 比如：动量法，Nesterov加速梯度，梯度截断 Adam则是RMSprop 和 动量法的结合。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"常见的五种神经网络(3)-循环神经网络（下）篇","slug":"TensorFlow/常见的五种神经网络(3)-循环神经网络（下）篇","date":"2019-09-18T00:14:54.000Z","updated":"2019-10-14T12:28:36.839Z","comments":true,"path":"2019/09/18/TensorFlow/常见的五种神经网络(3)-循环神经网络（下）篇/","link":"","permalink":"http://thinkgamer.cn/2019/09/18/TensorFlow/常见的五种神经网络(3)-循环神经网络（下）篇/","excerpt":"","text":"转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/100943664博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki 引言常见的五种神经网络系列第三篇，主要介绍循环神经网络，由于循环神经网络包含的内容过多，分为上中下三篇进行介绍，本文主要是循环神经网络（下）篇，主要介绍以下内容： 长短期记忆网络（LSTM） 门控循环单元网络（GRU） 递归循环神经网络（RecNN） 图网络（GN） 该系列的其他文章： 常见的五种神经网络(1)-前馈神经网络 常见的五种神经网络(2)-卷积神经网络 常见的五种神经网络(3)-循环神经网络(上篇) 常见的五种神经网络(3)-循环神经网络(中篇) 常见的五种神经网络(3)-循环神经网络(下篇) 常见的五种神经网络(4)-深度信念网络 常见的五种神经网络(5)-生成对抗网络 LSTM长短期记忆（Long Short-Term Memory，LSTM）网络是循环神经网络的一个变体，可以有效的解决简单循环神经网络的梯度爆炸和梯度消失问题。 LSTM的改进包含两点： 新的内部状态 门机制 新的内部状态LSTM网络引入一个新的内部状态（internal state）$c_t$专门进行线性的循环传递，同时（非线性）输出信息给隐藏层的外部状态$h_t$（公式3-1）。 c_t = f_t \\odot c_{t-1} + i_t \\odot \\tilde{c_t} \\\\ h_t = o_t \\odot tanh(c_t)其中 $f_t$，$i_t$，$o_t$为三个门来控制信息传递的路径，$\\odot$为向量元素乘积，$c_{t-1}$为上一时刻的记忆单元，$\\tilde{c_t}$是通过非线性函数得到的候选状态（公式3-2）: \\tilde{c_t} = tanh( W_c x_t + U_c h_{t-1} + b_c )在每个时刻t，LSTM网络的内部状态$c_t$记录了到当前时刻为止的历史信息。 门机制LSTM网络引入门机制来控制信息的传递， $f_t，i_t，o_t$分别为遗忘门，输入门，输出门。电路中门是0或1，表示关闭和开启，LSTM网络中的门是一种软门，取值在(0,1)，表示以一定比例的信息通过，其三个门的作用分别为： $f_t$：控制上一个时刻的内部状态 $c_{t-1}$需要遗忘多少信息 $i_t$：控制当前时刻的候选状态$\\tilde{c_t}$有多少信息需要保存 $o_t$：控制当前时刻的状态$c_t$有多少信息需要输出为$h_t$ 三个门的计算如下（公式3-3）： i_t=\\sigma (W_i x_t+U_i h_{t-1} + b_i) \\\\ f_t=\\sigma (W_f x_t+U_f h_{t-1}+ b_f ) \\\\ o_t=\\sigma (W_o x_t+U_o h_{t-1}+b_o)其中$\\sigma$为logsitic函数，其输出区间为(0,1)，$x_t$为当前输入，$h_{t-1}$为上一时刻的外部状态。 下图（图3-1）给出了LSTM的循环单元结构，其计算分为三个过程： 利用当前时刻的输入$x_t$和上一时刻的外部状态$h_{t-1}$计算出三个门和候选状态$\\tilde{c_t}$ 结合遗忘门$f_t$和输入门$i_t$来更新记忆单元$c_t$ 结合输出门$o_t$将内部状态信息传递给外部状态$h_t$ 通过LSTM循环单元，整个网络可以建立长距离的时序依赖关系，公式3-1～3-3可以简单的描述为（公式3-4）： \\begin{bmatrix} \\tilde{c_t}\\\\ o_t\\\\ i_t\\\\ f_t \\end{bmatrix} = \\begin{bmatrix} tanh\\\\ \\sigma \\\\ \\sigma \\\\ \\sigma \\end{bmatrix} (W\\begin{bmatrix} x_t\\\\ h_{t-1} \\end{bmatrix} + b) \\\\ c_t = f_t \\odot c_{t-1}+ i_t \\odot \\tilde{c_t} \\\\ h_t = o_t \\odot tanh(c_t)其中$x_t$为当前时刻的输入，$W$和$b$为网络参数。 循环神经网络中的隐状态h存储了历史信息，可以看作是一种记忆（Memeory）。在简单循环网络中，隐状态每个时刻都会被重写，因此可以看作一种短期记忆（Short-term Memeory）。在神经网络中，长期记忆（Long-term Memory）可以看作是网格参数，隐含了从训练数据中学到的经验，其更新周期要远远慢于短期记忆。而在LSTM网络中，记忆单元c可以在某个时刻捕捉到某个关键信息，并有能力将该信息保存一段时间，记忆单元c中保存的信息要远远长于隐状态h，但又远远短于长期记忆，因此被成为长短期记忆网络（Long Short-term Memory）。 GRU门控单元（Gate Recurrent Unit，GRU）网络是一种比LSTM更加简单的循环神经网络。在LSTM中遗忘门和输入门是互补关系，比较冗余，GRU将遗忘门和输入门合并成一个门：更新门。同时GRU也不引入额外的记忆单元，直接在当前的状态$h_t$和上一个时刻的状态$h_{t-1}$之间引入线性依赖关系。 在GRU网络中，当前时刻的候选状态$\\tilde{h_t}$为（公式3-5）： \\tilde{h_t} = tanh( W_h x_h + U_h(r_t\\odot h_{t-1}) + b_h ) 计算$\\tilde{h_t}$时，选用tanh激活函数是因为其导数有比较大的值域，缓解梯度消失问题。 其中$r_t \\in [0,1]$ 为重置门（reset gate），用来控制候选状态$\\tilde {h_t}$的计算是否依赖上一时刻的状态$h_{t-1}$，公式如下（公式3-6）： r_t = \\sigma ( W_r x_t + U_r h_{t-1} + b_r)当 $r_t$为0 时，候选状态$\\tilde{h_t}$只和当前输入$x_t$有关，和历史状态无关，当$r_t$为1时，候选状态$\\tilde{h_t}$和当前输入$x_t$，历史状态$h_{t-1}$都有关，和简单循环网络一致。 GRU网络隐状态$h_t$的更新方式为（公式3-7）： h_t = z_t \\odot h_{t-1}+ (1-z_t) \\odot \\tilde {h_t}其中$z \\in [0,1]$为更新门（update gate），用来控制当前状态需要从历史状态中保留多少信息（不经过非线性变换），以及需要从候选状态中获取多少信息。$z_t$公式如下（公式3-8）： z_t = \\sigma (W_z x_t + U_z h_{t-1} + b_z) 若$z_t=0$，当前状态$h_t$和历史状态$h_{t-1}$之间为非线性函数。 若$z_t=0，r=1$，GRU退化为简单循环网络 若$z_t=0，r=0$，当前状态$h_t$只和当前输入$x_t$有关，和历史状态$h_{t-1}$无关 若$z_t=1$，当前时刻状态$h_t=h_{t-1}$，和当前输入$x_t$无关 GRU网络循环单元结构如下（图3-2）： RecNN 如果将循环神经网络按时间展开，每个时刻的隐状态$h_t$看做是一个节点，那么这些节点构成一个链式结构，而链式结构是一种特殊的图结构，很容易将这种消息传递的思想扩展到任意的图结构上。 递归神经网络（Recursive Neurnal Network，RecNN）是循环神经网络在有向无循环图上的控制，递归神经网络一般结构为树状的层次结构，如下图所示（图3-3）： 以上图(a)为例，包含3个隐藏层$h_1,h_2,h_3$，其中$h_1$由两个输入$x_1,x_2$计算得到，$h_2$由两个输入$x_3,x_4$计算得到，$h_3$由两个隐藏层$h_1,h_2$计算得到。 对于一个节点$h_i$，它可以接受来自子节点集合$\\pi_i$中所有节点的消息，并更新自己的状态，如下所示（公式3-9）： h_i = f(h_{\\pi_i})其中$h_{\\pi_i}$表示$\\pi_i$集合中所有节点状态的拼接，$f(.)$是一个和节点状态无关的非线性函数，可以为一个单层的前馈神经网络，比如图3-3(a)所表示的递归神经网络可以表示为（公式3-10）： h_1 = \\sigma (W \\begin{bmatrix} x_1\\\\ x_2 \\end{bmatrix}+ b) \\\\ h_2 = \\sigma (W \\begin{bmatrix} x_3\\\\ x_4 \\end{bmatrix}+ b) \\\\ h_3 = \\sigma (W \\begin{bmatrix} h_1\\\\ h_2 \\end{bmatrix}+ b)其中$\\sigma$表示非线性激活函数，W和b为可学习的参数，同样输出层y可以为一个分类器，比如（公式3-11）： h_3 = g (W' \\begin{bmatrix} h_1\\\\ h_2 \\end{bmatrix}+ b')其中$g(.)$为分类器，$W’$和$b’$为分类器的参数。当递归神经网络的结构退化为图3-3(b)时，就等价于简单神经循环网络。 递归神经网络主要用来建模自然语言句子的语义，给定一个句子的语法结构，可以使用递归神经网络来按照句法的组合关系来合成一个句子的语义，句子中每个短语成分可以分成一些子成分，即每个短语的语义可以由它的子成分语义组合而来，进而合成整句的语义。 同样也可以使用门机制来改进递归神经网络中的长距离依赖问题，比如树结构的长短期记忆模型就是将LSTM的思想应用到树结构的网络中，来实现更灵活的组合函数。 GN在实际应用中，很多数据是图结构的，比如知识图谱，社交网络，分子网络等。而前馈网络和反馈网络很难处理图结构的数据。 图网络（Graph Network，GN）是将消息传递的思想扩展到图结构数据上的神经网络。 对于一个图结构$G(V,\\varepsilon )$，其中$V$表示节点结合，$\\varepsilon$表示边集合。每条边表示两个节点之间的依赖关系，节点之间的连接可以是有向的，也可以是无向的。图中每个节点v都用一组神经元来表示其状态$h^{(v)}$ ，初始状态可以为节点v的输入特征$x^{(v)}$，每个节点接受相邻节点的信息，来更新自己的状态，如下所示（公式3-12）： m^{(v)}_t = \\sum_{u \\in N(v)} f( h^{(v)}_{t-1},h^{(u)}_{t-1},e^{(u,v)} ) \\\\ h^{(v)}_t = g(h^{(v)}_{t-1},m^{(u)}_t)其中$N(v)$表示节点v的邻居节点，$m^{(v)}_t$ 表示在t时刻节点v接受到的信息，$e^{(u,v)}$为边(v,u)上的特征。 公式3-12是一种同步更新方式，所有结构同时接受信息并更新自己的状态，而对于有向图来说，使用异步的更新方式会更有效率，比如循环神经网络或者递归神经网络，在整个图更新T次后，可以通过一个读出函数g(.)来得到整个网络的表示。 至此，循环神经网络（上）（中）（下）篇已经介绍完毕。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"常见的五种神经网络(3)-循环神经网络（中）篇","slug":"TensorFlow/常见的五种神经网络(3)-循环神经网络（中）篇","date":"2019-09-10T17:16:12.000Z","updated":"2019-10-14T12:28:36.840Z","comments":true,"path":"2019/09/11/TensorFlow/常见的五种神经网络(3)-循环神经网络（中）篇/","link":"","permalink":"http://thinkgamer.cn/2019/09/11/TensorFlow/常见的五种神经网络(3)-循环神经网络（中）篇/","excerpt":"","text":"转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/100709422博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki 引言常见的五种神经网络系列第三种，主要介绍循环神经网络，分为上中下三篇进行介绍，本文主为（中）篇，涉及内容如下： 循环神经网络中的参数学习 RNN中的长期依赖问题 常见的循环神经网络结构 该系列的其他文章： 常见的五种神经网络(1)-前馈神经网络 常见的五种神经网络(2)-卷积神经网络 常见的五种神经网络(3)-循环神经网络(上篇) 常见的五种神经网络(3)-循环神经网络(中篇) 常见的五种神经网络(3)-循环神经网络(下篇) 常见的五种神经网络(4)-深度信念网络 常见的五种神经网络(5)-生成对抗网络 参数学习循环神经网络的参数可以通过梯度下降方法来学习。给定一个样本(x,y)，其中$x_{1:T}=(x_1, x_2, … ,x_T)$为长度是T的输入序列，其中$y_{1:T}=(y_1, y_2, … ,y_T)$是长度为T的标签序列，在每个时刻t，都有一个监督信息$y_t$，定义时刻t的损失函数为（公式1-1）： L_t = L(y_t, g(h_t))其中$g(h_t)$为第t时刻的输出，L为可微分的损失函数，比如交叉熵，整个序列上的损失函数为（公式1-2）： L = \\sum_{t=1}^{T} L_t整个序列的损失函数L关于参数U的梯度为（公式1-3）： \\frac{\\partial L}{\\partial U} = \\sum _{t=1}^{T}\\frac{\\partial L_t}{ \\partial U }即每个时刻的损失函数$L_t$对参数U的偏导数之和。 在循环神经网络中主要有两种计算梯度的方式： 随时间反向传播算法（Backpropagation Through Time，BRTT） 实时循环学习（Real-Time Recurrent Learning，RTRL） 随时间反向传播算法主要通过类似前馈神经网络的错误反向传播算法来进行计算梯度。随时间反向传播算法将循环神经网络看作是一个展开的多层前馈网络，其中“每一层”对应循环网络中的每个时刻，这样循环神经网络就可以按照前馈神经网络中的反向传播算法来计算梯度。与前馈神经网络不同的是，循环神经网络中各层的参数是共享的，因此参数的真实梯度是各个层的参数梯度之和。 先计算公式1-3中第t时刻损失对参数U的偏导数 $\\frac {\\partial L_t}{\\partial U}$，参数U和每个时刻k的净输入$z_k = Uh_{k-1} + Wx_{k} + b$有关，因此第t个时刻损失函数$L_t$关于参数$U_ij$的梯度为（公式1-4）： \\frac{\\partial L_t}{ \\partial U_{ij}} = \\sum_{k=1}^{t} tr( ( \\frac{\\partial L_t}{ \\partial z_k} )^T \\frac{\\partial^+ z_k}{ \\partial U_{ij}} ) \\\\ = \\sum_{k=1}^{t} ( \\frac{\\partial^+ z_k}{ \\partial U_{ij}} )^T \\frac{\\partial L_t}{ \\partial z_k}其中$\\frac{\\partial^+ z_k}{ \\partial U_{ij}}$ 表示“直接”偏导数，即公式$z_k = Uh_{k-1} + Wx_{k} + b$中保持$h_{k-1}$不变，对$U_{ij}$进行求偏导数，得到（公式1-5）： \\frac{\\partial^+ z_k}{ \\partial U_{ij}} = \\begin{bmatrix} 0\\\\ ... \\\\ [h_{k-1}]_j \\\\ ... \\\\ 0 \\end{bmatrix} \\triangleq I_i([h_{k-1}]_j)其中$[h_{k-1}]_j$为第$k-1$时刻隐状态的第j维，$I_i(x)$除了第j行值为x，之外全为0的向量。 定义$\\delta _{t,k} = \\frac{\\partial L_t}{ \\partial z_k }$为第t时刻损失函数对第k时刻隐藏层神经元净输入$z_k$的导数，则（公式1-6）： \\delta _{t,k} = \\frac{\\partial L_t}{ \\partial z_k } \\\\ = \\frac{ \\partial h_k }{ \\partial z_k} \\frac{\\partial z_{k+1}}{ \\partial h_k } \\frac{ \\partial L_t }{ \\partial z_{k+1} } \\\\ = diag(f'(z_k))U^T \\delta _{t,k+1}将（公式1-6） 和 （公式 1-5） 代入（公式1-4）得到（公式1-7）： \\frac{\\partial L_t}{ \\partial U_{ij} } = \\sum_{k=1}^{ t } [\\delta _{t,k}]_i [h_{k-1}]_j将（公式1-7）写成矩阵形式为（公式1-8）： \\frac{\\partial L}{ \\partial U } = \\sum_{k=1}^{ t } \\delta _{t,k} h^T_{k-1}下图为随时间反向传播算法示例： 将（公式1-8）代入（公式1-3）得到整个序列的损失函数$L$关于参数$U$的梯度（公式1-9）: \\frac{\\partial L}{ \\partial U } = \\sum_{t=1}^{ T}\\sum_{k=1}^{ t } \\delta _{t,k} h^T_{k-1}同理可得到$L$关于参数$W$的梯度（公式1-10）： \\frac{\\partial L}{ \\partial W } = \\sum_{t=1}^{ T}\\sum_{k=1}^{ t } \\delta _{t,k} x^T_k$L$关于参数$b$的梯度（公式1-11）： \\frac{\\partial L}{ \\partial b } = \\sum_{t=1}^{ T}\\sum_{k=1}^{ t } \\delta _{t,k} 在 随时间反向传播算法中，参数的梯度需要在一个完整的“向前”计算和“向后”计算后才能得到并参数更新。 实时循环学习与随时间反向传播算法不同的是：实时循环学习（Real-Time Recurrent Learning）是通过前向传播的方式来计算梯度。 假设RNN中第 $t+1$时刻的状态$h_{t+1}$为（公式1-12）： h_{t+1} = f(z_{t+1}) = f(Uh_k + Wx_{k+1} + b)其关于参数$U_{ij$的偏导数为（公式1-13）： \\frac{ h_{t+1} }{ \\partial U_{ij} } = \\frac{ \\partial h_{t+1} }{ \\partial z_{t+1} } ( \\frac{ \\partial^+z_{t+1} }{ \\partial U_{ij}} + U \\frac{ \\partial h_t}{ \\partial U_{ij} } ) \\\\ = diag( f'(z_{t+1}) ) ( I_i ([h_t]_j)+ U \\frac{ \\partial h_t}{ \\partial U_{ij} } ) \\\\ =f'(z_{t+1}) \\odot ( I_i ([h_t]_j)+ U \\frac{ \\partial h_t}{ \\partial U_{ij} } )其中$I_i(x)$为除了第i行之外元素全为0的向量。 RTRL自从第一个时刻开始，除了计算RNN的隐状态之外，还利用（公式1-13）依次前向计算偏导数$\\frac{\\partial h_1}{ \\partial U_{ij}},\\frac{\\partial h_2}{ \\partial U_{ij}},\\frac{\\partial h_3}{ \\partial U_{ij}}…$ 这样假设第t个时刻存在一个监督信息，其损失函数为$L_t$，就可以同时计算损失函数对$U_{ij}$的偏导数（公式1-14）： \\frac{\\partial L_t}{ \\partial U_{ij}} =( \\frac{\\partial h_t}{ \\partial U_{ij} } )^T \\frac{\\partial L_t}{ \\partial h_t}这样在第t个时刻就可以实时计算$L_t$关于参数U的梯度，并更新参数。参数W和b的梯度也可以按照上述方法进行计算。 两种算法比较：RTRL算法和BPTT算法都是基于梯度求解参数，分别通过前向模式和反向模式应用链式法则来计算梯度。在RNN中一般输出维度要比输入维度少，因此BPTT算法的计算量会很小，但要保存计算过程中的梯度值，空间复杂度较高。RTRL算法不需要进行空间回传，比较适合用在在线学习或无限序列的任务中。 长期依赖在BRTT算法中，将（公式1-6）展开得到（公式1-15）： \\delta _{t,k}=\\prod_{i=k}^{t-1} ( diag('f(z_i ))U^T )\\delta _{t,t}如果定义$\\gamma \\approx || diag(‘f(z_i ))U^T ||$，则（公式1-16）： \\delta _{t,k}=\\gamma ^{t-k} \\delta _{t,t}若$\\gamma &gt;1$，当$t-k \\rightarrow +\\infty$，$\\gamma ^{t-k} \\rightarrow +\\infty$，会造成系统不稳定，称之为梯度爆炸（Gradient Exploding Problem），反之，若$\\gamma &lt; 1$，当$t-k \\rightarrow +\\infty$，$\\gamma ^{t-k} \\rightarrow 0$，会出现和前馈神经网络类似的梯度消失问题（Gradient Vanishing Problem）。 注意：在循环神经网络中，梯度消失指的是并不是说$\\frac{ \\partial L_t}{ \\partial U}$的梯度消失了，而是$\\frac{ \\partial L_t}{ \\partial h_k}$的梯度消失，当$t-k$很大时，即参数U的更新主要靠最近的几个状态来更新，长距离的状态对参数U没有影响。 当循环神经网络中使用的激活函数是Logistic或者tanh的时候，由于其导数小于1，并且权重矩阵$||U||$也不会太大，因此，如果时间间隔t-k过大的话，也会出现梯度消失问题。所以一般采用 ReLU激活函数（关于激活函数的介绍可参考：神经网络中的激活函数介绍）。 虽然简单循环网络理论上可以建立长时间间隔的状态之间的依赖关系，但是由于梯度爆炸和梯度消失问题，实际上只能学习到短期的依赖关系，这样如果t时刻的输出$y_t$依赖于$t-k$时刻的输入$x_{t-k}$，当间隔k比较大时，简单神经网络很难建模这种长距离的依赖关系，称之为长期依赖问题（Long-Term Dependences Problem）。 改进措施： 选取合适的参数 使用非饱和的激活函数 循环网络的梯度爆炸问题比较容易解决，一般通过梯度截断和权重衰减来避免。而梯度消失很难解决，通常是对模型进行调优来解决。 常见的循环神经网络结构主要包含四种： N：N 1：N N：1 N：M N比N结构N维输入对应N维输出，大致结构如下所示： 其常常用于处理以下问题： 视频理解中获取视频每一帧标签，输入为视频解码后的图像，通过此结构，获取每一 帧的标签信息。这种场景一般用作视频理解的初期，对视频做初步的处理后， 后续可以基于这些标签信息进行语义分析，构建更为复杂的需求场景。 股票价格预测。基于历史的股票信息输入，预测下一时刻或者未来的股票走势信息。 1比N结构一维输入，N维输出，大致结构如下图所示： 还有一种结构是在同一信息在不同时刻输入到网络中，如下所示： 其常常用于处理以下问题： 看图写描述 : 根据输入的 一张图 片，生成对这张图片的描述信息 自动作曲 : 按照类别生成音乐 N比1结构N维输入，一维输出，大致结构如下图所示： 其常常用于处理以下问题： 视频理解中的获取视频每个场景的描述信息，或者获取整个影片的摘要信息。 获取用户评价的情感信息，即根据用户的一句话的评论，来判断用户的喜好等情感信息 。 N比M结构N维输入，M维输出，这种结构又被称为Encoder-Decoder模型，也可以称为Seq2Seq模型，这种模型的输入和输出可以不相等，该模型由两部分组成：编码部分和解码部分，大致结构如下图所示： c的前半部分循环神经网络为编码部分，称之为Endcoder, c可以是s3的直接输出，或者 是对s3输出做一定的变换，也可以对编码部分所有的s1、s2、s3进行变换得到，这样c中就包 含了对X1、 Xz、码的编码信息 。c的后半部分循环神经网络为解码部分，称之为Decoder。c作为之前的状态编码，作为初始值，输入到Decoder当中。 Decoder经过循环处理，最终将信息解码输出。 除了上边所示的解码结构外，还有下图所示的结构： N比M的循环神经网络结构更具有普遍性，现实环境中有很多基于该结构落地的场景，他可以解决如下问题： 机器翻译：将不同语言作为输入，输出为非输入语言的类型，这也是Encoder-Decoder的经典用法 文本摘要：输入一篇文章，输出这篇文章的摘要信息 语音识别：输入一段语音，输出这段语音信息的文字 至此，循环神经网络（中）篇已经介绍完了，在下篇中会展开介绍更多的内容，欢迎关注。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"常见的五种神经网络(3)-循环神经网络（上）篇","slug":"TensorFlow/常见的五种神经网络(3)-循环神经网络（上）篇","date":"2019-09-08T08:37:58.000Z","updated":"2019-10-14T12:28:36.838Z","comments":true,"path":"2019/09/08/TensorFlow/常见的五种神经网络(3)-循环神经网络（上）篇/","link":"","permalink":"http://thinkgamer.cn/2019/09/08/TensorFlow/常见的五种神经网络(3)-循环神经网络（上）篇/","excerpt":"","text":"转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/100600661博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki 引言常见的五种神经网络系列第三种，主要介绍循环神经网络，由于循环神经网络包含的内容过多，分为上中下三篇进行介绍，本文主要是循环神经网络（上）篇，主要介绍以下内容： 循环神经网络概述 如何给神经网络增加记忆能力 延时神经网络 有外部输入的非线性自回归模型 循环神经网络 一般的循环神经网络 单向循环神经网络 双向循环神经网络 深度循环神经网络 循环神经网络应用到机器学习任务 该系列的其他文章： 常见的五种神经网络(1)-前馈神经网络 常见的五种神经网络(2)-卷积神经网络 常见的五种神经网络(3)-循环神经网络(上篇) 常见的五种神经网络(3)-循环神经网络(中篇) 常见的五种神经网络(3)-循环神经网络(下篇) 常见的五种神经网络(4)-深度信念网络 常见的五种神经网络(5)-生成对抗网络 概述在前馈神经网络中，信息在神经元之间的传递是单向，网络的输出只依赖于当前的输入，这样限制虽然使网络变得容易学习，但是却减弱了网络的表达能力。在很多现实任务中，网络的输出不仅和当前的输入有关，也和过去一段时间的输出相关，比如一个有限状态自动机不仅和当前的输入有关，也和当前的状态（上一步的输出）有关。如下图（图-1） 有限状态自动机称为FSM（finite state machine）或者FSA（finite state automaton） 此外，前馈神经网络难以处理时序数据，比如视频，语音，文本等。因为时序数据的长度是不固定的，而前馈神经网络要求输入和输出的维度是固定的。因此当处理这种复杂的时序数据时，就需要一种表达能力能强的模型。 循环神经网络(Recurrent Neural Network,RNN) 是一类具有短期记忆能力的神经网络，在循环神经网络中，神经元不仅可以接受其他神经元的信息，还可以接受自身的信息，形成一个环路结构。RNN的参数学习可以通过随时间反向传播算法进行学习（下文会具体介绍），随时间反向传播算法按照时间的逆序将错误信息一步步的向前传递，当输入序列时间较长时，会存在梯度消失和梯度爆炸问题（也叫长期依赖问题），为了解决这个问题，人们对RNN进行了许多改进，其中最有效的是引入门控制，比如长短期记忆网络（LSTM）和门控循环单元网络（GRU），将在（下）篇进行介绍。 如何给网络增加记忆能力上边提到前馈神经网络是一个静态网络，不能处理时序数据，那么可以通过以下三种方法给网络增加记忆能力： 延时神经网络 有外部输入的非线性自回归模型 循环神经网络 延时神经网络一种简单的利用利用历史信息的方法是建立一个额外的延时单元，用来存储网络的历史信息（比如输入，输出，隐状态等），这其中比较有代表性的就是延时神经网络（TDNN，Time Delay Neural Network）。 延时神经网络是在前馈神经网络的非输出层都添加一个延时器，记录最近几次神经元的输出，在第t个时刻，第（l+1）层的神经元和第（l）层神经元的最近p次输出有关，即（公式-1）: h_t^{l+1} = f(h_t^l,h_{t-1}^l,....,h_{t-p+1}^l)通过延时器，前馈神经网络就具有了短期记忆的能力。 有外部输入的非线性自回归模型自回归模型（Autoregressive Model） 是统计学中常用一类时间序列模型，用一个变量 $y_t$ 的历史信息来预测自己（公式-2）。 y_t = w_0 + \\sum_{i=1}^{p}w_p * y_{t-i} + \\varepsilon_t其中p为超参数，$w_p$ 为参数，$\\varepsilon_t～N(0,\\sigma ^2)$ 为第t个时刻的噪声，方差$\\sigma^2$和时间t无关。 有外部输入的非线性自回归模型（Nonlinear Autoregressive Model）是自回归模型的扩展，在每个时刻t都有一个外部输入$x_t$，产出一个输出$y_t$，NART通过一个延时器来记录最近几次的外部输入和输出，第t个时刻的输出$y_t$为（公式-3）： y_t = f(x_t, x_{t-1},..,x_{t-p}, y_{t-1},y_{t-2},....,y_{t-q})其中f(.)为非线性函数，可以是前馈神经网络，p和q为超参数。 循环神经网络给定一个输入序列，$x_{1:T}=( x_1, x_2, … , x_T )$ 循环神经网络通过以下公式（公式-4）更新带反馈边的隐藏层的活性值$h_t$： h_t = (h_{t-1}, x_t)循环神经网络示例如下（图-2）： 一般的循环神经网络在（图-2）中展示了一个简单的循环神经网络，其整个结构分为3层：输入层，隐藏层和输出层。其中t时刻，隐藏层的状态$h_t$不仅与输入$x_t$有关，还与上一个时刻的隐藏层状态$h_{t-1}$有关。 由于隐藏层多了一个自身到自身的输入，因此该层被称为循环层，（图-2）所示的为一个简单循环神经网络。循环神经网络还有多种类型，基于循环的方向划分为： 单向循环神经网络 双向循环神经网络 基于循环的深度分为： 循环神经网络 深度循环神经网络 单向循环神经网络（图-2）所示即为一个单向的循环神经网络，对其展开后的效果图如下（图-3）： 上图可以理解为网络的输入通过时间往后传递，当前隐藏层的输出$h_t$取决于当前层的输入$x_t$和上一层的输出$h_{t-1}$，因此当前隐藏层的输出信息包含了之前时刻的信息，表达出对之前信息的记忆能力。单向循环神经网络表达如下（公式-5）： o_t = g(V*h_t) \\\\ h_t = f(U*x_t + W*h_{t-1})其中$o_t$为输出层的计算公式， $h_t$为隐藏层的计算公式，g(.) 和 f(.)为激活函数。值得说明的是在循环神经网络中U，V，W权重矩阵值每次循环都是一份，因此循环神经网络的每次循环步骤中，这些参数都是共享的，这也是循 环神经网络 的结构特征之一。 双向循环神经网络在日常的信息推断中，当前信息不仅仅依赖之前的内容，也有可能会依赖后续的内容，比如英语的完形天空。这时候单向的循环神经网络就不能很好的处理，就需要 双向循环神经网络(Bi-directional Recurrent Neural Network) 。 其主要思想是训练一个分别向前和分别向后的循环神经网络，表示完整的上下文信息，两个循环 网络对应同一个输出层，因此可以理解为两个循环神经网络的叠加，对应的输出结果根据两个神经网络输出状态计算获得，将双向循环神经网络按照时间序列结构展开，如下图所示（图-4）： 从上图可以看出，隐藏层需要保留两部分，一部分为由前向后的正向传递$h_t$，一部分为由后向前的反向传递$h’_t$，最新的信息输出$o_t$。双向循环神经网络的表达公式如下（公式-6）： o_t = g(V*h_t + V'*h'_t) \\\\ h_t = f(U*x_t + W*h_{t-1}) \\\\ h'_t = f(U'*x_t + W'*h'_{t-1})深度循环神经网络上边介绍的单向训练神经网络和双向循环神经网络都只有一个隐藏层，但是在实际应用中，为了增强表达能力，往往引入多个隐藏层，即深度循环神经网络，如下图所示（图-5）： 同样可以得到深度循环神经网络的表达式（公式-7）： o_t = g(V^{(i)}*h^{(i)}_t + V'^{(i)}*h'^{(i)}_t) \\\\ h^{(i)}_t = f(U^{(i)}*h^{(i-1)}_t + W^{(i)}*h_{t-1}) \\\\ h'^{(i)}_t = f(U'^{(i)}*h'^{(i-1)}_t + W'^{(i)}*h'_{t+1}) \\\\ ... \\\\ h^{(1)}_t = f(U^{(1)} * h_t + W^{(1)}*h_{t-1}) \\\\ h'^{(1)}_t = f(U'^{(1)} * h_t + W'^{(1)}*h'_{t+1}) \\\\从上述公式可以看出，最终的输出依赖两个维 度的计算，横向上内部前后信息的 叠加，即按照时间的计算；纵向上是每一时刻的输入信息在 逐层之间的传递，即按照 空间结构的计算。 循环神经网络应用到机器学习任务循环神经网络可以应用到很多不同类型的机器学习任务，根据这些任务的特点，可以分为以下几种模式： 序列到类别模式 同步的序列到序列模式 异步的序列到序列模式 序列到类别模式主要应用在序列数据的分类问题，其输入为序列，输出为类别。比如在文本分类中，输入为单词序列，输出为文本的类别。 假设一个样本 $x_{1:T}=(x_1, x_2, … , x_T)$为一个长度为T的序列，输出为类别 $y \\in (1, …, C)$，可以将样本x按不同的时刻输入到循环神经网络中，并得到不同时刻的隐含状态$h_t$，可以将 $h_t$ 看作是整个序列的最终表示，并输入给分类器 g(.) 进行分类，如下所示（公式-8）： \\hat{y} = g(h_T)其中g(.) 为简单的线性分类器（比如LR）或者复杂的分类器（前馈神经网络）。 除了将最后时刻的状态作为序列表示之外，我们还可以对整个序列的状态进行平均，并用整个状态的最终平均作为整个序列的表示（公式-9）： \\hat{y} = g( \\frac{1}{T} \\sum_{t=1}^{T} h_t )公式-8 和公式-9 分别对应下图（图-6）的（a）和（b）: 同步的序列到序列模式主要用于序列标注（Sequence Labeling）任务，即每一时刻都有输入和输出，输入序列和输出序列的长度相同。比如词性标注（Part-of-Speech Tagging）中，每一个单词都需要标注其对应的词性标签。 假设一个样本 $x_{1:T}=(x_1, x_2, … , x_T)$为一个长度为T的序列，输出为序列 $y_{1:T}=(y_1, y_2, … , y_T)$，可以将样本x按不同的时刻输入到循环神经网络中，并得到不同时刻的隐含状态$h_t$，每个时刻的 $h_t$ 代表了当前时刻和历史的信息，并输入给分类器 g(.) 进行分类，得到当前的标签 $\\hat{y}_t$，如下所示（公式-8）： \\hat{y} = g(h_T), \\forall_t \\in [1,T] 异步的序列到序列模式异步的序列到序列模式也成为编码器-解码器，输入序列和输出序列不需要有严格的对应关系，也不需要保持相同的长度，比如在机器翻译中，输入为源语音的单词序列，输出为目标语言的单词序列。 假设输入为一个长度为T的序列 $x_{1:T}=(x_1, x_2, … , x_T)$，输出为长度为M的序列$y_{1:M}=(x_1, x_2, … , x_M)$，经常通过先编码后解码的形式实现。 先将样本x按不同时刻输入到一个循环神经网络（编码器）中，并得到其编码$h_T$，然后再使用另外一个循环神经网络（解码器）中，得到输出序列$\\hat {y}_{1:M}$。为了建立输出序列之间的依赖关系，在解码器中通常使用非线性的自回归模型。如下所示（公式-9）： h_t = f_1(h_{t-1},x_t), \\forall_t \\in [1,T] \\\\ h_{T+t} = f_2(h_{T+t-1},x_t), \\forall_t \\in [1,M] \\\\ \\hat{y} _t = g(h_{T+t}), \\forall_t \\in [1,M]其中 $f_1(.)$，$f_2(.)$分别为用作编码器和解码器的循环神经网络，g(.)为分类器，$\\hat{y}_t$ 为输出预测$\\hat{y}_t$的表示。 至此，循环神经网络（上）篇已经介绍完了，在（中）篇和下篇中会展开介绍更多的内容，欢迎关注。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"常见的五种神经网络(2)-卷积神经网络","slug":"TensorFlow/常见的五种神经网络(2)-卷积神经网络","date":"2019-09-05T10:05:24.000Z","updated":"2019-10-14T12:28:36.837Z","comments":true,"path":"2019/09/05/TensorFlow/常见的五种神经网络(2)-卷积神经网络/","link":"","permalink":"http://thinkgamer.cn/2019/09/05/TensorFlow/常见的五种神经网络(2)-卷积神经网络/","excerpt":"","text":"该系列的其他文章： 常见的五种神经网络(1)-前馈神经网络 常见的五种神经网络(2)-卷积神经网络 常见的五种神经网络(3)-循环神经网络(上篇) 常见的五种神经网络(3)-循环神经网络(中篇) 常见的五种神经网络(3)-循环神经网络(下篇) 常见的五种神经网络(4)-深度信念网络 常见的五种神经网络(5)-生成对抗网络 卷积神经网络（Convolutional Neural Network）是一种具有局部连接，权重共享等特性的深层前馈神经网络。一般是由卷积层，汇聚层，全连接层交叉堆叠而成，使用反向传播算法进行训练。其有三个结构上的特征：局部连接，权重共享以及汇聚。这些特征使得卷积神经网络具有一定程度上的平移，缩放和旋转不变性。较前馈神经网络而言，其参数更少。 卷积神经网络目前主要应用在图像和视频分析的各种任务上，比如图像分类，人脸识别，物体识别，图像分割等，其准确率也远远超过了其他的人工神经网络。近年来，卷积神经网络也应用到自然语言处理和推荐系统等领域。 卷积的概念卷积（Convolution）也叫摺积，是分析数学中一种重要的运算。在信号处理或者图像处理中，会经常使用一维或二维卷积。 一维卷积一维卷积经常用在信号处理上，用来计算信号的累积。假设一个信号发生器每个时刻t发生一个信号 $x_t$，其信号衰减率维$w_k$，即在$k-1$时刻后，信息变为原来的$w_k$倍，假设$w_1 = 1, w_2=1/2,w_3=1/4$那么在t时刻收到的信号$y_t$为当前时刻产生的信息之前时刻产生的延迟信息的叠加(公式1.1)。 y_t = 1 * x_t + 1/2 * x_{t-1} + 1/4 * x_{t-2} \\\\ =w_1 * x_t + w_2 * x_{t-1} + w_3 * x{t-2} \\\\ = \\sum_{k=1}^{3} w_k * x_{t-k+1}我们把$w_1, w_2, ….$称为滤波器（Filter）或者卷积核（Convolution Kernel）。假设滤波器长度为m，它和一个信号序列$x_1,x_2,…$的卷积为(公式1.2)： \\sum_{k=1}^{m} w_k * x_{t-k+1}信号序列x和滤波器w的卷积定义为(公式1.3)： y = w \\otimes x一维卷积示例如下： 二维卷积卷积也常用在图像处理中，因为图像是一个二维结构，需要对一维卷积进行扩展。给定一个图像$X \\in R^{MN}$和滤波器$W \\in R^{mn}$，一般$m &lt;&lt; M, n &lt;&lt;N$，其卷积为(公式1.4)： y_{ij}=\\sum_{u=1}^{M}\\sum_{v=1}^{N} w_{uv} * x_{i-u+1,j-v+1}二维卷积示例如下： 注意：上图中的展示的卷积核（3*3矩阵）和二维结构数据相乘时需要逆时针旋转180度！对照着卷积公式可以理解。 互相关在计算卷积过程中，需要进行卷积核翻转，在具体实现上一般会以互相关操作来代替卷积，从而会减少一些不必要的操作或者开销。互相关是一个衡量两个序列相关性的函数，通常是用滑动窗口的点积计算来实现。给定一个图像$X \\in R^{MN}$和卷积核$W \\in R^{mn}$，他们的互相关为(公式1.5)： y_{ij}=\\sum_{u=1}^{M}\\sum_{v=1}^{N} w_{uv} * x_{i+u-1,j+v-1}和公式1.4相比，互相关和卷积的区别在于是否对卷积核进行翻转，因此互相关也称为不翻转卷积。 在神经网络中使用卷积是为了进行特征抽取，卷积核是否进行核翻转与其特征抽取能力无关。特别是当卷积核是可学习的参数时，卷积和互相关是等价的，因此为了实现方便，通常使用互相关来代替卷积。事实上很多深度学习工具中卷积操作都是用互相关来代替的。 公式1.5可以表示为： Y = W \\otimes X 常见的卷积核及特征常见的卷积核 对图像无任何影响的卷积核 \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix} 对图像进行锐化的滤波器 \\begin{bmatrix} -1 & -1 & -1 \\\\ -1 & 9 & -1 \\\\ -1 & -1 & -1 \\end{bmatrix} 浮雕滤波器 \\begin{bmatrix} -1 & -1 & 0 \\\\ -1 & 0 & 1 \\\\ 0 & 1 & 1 \\end{bmatrix} 均值模糊滤波器 \\begin{bmatrix} 0 & 0.2 & 0 \\\\ 0.2 & 0.2 & 0.2 \\\\ 0 & 0.2 & 0 \\end{bmatrix} 均值模糊是对像素点周围的像素进行均值化处理，将上下左右及当前像素点分文5份，然后进行平均，每份占0.2，即对当前像素点周围的点进行均值化处理。 高斯模糊滤波器 均值模糊是一种简单的模糊处理方式，但是会现实模糊不够平滑，而高斯模糊可以很好的处理，因此高斯模糊经常用于图像的降噪处理上，尤其是在边缘检测之前，进行高斯模糊，可以移除细节带来的影响。 一维高斯模糊 G(x)=\\frac{1}{ \\sqrt{2 \\pi \\sigma ^2}} e^{( -\\frac{x^2}{2\\sigma ^2} )} 二维高斯模糊 G(x)=\\frac{1}{ \\sqrt{2 \\pi \\sigma ^2}} e^{( -\\frac{x^2+y^2}{2\\sigma ^2} )} 卷积核的特征 这里的滤波器就是卷积核 当滤波器矩阵中的值相加为0甚至更小时，被滤波器处理之后的图像相对会比原始图像暗，值越小越暗 当滤波器矩阵中的值相加和为1时，被滤波器处理之后的图像与原始图像的亮度相比几乎一致 当滤波器矩阵中的值相加和大于1时，被滤波器处理之后的图像相对会比原始图像的亮度更亮 卷积的变种在卷积的标准定义基础上，还可以引入滤波器的滑动步长和零填充来增加卷积的多样性，可以更加灵活的提取特征。 滤波器的步长（Stride）是指滤波器在滑动时的时间间隔 零填充（Zero Padding）是在输入向量两端进行补零 下图展示为步长为2和零填充的示例： 假设卷积层的输入神经元个数为n，卷积大小为m，步长为s，输入神经元两端各补p各零，那么该卷积对应的神经元数量为：(n+2p-m)/s + 1。 一般的卷积分为以下三种： 窄卷积（Narrow Convolution）：步长s=1，两端不补零即p=0，卷积后输出长度为：n-m + 1 宽卷积（Wide Convolution）：步长s=1，两端补零p=m-1，卷积后输出长度为：n+m-1 等宽卷积（Equal-Width Convolution）：步长s = 1,两端补零p = (m −1)/2,卷积后输出长度 n。 卷积的数学性质卷积有很多比较好的数学性质，这里主要介绍一些二维的数学性质，同样针对一维卷积也同样适用。 交换性如果不限制两个卷积的长度，卷积是具有交换性的。即 $x \\otimes y = y \\otimes x$，当输入信息和卷积核有固定长度时，他们的宽卷积依然具有交换性。对于两维图像$X \\in R^{MN}$和卷积核$W \\in R^{mn}$，对图像X的两个维度进行零填充，两端各补m-1和n-1个零，得到全填充（Full Padding）的图像$\\tilde{X} \\in R^{(M+2m-2)(N+2n-2)}$。图像X和卷积核W的宽卷积（Wide Convolution）定义为：$W \\tilde{\\otimes } X \\triangleq X \\tilde{\\otimes } W$，其中$\\tilde{\\otimes }$为宽卷积操作。宽卷积具有交换性，即：$W \\tilde{\\otimes } X = X \\tilde{\\otimes } W$ 导数假设$Y = W \\otimes X$，其中$X \\in R^{MN}$，$W \\in R^{mn}$，$Y \\in R^{(M-m+1)*(N-n+1)}$，函数$f(Y) \\in R$为一个标量函数，则(公式1.6) \\frac{\\partial f(Y)}{\\partial w_{uv}} = \\sum_{i=1}^{M-m+1}\\sum_{j=1}^{N-n+1} \\frac{\\partial f(Y)}{\\partial y_{ij}} \\frac{\\partial y_{ij}}{\\partial w_{uv}} \\\\ = \\sum_{i=1}^{M-m+1}\\sum_{j=1}^{N-n+1} \\frac{\\partial f(Y)}{\\partial y_{ij}}x_{ {i+u-1},{j+v-1}} \\\\ = \\sum_{i=1}^{M-m+1}\\sum_{j=1}^{N-n+1} \\frac{\\partial f(Y)}{\\partial y_{ij}}x_{ {u+i-1},{v+j-1}}从公式1.6可以看出，f(Y)关于W的偏导数为X和$\\frac{\\partial f(Y)}{\\partial Y}$的卷积（公式1.7） \\frac{\\partial f(Y)}{\\partial W} = \\frac{\\partial f(Y)}{ \\partial Y } \\otimes X同理得到（公式1.8）： \\frac{\\partial f(Y)}{\\partial x_{st}} = \\sum_{i=1}^{M-m+1}\\sum_{j=1}^{N-n+1} \\frac{\\partial f(Y)}{\\partial y_{ij}} \\frac{\\partial y_{ij}}{\\partial x_{st}} \\\\ = \\sum_{i=1}^{M-m+1}\\sum_{j=1}^{N-n+1} \\frac{\\partial f(Y)}{\\partial y_{ij}}w_{ {s-i+1},{t-j+1}}其中当$(s-i+1) &lt; 1$，或$(s-i+1)&gt;m$，或$(t-j+1) n$，或$w_{s-i+1,t-j+1}=0$时，即相当于对W进行了 p=(M-m,N-n)的零填充。 从公式1.8可以看出，f(Y)关于X的偏导数为W和$\\frac{\\partial f(Y)}{ \\partial Y }$，公式1.8中的卷积是真正的卷积而不是互相关，为了一致性，我们用互相关的卷积，即(公式1.9)： \\frac{\\partial f(Y)}{\\partial X} = rot180(\\frac{\\partial f(Y)}{\\partial X}) \\tilde{\\otimes }W=rot180(W) \\tilde{\\otimes }\\frac{\\partial f(Y)}{\\partial X}其中rot180(.)表示旋转180度。 卷积神经网络卷积神经网络一般由卷积层，汇聚层和全连接层构成。 用卷积代替全连接在全连接前馈神经网络中，如果第$l$层有$n^l$个神经元，第$l-1$层有$n^{l-1}$个神经元，连接边就有$n^l * n^{l-1}$也就是权重参数有这么多个，当m和n都很大时，权重矩阵的参数会非常多，训练的效率会非常低。 如果用卷积代替全连接，第$l$层的净输入$z^l$与$l-1$层活性值$a^{l-1}$和滤波器$w^l \\in R^m$的卷积，即$z^l = w^l * a^{l-1} + b^l$,其中滤波器$w^l$为可学习的权重向量，$b^l \\in R^{l-1}$为可学习的偏置。 根据卷积的定义，卷积层有两个很重要的性质： 局部连接：在卷积层(假设是第$l$层)中的每一个神经元都只和下一层(第$l − 1$层)中某个局部窗口内的神经元相连,构成一个局部连接网络。 全局共享：作为参数的滤波器 $w^l$，对于第 $l$层的所有的神经元都是相同的。 卷积层卷积层的作用是提取一个局部区域的特征，不同大小的卷积相当于不同的特征提取器。上文介绍的卷积和神经元都是一维的，但卷积神经网络主要是针对图像处理而言的，而图像通常是二维的，为了充分利用图像的局部特征，通常将神经元组织为三维结构的神经层，其大小 M 宽度 W 深度 D，即D个M*N的特征映射组成。 对于输入层的而言，特征映射就是图像本身，如果是灰色图像，则深度为1，如果为彩色图像（分别是RGB三个通道的颜色特征映射），则深度为3。 汇聚层汇聚层（Pooling Layer）也叫子采样层（Subsampling Layer），其作用是进行特征选择，降低特征数量，从而减少参数数量。 卷积层虽然可以明显减少网络中的连接数量，但是特征映射中的神经元个数并未显著减少。如果后边接一个分类器的话，分类器的输入维数依然很高，很容易出现过拟合。因此有了汇聚层的产生，在卷积后边加一个汇聚层，从而降低特征维数，避免过拟合。 假设汇聚层的输入特征映射组为$X \\in R^{M N D}$，对于其中每一个映射$X^d$，将其划分为很多区域$R^d_{m,n}$，1 &lt;= m &lt;= M’，1&lt;= n &lt;= N’，这些区域可以重叠，也可以不重叠。汇聚（Pooling）是指对每个区域进行下采样（Down Sampling）得到一个值，作为这个区域的概括。常见的汇聚方式有两种： 最大汇聚（Maximum Pooling）：一个区域内所有神经元的最大值 平均汇聚（Mean Pooling）：一个区域内所有神经元的平均值 典型的汇聚层是将每个特征映射划分为22大小的不重叠区域，然后使用最大汇聚的方式进行下采样。汇聚层也可以看作是一个特殊的卷积层，卷积核大小为m m，步长为s * s，卷积核为 max函数或者mean函数。过大的采样区域会急剧减少神经元的数量，会造成过多的信息损失。 下图所示为最大汇聚示例： 全连接层在全连接层中，将最后一层的卷积输出展开，并将当前层的每个节点与下一层的另一个节点连接起来。全连接层只是人工神经网络的另一种说法，如下图所示，全连接层中的操作与一般神经网络中的操作完全相同。 对于output layer中的的每个神经元，其表达式可以记做为(公式1.10)： y = \\sigma (\\sum_{i=1}^{m} w_i ^T x_i + b)如果outptu有多个神经元，最终可以通过softmax进行最终类别的判断。 典型的卷积网络结构一个典型的卷积网络是有卷积层，汇聚层，全连接层交叉堆叠而成。目前常用的卷积神经网络结构如下图所示： 卷积块是由M个卷积层b个汇聚层（M通常在2～之间，b为0或1），一个卷积网络中可以堆叠N个连续的卷积块，然后再接着K个全连接层（N的取值空间比较大，一般是1～100或者更大，K通常为0～2）。 目前整个网络倾向于使用更小的卷积核（比如11或者33）以及更深的结构（比如层数大于50），此外，卷积操作的灵活性越来越大，汇聚层的作用变得越来越小，因此目前流行的卷积网络中，汇聚层的比例也在逐渐降低，倾向于全连接网络。 参数学习在卷积神经网络中，参数为卷积核中的权重和偏置，和全连接前馈神经网络一样，使用误差反向传播算法来进行参数学习。梯度主要通过每一层的误差项$\\delta$进行反向传播，并进一步计算每一层的梯度。在卷积神经网络中主要有两种功能不同的网络层：卷积层和汇聚层。而参数为卷积核中权重和偏置，因此只需要计算卷积层中参数梯度。 不失一般性，对第$l$层卷积层,第$l-1$层的输入特征映射为$X^{(l-1)} \\in R^{MND}$，通过卷积计算得到第$l$层净输入为$Z^{(l)}\\in R^{M’N’P}$，第$l$层的第p(1&lt;= p &lt;= P)个特征净输入为(公式1.11) Z^{(l,p)} = \\sum_{d=1}^{D} W^{(l,p,d)} \\otimes X^{(l-1,d)}+ b^{(l,p)}其中$W^{(l,p,d)} ,b^{(l,p)}$为卷积核以及偏置。第$l$层共有P * D 个卷积和P个偏置，可以分别使用链式法则计算其梯度。 根据公式1.7 和 1.11，损失函数关于第$l$层的卷积核$W^{(l,p,d)}$的偏导数为为(公式1.12)： \\frac{\\partial L (Y,\\hat{Y})}{ \\partial W^{(l,p,d)} } = \\frac{\\partial L (Y,\\hat{Y})}{ \\partial Z^{(l,p)} } \\otimes X^{(l-1,d)}=\\delta ^{(l,p)} \\otimes X^{(l-1,d)}其中为(公式1.13) \\delta ^{(l,p)} = \\frac{\\partial L (Y,\\hat{Y})}{ \\partial Z^{(l,p)} }为损失函数关于第$l$层的第p个特征映射净输入$Z^{(l,p)}$的偏导数。 同理可得，损失函数关于第$l$层的第p个偏置$b^{(l,p)}$的偏导数为为(公式1.14)： \\frac{ \\partial L (Y,\\hat{Y}) }{ \\partial b^{(l,p)} } = \\sum_{i,j} [\\delta ^{(l,p)}]_{i,j}卷积网络中，每层参数的梯度依赖其所在层的误差项$\\delta ^{(l,p)}$ 误差项的计算卷积层和汇聚层的误差项计算不同。 卷积层当$l+1$层为卷积层时，假设特征映射净输入(公式1.15) Z^{(l+1,p)} = \\sum_{d=1}^{D} W^{(l+1,p,d)} \\otimes X^{(l,d)} + b^{(l+1,p)}其中$W^{(l+1,p,d)},b^{(l+1,p)}$为第$l$层的卷积核和偏置。第$l+1$层共有 P *D 个卷积核和P个偏置。 第 $l$层的第 $d$个特征映射的误差项$\\delta ^{(l,d)}$的具体推导过程如下(公式1.16): \\delta ^{(l,d)} \\triangleq \\frac{\\partial L (Y,\\hat{Y})}{ \\partial Z^{(l,d)} } \\\\ =\\frac{\\partial X^{(l,d)} } { \\partial Z^{(l,d)}} \\cdot \\frac{\\partial L (Y,\\hat{Y})}{ \\partial X^{(l,d)} } \\\\ = f'_l (Z^{(l,p)}) \\odot \\sum_{p=1}^{P}( rot180(W^{(l+1,p,d)} ) \\tilde{\\otimes } \\frac{\\partial L(Y,\\hat{Y})}{ \\partial Z^{(+1,p)}}) \\\\ = f'_l (Z^{(l,p)}) \\odot \\sum_{p=1}^{P}(rot180(W^{(l+1,p,d)} ) \\tilde{\\otimes }\\delta ^{(l+1,p)})其中$\\tilde{\\otimes}$表示宽卷积。 汇聚层当第$l+1$层为汇聚层时, 因为汇聚层是下采样操作, $l+1$层的每个神经元的误差项 $\\delta$对应于第$l$层的相应特征映射的一个区域。$l$层的第$p$个特征映射中的每个神经元都有一条边和$l+1$层的第$p$个特征映射中的一个神经元相连。 根据链式法则,第$l$层的一个特征映射的误差项$\\delta ^{(l,p)}$，只需要将 $l+1$层对应特征映射的误差项$\\delta ^{(l+1,p)}$进行上采样操作(和第 $l$层的大小一样) ,再和 $l$层特征映射的激活值偏导数逐元素相乘,就得到了 $\\delta ^{ (l,p)}$ 第 $l$层的第$p$个特征映射的误差项$\\delta ^{(l,p)}$的具体推导过程如下(公式1.17)： \\delta ^{(l,p)} \\triangleq \\frac{\\partial L (Y,\\hat{Y})}{ \\partial Z^{(l,p)} } \\\\ =\\frac{\\partial X^{(l,p)} } { \\partial Z^{(l,p)}} \\cdot \\frac{\\partial Z^{(l+1,p)} } { \\partial X^{(l,p)}} \\cdot \\frac{\\partial L (Y,\\hat{Y})}{ \\partial Z^{(l+1,p)} } \\\\ = f'_l (Z^{(l,p)}) \\odot up(\\delta ^{(l+1,p)})其中$f’_l$为第l层使用的激活函数导数，up为上采样函数(upsampling)，与汇聚层中使用的下采样函数刚好相反，如果下采样是最大汇聚（max pooling），误差项$\\delta ^{(l+1,p)}$中每个值都会传递到上一层对应区域中的最大值所对应的神经元，该区域中其他位置的神经元的误差都设为0，如果下采样是平均汇聚(mean pooling) ,误差项 $\\delta ^{(l+1,p)}$中每个值会被平均分配到上一层对应区域中的所有神经元上。 几种典型的卷积神经网络LeNet-5LeNet-5 虽然提出的时间比较早（LeCun et al., 1998），但是一个非常成功的卷积神经网络模型，90年代在许多银行进行使用，用来识别手写数字，其网络结构如下： AlexNetAlexNet是第一个现代深度卷积网络模型，其首次使用了现在深度卷积网络的一些技巧，比如GPU并行训练，采用ReLU作为非线性激活函数，使用DropOut防止过拟合，使用数据增强来提高模型准确率。AlexNet获得了2012年ImageNet图像分类比赛的冠军，其网络结构如下： Inception在卷积网络中，如何定义一个卷积的大小是一个十分关键的问题，在Inception网络中，一个卷积层包含多个不同大小的卷积操作，称为Inception模块， Inception网络是由多个inception模块和汇聚层堆叠而成。 Inception模块同时使用11，33，55等大小不同的卷积核，并将得到的特征映射在深度上拼接（堆叠）起来作为输出特征映射。下图给出了v1版本的inception模块结构图，采用了4组平行的特征抽取方式，分别为11，33，55的卷积和33的最大汇聚，同时为了提高计算效率，减少参数数量，inception模块在进行33，55的卷积之前，33的最大汇聚之后，进行一次1*1的卷积来减少特征映射的深度。 Inception网络最早的v1版本就是非常著名的GoogleNet，获得了2014年ImageNet图像分类竞赛的冠军。其结构图如下所示： 当然Inception网络有多个改进版本，比如Inception-v3网络，Inception-ResNet v2网络和改进版的Inception-v4模型。 残差网络残差网络（Residual Network，ResNet）是通过给非先行的卷积层增加直连边的方式来提高信息的传播效率。 假设在一个深度网络中，我们期望一个非线性单元$f(x,\\theta)$去逼近一个目标函数为h(x)。如果将目标函数拆分为两部分：恒等函数（Identity）和残差函数（Reside Function）h(x)-x。 h(x) = \\underset{IdentityFunc}{\\underbrace{x}} +( \\underset{ResidueFunc}{\\underbrace{h(x)-x}})根据通用近似定理，一个由神经网络构成的非线性单元有足够的能力来近似逼近原始目标函数或残差函数，但实际中后者更容易血虚。因此原来的优化问题可以转化为：让非线性单元$f(x,\\theta)$去近似残差h(x)-x,并用$f(x,\\theta) +x$去逼近h(x)。 下图给出了一个典型的残差单元示例，残差单元由多个级联的（等长）卷积层和一个跨层的直连边组成，再经过ReLU激活后得到输出。残差网络就是将很多个残差单元串联起来构成的一个非常深的网络。 其他卷积方式转置卷积我们一般通过卷积操作来实战高维特征到低维特征的转换，但在一些任务中需要把低维特征映射到高维特征，并且希望通过卷积操作来实现。 卷积操作可以通过仿射变换的形式。假设一个5维的向量x，经过大小为3的卷积核w=[w1,w2,w2]^T来进行卷积，得到3维向量z，卷积操作可以写为： 其中C是一个稀疏矩阵，其非零元素来自于卷积核w中的元素。如果实现3维向量z到5维向量x的映射，可以通过仿射矩阵转置来实现。 其中rot180(.)表示旋转180度。 我们将低维特征映射到高维特征的卷积操作称之为转置卷积（Transposed Convolution），也叫反转卷积（Deconvolution）。 空洞卷积对于一个卷积层，如果希望增加输出单元的感受野，一般可以通过三种方式实现： 增加卷积核的大小 增加层数 在卷积之前进行汇聚操作 前两种会增加参数数量，最后一种会丢失一些信息。 空洞卷积（Atrous Convolution）也成为膨胀卷积（Dilated Convolution），是一种不增加参数数量，同时增加输出单元感受野的一种方法。 空洞卷积通过给卷积核插入“空洞”来变相的增加其大小，如果在卷积核的每两个元素之间插入d-1个空洞，卷积核的有效大小维：$m’=m+ (m-1) * (d-1)$其中d称为膨胀率（Dilation Rate）。当d=1时卷积核维普通的卷积核。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"【论文】RecSys18-序列推荐模型TransFM(Translation-based Factorization Machines for Sequential Recommendation)","slug":"论文/【论文】RecSys18-序列推荐模型TransFM(Translation-based Factorization Machines for Sequential Recommendation)","date":"2019-08-31T01:14:39.000Z","updated":"2019-11-14T02:26:37.481Z","comments":true,"path":"2019/08/31/论文/【论文】RecSys18-序列推荐模型TransFM(Translation-based Factorization Machines for Sequential Recommendation)/","link":"","permalink":"http://thinkgamer.cn/2019/08/31/论文/【论文】RecSys18-序列推荐模型TransFM(Translation-based Factorization Machines for Sequential Recommendation)/","excerpt":"序列推荐模型 Translation-based Recommendation，参考：点击阅读","text":"序列推荐模型 Translation-based Recommendation，参考：点击阅读 概述论文是由Rajiv Pasricha和Julian McAuley两位大佬提出的发表在RecSys18 上的，是TransRec和FM的结合版本（论文下载地址：https://cseweb.ucsd.edu/~jmcauley/pdfs/recsys18a.pdf）。在下面会简单介绍TransRec和FM。 对于电商网站（如亚马逊），媒体网站（如Netflix，Youtube）等而言，推荐系统是其中至关重要的一环。传统的推荐方法尝试对用户和物品的全局交互进行建模。例如矩阵分解和其派生模型，虽然能够有效的捕获到用户的偏好，但是未考虑到时序特征，其忽略了用户的最近交互行为，提供了一个静态的推荐列表。 序列推荐的目的是基于用户的历史行为序列去预测用户将来的行为。Julian McAuley作为主要作者的另一篇论文（Translation-based Recommendation）提出了“翻译”空间的概念，将物品作为一个点嵌入到“翻译”空间内，用户的序列行为则作为一个翻译向量存在于该空间，然后通过距离计算便根据用户u的当前行为物品i，预测其接下来可能有行为的物品，具体可参考：https://mp.weixin.qq.com/s/YovZKGd2BDqnpW5BBGLA-A。TransRec的主要思路如下图所示： 本论文中提出了TransFM，其结合了FM和TransRec的思想，将其应用在序列推荐中，这样做的好处是使用简单的模型对复杂的交互之间进行建模并能取得不错的效果。 FM能够对任意的实值特征向量进行操作，并通过参数分解对特征之间的高阶交互进行建模。他可以应用在一般的预测任务里，并可以通过特征替换，取代常见的推荐算法模型。 TransFM的主要思路如下图所示： TransFM是对所有观察到的行为之间可能的交互进行建模，对于每一个特征i，模型学习到两部分：一个低维的embedding向量$\\overrightarrow{v_i}$和一个翻译向量$\\overrightarrow{v_i’}$ 特征之间的交互强度使用平方欧几里德距离来进行计算，在上图中，展示了user，item，time的embedding特征和翻译向量，交互行为之间的权重由起始点和结束点之间的平方欧几里德距离进行计算。与FM一样，TransFM可以在参数和特征纬度的线性时间内进行计算，从而有效的实现大规模数据集的计算。 相关研究序列推荐已经存在了许多基于MC（马尔可夫链，Markov Chains）的序列推荐模型，比如FPMC（Factorized Personalized Markov Chains），使用独立分解矩阵对三阶交互行为进行分解，继而来模拟成对的相互作用。PRME使用欧几里德距离替换内积对用户-物品之间的交互行为进行建模。TransRec同样也是一个序列推荐模型，通过共享物品的embedding向量空间，将用户行为转化为翻译向量，其计算公式如下： 这些对于给定的用户历史行为序列十分有效，但是在不改变模型结构的前提下，并不能捕获时间，地理和其他的上下文特征。 ## 因子分解机 FM对于任意的机器学习任务来讲是一个通用的学习框架，他模型任意任意特征之间的二阶交互，并很容易扩招到更高阶，每个特征的交互通过参数之间的内积来权衡。其公式如下（这里讨论的是FM的二阶形式）： 通过选择合适的损失函数，FM可以应用在任意的分类，回归或者排序任务中，在这篇文章里主要是针对隐式反馈结合BPR算法框架去优化预测的结果。 ## 混合推荐 混合推荐结合了协同和conetnt-based，目的在于提升效果并且为行为很较少的用户提供有效的选择，在一定程度上缓解了用户冷启动。这里可以利用的潜在的信息包括：时间特征，地理特征，社交特征等。最近的一些关于混合推荐的工作结合了图像特征，或者是使用深度学习自动生成有用的内容特征。 虽然这些方法都取得了不错的表现，但依赖于专门的模型和技术。相比之间，论文里提出的TransFM是一种更广义的办法，可以对任意的特征向量和预测任务进行操作，通过适当的特征工程，TransFM模型可以结合时间，地理，人口统计和其他内容特征，而无需更改模型本身结构。 # TransFM模型 ## 问题定义 TransFM使用平方欧几里德距离替换FM中的内积计算，并用embedding 向量和翻译向量之和表示特征v_i的向量，其公式如下： 其中距离计算方式为： 使用平方欧几里德距离替换内积的好处是：提高模型的泛化能力，更有效的捕获embedding之间的传递性。比如(a,b)，(b,c)之间有很高的交互权重，那么(a,c)之间的相关性也会更强。 下图展示了TransFM和其他几种算法的预测方法，从中可以看出PRME学习的是两个用户的embedding向量之间的距离，FM学习的是任意特征与相应参数之间的内积，TransRec学习的是物品的embedding向量和用户行为的翻译序列，TransFM学习的是每个特征的embedding向量和翻译向量，使用平方欧几里德距离去度量特征之间的交互。 ## 模型计算 FM是可以将计算复杂度降低到nk的，同样TransFM也可以降低其计算负责度。首先： 其次进行化简得： 上面的第一个总和可以分成六个单独项，每一项又可以继续进行化简： 假设输入的特征是n维，隐向量长度为k，那么时间复杂度就是O(nk)，而不是O(n^2k)。 参数优化模型使用S-BPR（Sequential Bayesian Personalized Ranking）进行优化，其优化方式如下： 其中Ω(Θ)为L2正则。 ## 实践和推断 作者等人在TensorFlow中对TransFM进行了实现，用的是mini-batch gradient descent 和 Adam进行模型的训练（adam对于有大量参数且稀疏的数据集上表现良好）。 作者这里也罢代码进行了开源，包括数据集，已经不同算法实现实现对比，其地址为：https://github.com/rpasricha/TransFM # 实验 作者结合了一些算法在亚马逊和谷歌数据集上进行测试，其中评价的指标是AUC，效果如下： 上边的Table 3是指从Amazon选取top5 品类 ，从Google Local 中选取6个城市作为实验依据。 FM模型和其他模型的融合PRME（Personalized Ranking Metric Embedding） 和TransFM对比的不同在于TransFM中i的向量是embedding向量和translation向量和，而这里没有translation向量。实时证明TransFM效果要好很多。 HRM（Hierarchical Representation Model ） 对比的实验结果如下： 我的总结 TransFM结合了TransRec 和 FM和优势，在大量，稀疏的数据集上取得了不错的效果。 在参数和特征纬度下，计算时间线性增大（nk） 改变FM中的内积计算方式，使用平方欧几里德距离，提高了模型的泛化能力，和样本特征之间的传递性 在不改变模型结构的前提下，可以轻易将时间，地域或者其他内容特征加入到模型中 数据集拆分时避免了从整体数据集中的随机拆分，而是按照时间先后的顺序进行拆分。保证了一定的时间连续性，很多论文中划分训练集和测试集时都是这样做的，在工业界中模型的训练和评估大部分也是这样做的。 根据经验将参数限定在一个范围内，根据网格搜索法寻找最佳参数 实验对比的丰富性，使结论更具有说服力 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"论文","slug":"论文","permalink":"http://thinkgamer.cn/tags/论文/"},{"name":"TransFM","slug":"TransFM","permalink":"http://thinkgamer.cn/tags/TransFM/"}]},{"title":"【论文】RecSys17-序列推荐模型 Translation-based Recommendation","slug":"论文/【论文】RecSys17-序列推荐模型 Translation-based Recommendation","date":"2019-08-29T00:19:12.000Z","updated":"2019-10-14T06:42:35.690Z","comments":true,"path":"2019/08/29/论文/【论文】RecSys17-序列推荐模型 Translation-based Recommendation/","link":"","permalink":"http://thinkgamer.cn/2019/08/29/论文/【论文】RecSys17-序列推荐模型 Translation-based Recommendation/","excerpt":"序列推荐模型 TransFM（Translation-based Factorization Machines for Sequential Recommendation）参考：点击阅读","text":"序列推荐模型 TransFM（Translation-based Factorization Machines for Sequential Recommendation）参考：点击阅读 背景这篇论文是由 Ruining He，Wang-Cheng Kang和Julian McAuley三位大佬提出的，在2017年的ACM推荐系统会议（RecSys’17）上获得了最佳论文奖（在大佬主页可以下载该论文中涉及的代码和数据集，可惜代码是C++写的，不懂C++的童鞋挑战性很大～） 第一作者的Ruining He主页为https://sites.google.com/view/ruining-he/ RecSys历届最佳论文地址：https://recsys.acm.org/best-papers/ 本论文下载地址：https://arxiv.org/pdf/1707.02410.pdf 论文的两个研究点： 用户的序列推荐（用户在浏览了一些items之后给他推荐物品j） 物品到物品的推荐（用户购买了一个牛仔裤，给他推荐一个衬衫） 概述对用户和物品以及物品和物品之间的关系进行建模是设计一个成功推荐系统的核心。一种经典的做法是预测用户行为序列（或者是下一个物品的推荐），其挑战在于对用户，用户历史行为物品和用户接下来有行为的物品之间的三阶交互关系进行建模。现有的方法是对这些高阶的交互分解为成对的关系组合，通过不同的模型去对用户的偏好（用户和物品的交互）和序列匹配（物品和物品的交互）进行建模。 比如MF（Matrix Factorization，矩阵分解）只对用户和物品之间的交互行为进行建模；MC（Markov Chain，马尔可夫链）只对用交互过程中的物品对进行建模，通常通过对转移矩阵进行分解提高其泛化能力。 对于序列推荐，研究者提出了可扩展的张量分解方法，比如FPMC（Factorized Personalized Markov Chains），FPMC通过两个成对的交互关系来模拟u，i，j之间的三阶交互关系，其实这就是MF和MC的结合。对于提升FPMC有两个方向的研究思路，一个思路是在个性化度量嵌入方法用欧几里德距离替换FPMC中的内积，其中度量假设尤其是三角不等式使模型的泛化性更好，然而，这些研究工作采用的仍然是对用户偏好和序列的连续性分别建模的框架，由于这两部分本身存在关系，因此这样做是存在一定的问题的。另一个思路是利用平均/最大池化等操作去聚合用户u和前一项i的向量表示，然后再测量它们与下一个项j的相似度，这种思路虽然部分解决了两个组件之间的相互依赖问题，但很难解释而且不能从度量embedding向量中获得收益。 为了解决上述存在的问题，提出了Translation-based Recommendation模型，具体解释往下看。 模型介绍问题定义涉及的相关字符含义如下图所示： 模型结构TransRec的主要思路如下图： 物品作为一个点被嵌入到翻译空间内，用户的序列行为则作为一个翻译向量存在于该空间，然后，通过个性化翻译操作捕获前面提到的三阶交互，其基本思路就是用户的翻译向量和上一个行为物品的翻译向量之和，确定下一个有行为的物品j，如下所示 \\underset{ \\gamma _i }{\\rightarrow} + \\underset{t_u}{\\rightarrow} \\approx \\underset{ \\gamma _j }{\\rightarrow}其中距离的计算可以采用L1-distance或者L2-distance。由于生产环境中数据的稀疏性，很难为每个用户学习到一个向量，因此添加了一个全局翻译向量来初始化所有的用户，这样也能够有效的缓解用户冷启动。如下所示 \\underset{ T_u }{\\rightarrow} = \\underset{t}{\\rightarrow} + \\underset{ t_u }{\\rightarrow}在一个生产系统中，往往会存在头部物品（即热门物品），这些物品的流行度很高，那么如果仅仅采用简单的距离计算的话，那些头部物品就很可能出现在每个用户的推荐结果中。因此在计算时增加了一个偏置项beta_j来对热门物品进行降权。最终对于给定的用户u和之前的行为物品i可以由以下的计算公式为其推荐物品j。 物品j的热度越高，则beta_j越小，这样当两个物品计算出来的距离一致时，倾向于推荐那些热度小的物品，这样也能够在一定程度上提高推荐物品的多样性。 ***这里有一点需要注意的是：为了避免“维度诅咒”问题，将r_j限定在整个翻译空间的一个子集上，例如一个单位球体的空间范围。*** 对于给定过的用户和历史行为序列，模型的目标是对集合中的物品进行排序，这里采用的是pairwise方法的S-BPR（Sequential Bayesian Personalized Ranking）。其优化的公式如下： 其中j是真实的下一个交互的物品，j'是除j之外的集合中的任意一个物品。omega为L2正则项。 ## 参数学习 物品i和用户对应的全局翻译向量随机初始化为单元向量，每个物品的偏置向量和每个用户的翻译向量初始化为0。 目标函数通过随机梯度上升进行优化，随机从集合中抽取用户u，正例j和负例j'，通过下面的计算公式进行迭代： 其中ε为学习率，λ为正则项参数。重复该公式，直到收敛或者效果达到最优或者达到最大迭代次数。 ## 最近邻查找 在测试时，可以通过最近邻搜索进行推荐，一个小的挑战就是物品的偏差。这里分为两部分去解决这个问题。 第一使用： $$\\beta _j ' \\leftarrow \\beta _j - max_{k\\in I}\\beta _k$$ 表示$\\beta _j$ 对偏置项进行转换，不会改变计算结果的排序。 第二使用L2范数计算 $$\\overrightarrow{\\gamma _j}' = (\\overrightarrow{\\gamma _j}';\\sqrt{-\\beta _j'})$$ 或者使用L1范数计算 $$\\overrightarrow{\\gamma _j}' = (\\overrightarrow{\\gamma _j}';-\\beta _j')$$ 实验证明L2范数效果更好。对于给定的用户u和物品i，在整个向量空间内为其计算寻找最近的$\\overrightarrow{\\gamma _j}'$ --- # 实验 为了充分验证TransRec的优势，使用了大量的公开数据集，如下图所示： 在算法选择上以PopRec为baseline，BPR-MF，FMC，FPMC，PRME，HRM作为对比算法模型，在上表中的数据集上对比实验如下： 在进行实验寻找最佳参数时，使用的是网格搜索法，使用随机提督上升优化模型的学习率为0.05，正则项参数的测试范围是：{0, 0.001, 0.01, 0.1, 1}。在TransRec中尝试了L2-ball 和 L2-sphere计算距离，L2-ball的效果更好一些。 在最开始我们提到本论文主要有两点用户的序列推荐（用户在浏览了一些items之后给他推荐物品j）物品到物品的推荐（用户购买了一个牛仔裤，给他推荐一个衬衫） 在TransRec中，通过删除个性化向量部分，TransRec可以直接进行物品到物品的推荐，这和知识图谱中的推荐有点相似，因为需要对不同项之间的关系进行建模。其中实现的结果类似于下图这样。 同样也对该部分进行了单独的实验，采用的数据集，对比的算法和实验的结论如下： 我的总结 文章中介绍了TransRec的优势（1）只用一个模型来模拟用户，物品之间的三阶交互（2）可以从隐式假设度量中获益（3）轻易的解决数据量大的问题 论文中不仅提出了使用一个模型来对用户物品之间的三阶关系进行建模，还借鉴知识图谱中的思想提出了物品道物品之间的推荐。 文中实验时将数据集拆分成了三部分，训练集，验证集，和测试集。其比例为8:1:1。 数据集拆分时避免了从整体数据集中的随机拆分，而是按照时间先后的顺序进行拆分。保证了一定的时间连续性，这一点值得借鉴。 在寻找最佳参数时使用的是网格搜索法。 用户的翻译向量采用了全局翻译向量和个性化的翻译向量之和。一定程度上解决了用户的冷启动。 样本偏置项，减小物品本身热度对模型的影响。 为了避免“维度诅咒”问题，将样本限定在整体样本空间的一个子集上。 基于TransRec的思路，作者又提出了和FM的结合，其论文是Translation-based Factorization Machines for Sequential Recommendation，接下来会对其进行介绍。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"论文","slug":"论文","permalink":"http://thinkgamer.cn/tags/论文/"},{"name":"TransRec","slug":"TransRec","permalink":"http://thinkgamer.cn/tags/TransRec/"}]},{"title":"Spark排序算法系列之ALS模型实现","slug":"RecSys/Spark排序算法/Spark排序算法系列之ALS模型实现","date":"2019-08-13T06:27:45.000Z","updated":"2019-10-14T06:42:35.663Z","comments":true,"path":"2019/08/13/RecSys/Spark排序算法/Spark排序算法系列之ALS模型实现/","link":"","permalink":"http://thinkgamer.cn/2019/08/13/RecSys/Spark排序算法/Spark排序算法系列之ALS模型实现/","excerpt":"在上一篇文章中介绍了ALS算法的原理（点击阅读），在这篇文章中主要介绍一下ALS算法在Spark中的实现。","text":"在上一篇文章中介绍了ALS算法的原理（点击阅读），在这篇文章中主要介绍一下ALS算法在Spark中的实现。 概述协同过滤(Collaborative Filtering)在推荐系统中应用的非常广，该算法的目标是去填充用户-物品评分矩阵中的缺失值，即未评分。该算法的Spark的ML包和MLlib包中均有实现。 其中涉及的参数如下： numBlocks：数据分区的数目，默认为10 rank：隐向量的长度，默认是10（m n =&gt; m k - k * n） maxIter：最大迭代次数，默认为10 regParam：正则化参数系数，默认为1.0 implicitPrefs：控制使用显式反馈还是隐式反馈，默认是false即显式反馈。 alpha：隐式反馈时的置信度参数，默认为1.0 nonnegative：是否对最小二乘使用非负约束，默认为false 隐式反馈与显式反馈基于矩阵分解的协同过滤标准方法将用户-物品矩阵中的rate视为用户对项目给出的显式偏好，例如：用户对电影进行评分。 在许多实际的用例中，通常只能获取隐式反馈数据（例如：观看，点击，购买，喜欢，分享等）。spark.ml中用于处理此类数据的方法取自Collaborative Filtering for Implicit Feedback Datasets。本质上，这种方法不是试图直接对评级矩阵进行建模，而是将数据视为表示用户操作观察强度的数字（例如点击次数或某人花在观看电影上的累积持续时间）。然后，这些数字与观察到的用户偏好的置信水平相关，而不是与项目的明确评级相关。然后，该模型试图找到可用于预测用户对项目的预期偏好的潜在因素。 正则化参数通过用户-物品的评分矩阵中用户的评分物品数和物品收到的评分个数来作为正则项，解决最小二乘更新过程中的问题。 这种方法被命名为“ALS-WR”，可以参考论文： Collaborative Filtering for Implicit Feedback Datasets。它减小来regParam对数据集规模的依赖，因此我们可以将从采样子集中学习的最佳参数应用于完整数据集，并获得较好的结果。 应用场景Spark ALS算法支持输出item 或者user的隐向量，据此我们可以计算出用户或者物品的相似度，继而进行排序得到用户或者item的top N相似user或者item。这样在数据进行召回时便可以进行召回了。 比如根据用户用行为的物品召回，当用户浏览了若干了item时，便将这些item相似的item加入到召回池中，进行rank排序。 ML中的ALS实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354object ALSML &#123; def main(args: Array[String]): Unit = &#123; val spark = SparkSession.builder().master(\"local[5]\").appName(\"ALSML\").enableHiveSupport().getOrCreate() Logger.getRootLogger.setLevel(Level.WARN) val input = \"data/sample_movielens_ratings.txt\" val model_param = \"maxIters:10,rank:5,numBlocks:10,regParam:0.01,alpha:0.618,userCol:userId,itemCol:movieId,rateCol:rating,implicitPrefs:true\" val output_model = \"model/als_ml\" // 训练模型 找到合适的参数 runBasedML(spark,input,model_param,output_model) &#125; def runBasedML(spark: SparkSession, input: String, param: String,output_model_path: String) = &#123; import spark.sqlContext.implicits._ val ratings = spark.read.textFile(input).map(parseRating).toDF() val Array(training, test) = ratings.randomSplit(Array(0.8, 0.2)) println(\"创建并训练ALS模型 ...\") val als = ALSMLUtil.createModel(param) val model = als.fit(training) println(\"模型的效果评估 ...\") ALSMLUtil.evaluateModel(model, test) println(\"为用户进行item推荐 ...\") model.recommendForAllUsers(10).show(10) println(\"为指定用户进行top N item推荐 ...\") val users = ratings.select(als.getUserCol).distinct().limit(3) model.recommendForUserSubset(users,10).show(10) println(\"为item进行用户推荐 ...\") model.recommendForAllItems(10).show(10) println(\"为指定的item进行top N 用户推荐 ...\") val movies = ratings.select(als.getItemCol).distinct().limit(3) model.recommendForItemSubset(movies, 10).show(10) println(\"输出隐向量 ...\") model.itemFactors.rdd.map(f =&gt; (f.get(0), f.getList(1).toArray.mkString(\",\"))).take(10).foreach(println) println(\"保存与加载模型 ...\") model.write.overwrite().save(output_model_path) val newModel = ALSModel.load(output_model_path) newModel.itemFactors.rdd.map(f =&gt; (f.get(0), f.getList(1).toArray.mkString(\",\"))).take(10).foreach(println) &#125; def parseRating(str: String): Rating = &#123; val fields = str.split(\"::\") assert(fields.size == 4) Rating(fields(0).toInt, fields(1).toInt, fields(2).toFloat, fields(3).toLong) &#125; case class Rating(userId: Int, movieId: Int, rating: Float, timestamp: Long)&#125; MLlib中的ALS实现123456789101112131415161718192021222324252627282930313233343536373839404142object ALSMLlib &#123; def main(args: Array[String]): Unit = &#123; val spark = SparkSession.builder().master(\"local[5]\").appName(\"ALS\").enableHiveSupport().getOrCreate() Logger.getRootLogger.setLevel(Level.WARN) val input = \"data/sample_movielens_ratings.txt\" val model_param = \"maxIters:10,rank:5,numBlocks:10,regParam:0.01,alpha:0.618,implicitPrefs:true\" val output_model_path = \"model/als_ml\" run(spark, input, model_param, output_model_path) &#125; def run(spark: SparkSession, input: String, model_param: String, output_model_path: String): Unit = &#123; println(\"加载数据 ...\") val ratings = spark.sparkContext.textFile(input) .map(_.split(\"::\").slice(0,3) match &#123; case Array(userId, movieId, rating) =&gt; Rating(userId.toString.toInt, movieId.toString.toInt, rating.toString.toDouble) &#125;) println(\"训练模型 ...\") val param = new ALSMLlibParam() param.parseString(model_param) val model = ALS.train(ratings,param.getRank, param.getMaxIters,param.getAlpha,param.getNumBlocks) println(\"评估模型 ...\") val usersProducts = ratings.map &#123; case Rating(user, product, rate) =&gt; (user, product) &#125; val predictions = model.predict(usersProducts).map&#123; case Rating(user, product, rate) =&gt; ((user,product),rate)&#125; val rateAndPre = ratings.map &#123; case Rating(user, product, rate) =&gt; ((user, product), rate) &#125;.join(predictions) val MSE = rateAndPre.map &#123; case ((user, product), (r1, r2)) =&gt; val err = (r1 - r2) err * err &#125;.mean() println(\"Mean Squared Error = \" + MSE) println(s\"用户（2）对 物品（2）的预测评分为：$&#123;model.predict(2,2)&#125;\") println(\"用户纬度的特征向量为：\") model.userFeatures.map(f =&gt; (f._1,f._2.mkString(\",\"))).take(10).foreach(println) println(\"物品纬度的特征向量为：\") model.productFeatures.map(f =&gt; (f._1,f._2.mkString(\",\"))).take(10).foreach(println) &#125;&#125; 问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.onReceive(DAGScheduler.scala:1821) at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.onReceive(DAGScheduler.scala:1810) at org.apache.spark.util.EventLoop$$anon$1.run(EventLoop.scala:48) at org.apache.spark.scheduler.DAGScheduler.runJob(DAGScheduler.scala:642) at org.apache.spark.SparkContext.runJob(SparkContext.scala:2034) at org.apache.spark.SparkContext.runJob(SparkContext.scala:2055) at org.apache.spark.SparkContext.runJob(SparkContext.scala:2074) at org.apache.spark.rdd.RDD$$anonfun$take$1.apply(RDD.scala:1364) at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151) at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112) at org.apache.spark.rdd.RDD.withScope(RDD.scala:363) at org.apache.spark.rdd.RDD.take(RDD.scala:1337) at com.kk.recommend.tools.model.ALSBasedMLUtil$.evaluateModel(ALSBasedMLUtil.scala:51) at com.kk.recommend.topic.follow.ItemCFV2$.testBasedML(ItemCFV2.scala:104) at com.kk.recommend.topic.follow.ItemCFV2$.main(ItemCFV2.scala:40) at com.kk.recommend.topic.follow.ItemCFV2.main(ItemCFV2.scala) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.spark.deploy.yarn.ApplicationMaster$$anon$2.run(ApplicationMaster.scala:688)Caused by: java.lang.ArrayStoreException: org.apache.spark.sql.catalyst.expressions.GenericRowWithSchema at scala.runtime.ScalaRunTime$.array_update(ScalaRunTime.scala:90) at scala.collection.IndexedSeqOptimized$class.copyToArray(IndexedSeqOptimized.scala:180) at scala.collection.mutable.WrappedArray.copyToArray(WrappedArray.scala:35) at scala.collection.TraversableOnce$class.copyToArray(TraversableOnce.scala:278) at scala.collection.AbstractTraversable.copyToArray(Traversable.scala:104) at scala.collection.TraversableOnce$class.toArray(TraversableOnce.scala:286) at scala.collection.mutable.WrappedArray.toArray(WrappedArray.scala:73) at com.kk.recommend.tools.model.ALSBasedMLUtil$$anonfun$2.apply(ALSBasedMLUtil.scala:48) at com.kk.recommend.tools.model.ALSBasedMLUtil$$anonfun$2.apply(ALSBasedMLUtil.scala:46) at scala.collection.Iterator$$anon$12.nextCur(Iterator.scala:434) at scala.collection.Iterator$$anon$12.hasNext(Iterator.scala:440) at scala.collection.Iterator$$anon$10.hasNext(Iterator.scala:389) at scala.collection.Iterator$class.foreach(Iterator.scala:893) at scala.collection.AbstractIterator.foreach(Iterator.scala:1336) at scala.collection.generic.Growable$class.$plus$plus$eq(Growable.scala:59) at scala.collection.mutable.ArrayBuffer.$plus$plus$eq(ArrayBuffer.scala:104) at scala.collection.mutable.ArrayBuffer.$plus$plus$eq(ArrayBuffer.scala:48) at scala.collection.TraversableOnce$class.to(TraversableOnce.scala:310) at scala.collection.AbstractIterator.to(Iterator.scala:1336) at scala.collection.TraversableOnce$class.toBuffer(TraversableOnce.scala:302) at scala.collection.AbstractIterator.toBuffer(Iterator.scala:1336) at scala.collection.TraversableOnce$class.toArray(TraversableOnce.scala:289) at scala.collection.AbstractIterator.toArray(Iterator.scala:1336) at org.apache.spark.rdd.RDD$$anonfun$take$1$$anonfun$28.apply(RDD.scala:1364) at org.apache.spark.rdd.RDD$$anonfun$take$1$$anonfun$28.apply(RDD.scala:1364) at org.apache.spark.SparkContext$$anonfun$runJob$5.apply(SparkContext.scala:2074) at org.apache.spark.SparkContext$$anonfun$runJob$5.apply(SparkContext.scala:2074) at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:87) at org.apache.spark.scheduler.Task.run(Task.scala:109) at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:381) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 结局办法： 解决办法：点击阅读 打印的Schema信息：123456root |-- userId: integer (nullable = false) |-- recommendations: array (nullable = true) | |-- element: struct (containsNull = true) | | |-- topicId: integer (nullable = true) | | |-- rating: float (nullable = true) 在row 中的这些列取得时候，要根据类型取，简单的像String，Seq[Double] 这种类型就可以直接取出来，但是像 Seq[(Double,Double)] 这种类型直接取得花就会丢失schema信息，虽然值能取到，但是schema信息丢了，在dataFrame中操作的时候就会抛错 ALS测试结果数据的格式如下： userId recommendations 148 [[1972, 0.0334868… 原始的写法是： 1234567result.select(\"userId\", \"recommendations\") .filter(row =&gt; !(row.isNullAt(0) || row.isNullAt(1))) .rdd.flatMap( l=&gt;&#123; val uid = l.get(0).toString val itemList = l.getAs[mutable.WrappedArray[(Int,Double)]](\"recommendations\") for(item&lt;- itemList) yield (uid, item._1.toString) &#125;) 修改后为：1234567result.select(\"userId\", \"recommendations\") .filter(row =&gt; !(row.isNullAt(0) || row.isNullAt(1))) .rdd.flatMap( l=&gt;&#123; val uid = l.get(0).toString val itemList= l.getAs[Seq[Row]](1).map(x=&gt;&#123;(x.getInt(0),x.getFloat(1))&#125;) for(item&lt;- itemList) yield (uid, item._1.toString) &#125;) 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"},{"name":"CTR","slug":"CTR","permalink":"http://thinkgamer.cn/tags/CTR/"}]},{"title":"基于协同的ALS算法原理介绍与实现","slug":"RecSys/推荐算法/基于协同的ALS算法原理介绍与实现","date":"2019-08-08T15:41:20.000Z","updated":"2019-10-14T06:42:35.664Z","comments":true,"path":"2019/08/08/RecSys/推荐算法/基于协同的ALS算法原理介绍与实现/","link":"","permalink":"http://thinkgamer.cn/2019/08/08/RecSys/推荐算法/基于协同的ALS算法原理介绍与实现/","excerpt":"ALS也是一种协同算法，其全称是交替最小二乘法（Alternating Least Squares），由于简单高效，已被广泛应用在推荐场景中，目前已经被集成到Spark MLlib和ML库中，在下一篇文章会对其使用方式进行详细介绍，本篇文章主要介绍ALS的底层算法原理。","text":"ALS也是一种协同算法，其全称是交替最小二乘法（Alternating Least Squares），由于简单高效，已被广泛应用在推荐场景中，目前已经被集成到Spark MLlib和ML库中，在下一篇文章会对其使用方式进行详细介绍，本篇文章主要介绍ALS的底层算法原理。 最小二乘法（Least Squares）在介绍ALS算法之前，先来了解LS，即最小二乘法。LS算法是ALS的基础，是一种数学优化技术，也是一种常用的机器学习算法，他通过最小化误差平方和寻找数据的最佳匹配，利用最小二乘法寻找最优的未知数据，保证求的数据与已知的数据误差最小。 LS也被用于拟合曲线，比如所熟悉的线性模型。下面以简单的线性一元线性回归模型说明最小二乘法。假设我们有一组数据{(x1,y1),(x2,y2),(x3,y3)…}其符合线性回归，假设其符合的函数为如下： y = w_0 + w_1 x我们使用一个平方差函数来表达参数的好坏，平方差函数如下： L_n = (y_n - f(x;w_0,w_1))^2其中f(.) 表示我们假设的线性回归函数。显然Ln越小越好，Ln越小表示误差越小。假设有N个样本，则N个样本的平均平方差为： L = \\frac{1}{N} \\sum_{n=1}^{N} (y_n - f(x;w_0,w_1))^2L越小表示参数w越精确，而这里最关键的就是寻找到最合适的w0和w1，则此时的数学表达式为： \\underset{w_0,w_1}{arg \\ min} \\frac{1}{N} \\sum_{n=1}^{N} (y_n - f(x;w_0,w_1))^2将先行回归函数代入到最小二乘损失函数中，得到的结果为： L = \\frac{1}{N} \\sum_{n=1}^{N} (y_n - w_0 - w_1 x_n)^2 \\\\ \\frac{1}{N} \\sum_{n=1}^{N} (w_1 ^2x_n^2 + 2w_1x_n(w_0 - y_n) + w_0^2 - 2w_0y_n + y_n^2)L函数取得最小值时，w0和w1的一阶偏导数一定是0（因为误差平方和是一个大于等于0的数，是没有最大值的，所以取得最小值时，一阶偏导数一定为0）。因为对L函数分别求偏导，使其等于0，并对w0和w1求解，即可。 交替最小二乘法（Alternating Least Squares）ALS算法本质上是基于物品的协同，近年来，基于模型的推荐算法ALS(交替最小二乘)在Netflix成功应用并取得显著效果提升，ALS使用机器学习算法建立用户和物品间的相互作用模型，进而去预测新项。 基本原理用户对物品的打分行为可以用一个矩阵（R）来表示：矩阵中的打分值 r_ij表示用户 u_i 对物品 v_j 的打分，其中”?”表示用户没有打分，这也就是要通过机器学习的方法去预测这个打分值，从而达到推荐的目的。 模型抽象根绝协同过滤的思想，R矩阵的行向量对应每个用户U，列向量对应每个物品V。ALS的核心思想是：将用户和物品都投射到k维空间，也就是说假设有k个隐向量特征，至于这个k个隐向量是什么不用关系（可能是标签，年龄，性别等），将每个用户和每个物品都用k维的向量来表示，把他们的内积近似为打分值，这样便可以得到近似的评分。 R \\approx UV^T其中： R为打分矩阵（m*n，m表示用户个数，n表示物品个数） U表示用户对隐含特征的偏好矩阵（m*k） V表示物品对隐含特征的归属矩阵（n*K） 上述模型的参数就是U和V，求得U和V之后，就可以近似的得到用户对未评分物品的评分。 代价函数求上述公式中的U和V，就需要一个代价函数来衡量参数的拟合程度。用户对物品的行为分为显式行为和隐式行为，两种不同类型的行为下，对应的代价函数也是不一样的。 关于显式行为和隐式行为的介绍可以餐考 我的《推荐系统开发实战》一书。 显式反馈代价函数如果用户对物品有明确的评分行为，那么可以对比重构出来的评分矩阵和实际的评分矩阵，便可得到误差。由于用户对物品的评分却失很多，仅以有评分行为的物品去计算误差。下面是显式反馈的代价函数。 J(U,V) = \\sum_{i}^{m} \\sum_{j}^{n}[(r_{ij} - u_iv_j^T) ^2 + \\lambda ( ||u_i||^2 + ||v_j||^2 ) ]其中：λ 为正则项系数 隐式反馈代价函数隐式反馈对应的ALS算法即：ALS-WR（Alternating Least Squares With Weighted-λ -regularization） 很多情况下，用户并没有明确反馈对物品的偏好，需要通过用户的相关行为去推测其对物品的偏好，比如在电商网站中，用户是否点击物品，点击的话在一定程度上表示喜欢，未点击的话可能是不喜欢，也可能是没有看到该物品。这种形式下的反馈就被称为隐式反馈。即矩阵R为隐式反馈矩阵，引入变量p_ij表示用户u_i对物品v_j的置信度，如果隐式反馈大于0，置信度为，反之置信度为0。 p_{ij} = \\left\\{\\begin{matrix} 1 & r_{ij} >0 \\\\ 0 & r_{ij} =0 \\end{matrix}\\right.上文也提到了，隐式反馈为0，不代表用户完全不喜欢，也可能是用户没有看到该物品。另外用户点击一个物品，也不代表是喜欢他，可能是误点，所以需要一个信任等级来显示用户喜欢某个物品，一般情况下，r_ij越大(用户行为的次数)，越能暗示用户喜欢某个物品，因此引入变量c_ij，来衡量p_ij的信任度。 c_{ij} = 1 + \\alpha r_{ij}α 为置信度系数，那么代价函数变为如下形式： J(U,V) = \\sum_{i}^{m} \\sum_{j}^{n}[c_{ij}(p_{ij} - u_iv_j^T) ^2 + \\lambda ( ||u_i||^2 + ||v_j||^2 ) ]算法求解无论是隐式代价函数求解还是显式代价函数求解，他们都是凸函数，而且变量耦合在一起，常规的梯度下降算法不能求解。但是先固定U求V，再固定V求U，如此迭代下去，问题就可以解决了。 U^0 \\rightarrow V^1 \\rightarrow U^1 \\rightarrow V^2 \\rightarrow U^2 ....固定一个变量，求另外一个变量，用什么方法求解呢？梯度下降？可以，但是比较麻烦。这其实是一个最小二乘的问题，由于一般隐含的特征k不会太大，可以直接当做是正规方程去解决。如此的交替的使用最小二乘去求解，所以名字就叫做交替最小二乘法。 显氏反馈求解固定V求解U，对公式进行求导化简，可得： U ^T = \\left( V^T V + \\lambda I \\right)^{-1} V^T R^T同理，固定U求解V，对公式进行求导化简，可得： V ^T = \\left( U^T U + \\lambda I \\right)^{-1} U^T R隐式反馈求解固定V求解U，对公式进行求导化简，可得： U ^T = \\left( V^T C_v V + \\lambda I \\right)^{-1} V^T C_v R^T同理，固定U求解V，对公式进行求导化简，可得： V ^T = \\left( U^T C_u U + \\lambda I \\right)^{-1} U^T C_u R 面试点 最小二乘法英文名字是什么？解释及其对应的数学原理 12Least Squares参考上文 ALS全称是什么？为什么叫交替最小二乘法？ 12Alternaing Least Squares参考上文 隐式反馈和显氏反馈的区别？两种形式下ALS的代价函数 12《推荐系统开发实战》中有对其的介绍 两种形式下的代价函数参考上文 代价函数中的正则项及其含义？ 1参考上文 过拟合和欠拟合的含义？在ALS中什么情况会出现过拟合和欠拟合？对应的解决办法？ 123456789欠拟合定义：拟合的函数与训练集误差较大，过拟合定义：拟合的函数与训练集完美匹配（误差很小）合适拟合定义：拟合的函数与训练集误差较小欠拟合出现原因：数据规模太小，特征太多，正则化项系数较小过拟合出现原因：数据特征太少，正则化项系数较大欠拟合解决办法：增大数据规模、减小数据特征数（维数）、增大正则化系数λ过拟合解决办法：增多数据特征数、添加高次多项式特征、减小正则化系数λ Spark实现ALS可调节的参数有哪些？分别表示什么含义？ 123456789maxIters // 最大迭代次数，默认10 rank // 隐向量的长度，默认是10，一般远小于m，nnumBlocks // 数据分区的个数，默认是10regParam // ALS中的正则化参数，默认是1.0alpha // ALS隐氏反馈变量的参数，置信度系数，默认是1.0userCol // 用户列名itemCol // item列名rateCol // 评分列名implicitPrefs // 显氏反馈 还是 隐氏反馈，默认false，意味显氏反馈 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"http://thinkgamer.cn/tags/推荐算法/"},{"name":"ALS","slug":"ALS","permalink":"http://thinkgamer.cn/tags/ALS/"}]},{"title":"【技术分享】2019全球人工智能技术峰会PDF资料拿走不谢","slug":"Share/【技术分享】2019全球人工智能技术峰会PDF资料拿走不谢","date":"2019-08-08T04:58:29.000Z","updated":"2019-10-14T06:42:35.672Z","comments":true,"path":"2019/08/08/Share/【技术分享】2019全球人工智能技术峰会PDF资料拿走不谢/","link":"","permalink":"http://thinkgamer.cn/2019/08/08/Share/【技术分享】2019全球人工智能技术峰会PDF资料拿走不谢/","excerpt":"2019 全球人工智能技术峰会PDF资料免费分享，资料内容涵盖各个方面，全部都是一线互联网公司的产业实践。","text":"2019 全球人工智能技术峰会PDF资料免费分享，资料内容涵盖各个方面，全部都是一线互联网公司的产业实践。 工业实践 「百度」源于产业实践的开源深度学习平台飞浆（PaddlePaddle） 「易观」如何建设大数据中台（从0到1建设大数据中台） 「华为」云边协同，重新定义AI 机器学习 「网易云」AI算法在音乐推荐中的应用 「VIPKID」在线教育行业中视频理解的应用 「美团点评」美团外卖商业变现实践搜索推荐 「荔枝」荔枝UGC推荐探索与实践 「金山」推荐系统在剑网3推栏项目中的落地 知识图谱 「瑞士再保险」知识图谱构建（数据，算法与架构） 「美团点评」基于知识图谱的问答在O2O智能交 互场景中的应用和演进 「中科院」基于知识图谱的问答关键技术—从答案到自然答案 NLP 「阿里巴巴」语音对话机器人在阿里小蜜中的相关技术探索 「追一科技」深度学习在企业智能交互中的应用 「贝壳找房」4D看房：写稿机器人与VR的美丽邂逅 智能安防 「扇贝」A Short Intro: 无处不在的对抗样本攻防 「友邦安达」AI边缘计算的崛起 智能金融 「旷视」旷视AI 在金融风控领域的运用 「MinTech」MinTech的金融科技 实践与探索 「百信银行」机器阅读在智能银行中的应用深度剖析与实践 智慧零售 「WakeData」唤醒沉睡的数据 「MobTech」基于创新算法的半监督的 lookalike效果营销 「京东」新零售时代的智慧中台 智慧城市 「哈罗出行」科技推动出行进化-密密织就的出行智能 智能商业 「苏宁」苏宁物流 智能决策系统建设与应用 「贝锐科技」三生万物理论的实践进化 「科大讯飞」一场客服与AI的融合之旅 IT架构 「威佩网络」人工智能和大数据系统在电子竞技数据处理平台中的应用 「快狗打车」快狗打车智能调度系统架构演进 「国美」国美Redis集群-国美千亿级Redis集群架构变迁的思考 AIOps 「宜信」分布式主动感知在智能运维中的实践 「F5」无探针实时应用大数据采集引擎最佳实践和AIOps实现 「日志易」海量日志分析与智能运维 智能企业赋能 「百度」企业赋能AI 服务生活 DuerOS的技能服务开发 「蘑菇街」基于图像技术构建蘑菇街时尚目的地 「51Talk」人工智能赋能教育-人工智能如何助力K12在线英语 以上资料，私聊微信获取 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》已经在京东上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"http://thinkgamer.cn/tags/技术分享/"}]},{"title":"重庆保时捷女司机揭露了丑恶世道，但终要相信有善有正义有张小敬这样的长安不良帅","slug":"随手记/重庆保时捷女司机揭露了丑恶世道，但终要相信有善有正义有张小敬这样的长安不良帅","date":"2019-08-04T02:52:43.000Z","updated":"2019-10-14T06:42:35.694Z","comments":true,"path":"2019/08/04/随手记/重庆保时捷女司机揭露了丑恶世道，但终要相信有善有正义有张小敬这样的长安不良帅/","link":"","permalink":"http://thinkgamer.cn/2019/08/04/随手记/重庆保时捷女司机揭露了丑恶世道，但终要相信有善有正义有张小敬这样的长安不良帅/","excerpt":"世道很好，只是被藏的很好，只有走在那些青石板上，我才能看到石砖墙瓦的流芳百年 世道很坏，只是很少的存在，只有遇见那些孤立无援，我才能看到人心冷暖的肆无忌惮","text":"世道很好，只是被藏的很好，只有走在那些青石板上，我才能看到石砖墙瓦的流芳百年 世道很坏，只是很少的存在，只有遇见那些孤立无援，我才能看到人心冷暖的肆无忌惮 这是我第一次写对社会事件的看法，当然不是为了蹭热点，而是这件事真的是触动了我。因为最近沉迷于关于西藏的记录片，真心感受到了藏民的质朴无华和亲切友善，然而这个开着保时捷的重庆女司机却再次刷新了我的三观。我以为那些不被人看到的丑恶会被岁月淡化，时光只会记录到存于这世界的美好，然而我失望了… PS：最近看的两部藏区纪录片是《冈仁波齐》《阿拉姜色》 7月30日上午，重庆一位驾驶保时捷的女子在斑马线违章掉头时与另一辆车的男司机发生口角。这件事本身没什么，同样作为一名司机，我觉得双方互相道个歉，然后故事就大结局了！不会像《长安十二时辰》中龙波能不能把花萼楼炸掉那样牵动着我的心，时时不能大结局。 然而，女司机的一巴掌直接把她扇到了微博热搜，扇成了人民茶余饭后的谈资，扇出了她的往往种种违章，扇醒了沉迷于和平安乐的普罗大众，扇惊了她身后的派出所所长丈夫。 再来看下女司机，16年购入保时捷至今，三年中共有29条交通违法记录，违法行为包括闯红灯、乱停车、违反禁止标线、驾驶时拨打接听手持电话等。曾经在郊区无意间闯了一个红灯，被扣了3分+200人民币！说实话对于这钱，这分我挺悔恨的，毕竟我们的驾驶证只有12分，我们也都是平凡人！但是她却不一样，29条违章记录之后依旧在道路上横行霸道？难道人家的本本跟我的不太一样！ 随着事件的发酵，这个江湖人称“月姐”的保时捷女司机被挖出了更多的“不良形象”，头批大波浪，戴白帽，身着喇叭裤，吊带小背心，黑色墨镜，嘴刁中南海，黑道感十足，简直就像黑道中的大嫂。再加上那个标志性的用食指指人的动作，说实话，遇见这种人，我会离她方圆十里开外！ 关于这件事的处理结果还没有公布，不过她的几句霸语倒惊醒了我： “我出了名的飙车！红灯从来都是闯，没人敢把我怎么样。” “我一个电话，所有记录都可以删除。” “信不信，我分分钟找人弄你全家。” ## 世道是怎样的败落，竟没人敢把你怎么样？ “这世间的种种繁荣，都只不过是展现在你眼前的假象”，这句话说的有点过了，但是这世道上的一些黑暗是超乎我们想象的。 某些拿着国家津贴的管员不作为，贪污受贿，包养小三，当被抓时的那种悔恨懊恼是你触碰法律底线最后的救赎吗 某些身穿白大褂原本该济世救人的医生，却也受不了“灰色收入”的诱惑，而丢掉了该有的职业操守 某些卖房时说的比唱的都好听的开发商，在收完定金和首付款之后，迟迟不能交房，最后变成烂尾楼 这种事情在社会上屡见不鲜，但有法律这条约束线，还能起到警戒和惩罚的作用，我们能做的就是不管他人，约束好自己，不触碰法律的底线，要始终相信那些触犯法律的人终会得到制裁！ ## 这世上谁可以命令除他之外的所有人，是大唐时高高在上的圣人吗？ 权利大概是这个世界上最让人崇尚的东西，也是最让人畏惧的东西，没钱的怕有钱的，有钱的怕有权的，有权的天不怕地不怕，就怕权利更大的。 不晓得这女司机是何方神圣，但这种通过“权利”可以办成一些平凡人 办不成的事的现象是显然存在的，这就像一个潜规则，只不过我们都是受害者！ 只要你背靠大树，那你就可以享受枝繁叶茂带来的阴凉。《长安十二时辰》中背靠永王的熊火帮不是烧杀抢掠，无恶不作吗！ 同样的一些其他潜规则，比如，谁有钱有权更霸道，谁就更有理，这是强者的逻辑。 再比如，忍一时风平浪静，退一步海阔天空，这是弱者的借口。 有句话说得好：人善被人欺，马善被人骑，柿子专挑软的捏。 有些人之所以肆无忌惮、横行霸道，就是看准了老实人心地善良，不敢反抗。 ## 你的那句“弄死你全家”让我心有余悸。 生老病死是人之常情，但欲加之罪何患无词。弱者生存的阶级里最害怕的就是强者的践踏。 是你的错，你先动的手，他还了一下，就放话要弄死他全家！说实话真的怕了，能说出这句话的人，肯定处于金字塔的上层，这样她才有这样的底气，如此肆无忌惮。 如今的法制社会，我们应该捍卫的是法律，在遇到事情时，拿起法律的武器来保护自己。而那个女司机则是靠着“法律执行人”的丈夫“弄死你全家”。 想想也挺可笑的，士兵手里的剑是刺杀敌人的，医生手里的刀是济世救人的，官员手里的权利是维护治安的，而你则是来刷新我的三观的！ ## 那个扇了女司机的男司机以后会怎么样？ 在这个世界上，有人打心底里认为，只要有钱，便可以为所欲为，同样因为没钱，这世上的很多弱者在自己受了委屈之后，都会选择默不作声，任人宰割。 即使是事件中的男司机，一时忍无可忍的，动手还击。可事后冷静下来，还是第一时间道歉了事。尽管错不在他，但我们也能体会到他内心的无奈。 弱小的力量怎么能去和金钱，势力抗衡！ 《长安十二时辰》中有这样一个情节交代，永王（右相想要扶持的王子）因为为西域的小勃律使修建一个驿馆，在花萼楼上领功。被太子揭了老底，原来搞的暴力拆迁。而闻染的父亲闻无忌，虽为烽燧堡战役的幸存者，但依旧不能抵抗这场所谓的暴力拆迁，他的协商和争论只是让他白白送了姓名！ 这件事件的男司机代表的不正是我们这些平凡的人，堂堂的七尺男儿，为了妻儿家人，在事发之后也不得不低下头，进行了道歉！ 谁叫对方有钱优有势，而自己却是个普通之人呢！ ## 那个开保时捷的女司机后来怎么样了？ 重庆市公安局已经成立了调查组，彻查相关情况，依法处理，重视群众反应。 政府的态度已经很明显了，但那只是政府的官方态度，具体后事如何，暂时是未知的。不过这让我想起来了最近热播的《长安十二时辰》。 其中发生的事件是：龙波携众人和阙乐霍多，对花萼楼麒麟臂进行偷梁换柱，意图送圣人西去，而“大案牍术”选择的张小敬对其穷追不舍，彻查此案。 事件的起因是：安西铁军第八团在烽燧堡巡查之际，遭遇敌兵，于是死守城墙，但是援军迟迟不来，最后得知援军早已撤离，而援军不至的缘由是当时的兵部尚书林九郎并未下令进行支援，于是敌意升级到了大唐的圣人。 不过圣人在这里是做了个冤大头为什么这么说呢？因为当时的底层官员上报的是大唐边境平静，并无敌军来犯，如果作为林九郎下令增兵烽燧堡，这无疑是在打圣人的脸，是拆穿大唐边境一片平和的谎言。那么圣人必会迁怒于他，他的右相之路恐怕就没那么顺利了吧… 曾经表面“繁荣”的大唐不和现在的我们一样，看似和平安定，岁月静好，实则波涛汹涌，多少不为人知的“黑暗料理”一个个在显露出来，接下来我们就静等重庆女司机的处理结果吧！ 该有的光明会来，因为有张小敬这样的长安不良帅 一个好人，什么时候开始变坏？从他觉得孤立无援的那一刻起； 一个老实人，什么时候开始冷漠，从他看透人心冷暖的那一秒始。 可如果人人都如此，那社会上的好人就越来越少，坏人就越来越多。最后必然陷入整体崩溃中。 所以，不要把这个世界让给那些坏人，也不要让好人在黑暗里孤独的抗争。 十年饮冰难凉热血，面对丑恶，忍耐不是美德，愤怒才是。而愤怒，绝不是一两个人的事情，而是所有有正义感的人共同的事业。 说到底，这世界并不完美，犹如表象繁荣的大唐，但却依旧值得我们去奋斗，就像张小敬一样，不退！！！ 你的善良，你的坚持，终会发光！ --- 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》已经在京东上线，感兴趣的朋友可以进行关注！","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/tags/随手记/"}]},{"title":"基于协同的Slope One算法原理介绍和实现","slug":"RecSys/推荐算法/基于协同的Slope One算法原理介绍和实现","date":"2019-08-02T08:45:53.000Z","updated":"2019-10-14T06:42:35.665Z","comments":true,"path":"2019/08/02/RecSys/推荐算法/基于协同的Slope One算法原理介绍和实现/","link":"","permalink":"http://thinkgamer.cn/2019/08/02/RecSys/推荐算法/基于协同的Slope One算法原理介绍和实现/","excerpt":"该篇文章主要介绍Slope One算法。Slope One 算法是由 Daniel Lemire 教授在 2005 年提出的一个 Item-Based 的协同过滤推荐算法。和其它类似算法相比, 它的最大优点在于算法很简单, 易于实现, 执行效率高, 同时推荐的准确性相对较高。","text":"该篇文章主要介绍Slope One算法。Slope One 算法是由 Daniel Lemire 教授在 2005 年提出的一个 Item-Based 的协同过滤推荐算法。和其它类似算法相比, 它的最大优点在于算法很简单, 易于实现, 执行效率高, 同时推荐的准确性相对较高。 协同过滤算法理解和Python实现 基于标签的推荐算法 基于图的推荐算法 经典的ItemCF的问题经典的基于物品推荐，相似度矩阵计算无法实时更新，整个过程都是离线计算的，而且还有另一个问题，相似度计算时没有考虑相似度的置信问题。例如，两个物品，他们都被同一个用户喜欢了，且只被这一个用户喜欢了，那么余弦相似度计算的结果是 1，这个 1 在最后汇总计算推荐分数时，对结果的影响却最大。 Slope One 算法针对这些问题有很好的改进。不过 Slope One 算法专门针对评分矩阵，不适用于行为矩阵。 Slope One算法过程Slope One 算法是基于不同物品之间的评分差的线性算法，预测用户对物品评分的个性化算法。 Slope算法主要分为3步 计算物品之间的评分差的均值，记为物品间的评分偏差 (两物品同时被评分) R(i,j) = \\frac{ \\sum_{ u \\in N(i)\\bigcap N(j) } (r_{ui} - r_{uj}) }{ | N(i) \\bigcap N(j) | } ( r_ui - r_uj ) 表示评分的差,这里需要注意的是j相对i的评分偏差是 r_ui - r_uj ，如果是i相对j的评分偏差则是 r_uj - r _ui,两 者是互为相反数的关系。 其中： r_ui ：用户u对物品i的评分 r_uj ：用户u对物品j的评分 N(i) ：物品i评过分的用户 N(j) ：物品j评过分的用户 N(i) 交 N(j) ：表示同时对物品i 和物品j评过分的用户数。 根据物品间的评分偏差和用户的历史评分，预测用户对未评分的物品的评分。 p_{uj} = \\frac{ \\sum_{i \\in N(u)} |N(i) \\bigcap N(j) |(r_{ui} - R(i,j)) }{ \\sum_{i \\in N(u)}|N(i) \\bigcap N(j)| }其中： N(u) ：用户u评过分的物品 将预测评分进行排序，取Top N对应的物品推荐给用户 实例说明例如现在有一份评分数据，表示用户对电影的评分： - a b c d e U1 2 3 3 4 U2 4 2 3 3 U3 4 2 3 2 U4 3 5 4 3 现在我们来预测预测每个用户对未评分电影的评分。 Step1: 计算物品之间的评分偏差，以U1为例： R(a,b) = \\frac{ (2-3) + (4-2) }{ 2 } = 0.5 R(a,c) = \\frac{ (2-3) + (4-3) +(3-5) }{ 3 } = -0.67 R(a,d) = \\frac{ (2-4) + (3-4) }{ 2 } = -1.5 R(a,e) = \\frac{ (4-2) + (3-3) }{ 2 } = 1同理可以计算出电影b，c，d，e与其他电影的评分偏差。 Step2: 计算用户对未评分物品的可能评分（为了方便计算，这里以U2为例） 由上表可知，用户U2 对电影a没有评分，这里计算用户U2对电影a的评分。 p_{u_2,a} = \\frac{2 * (4-0.5) +3 * (2-(-0.67)) + 2 * (3-(-1.5) ) + 2 * (3-1)) }{ 2+3+2+2} = 3.11Step3: 评分排序 由于给定样例中，U2只对a没有评过分，所以这里不需要进行排序，正常的话，按分数进行倒排就行。 代码实现这里采用Python实现，在实现过程中并没有考虑算法的复杂度问题。 加载数据123456789101112131415def loadData(self): user_rate = &#123; \"U1\": &#123;\"a\": 2, \"b\": 3, \"c\": 3, \"d\": 4&#125;, \"U2\": &#123;\"b\": 4, \"c\": 2, \"d\": 3, \"e\": 3&#125;, \"U3\": &#123;\"a\": 4, \"b\": 2, \"c\": 3, \"e\": 2&#125;, \"U4\": &#123;\"a\": 3, \"c\": 5, \"d\": 4, \"e\": 3&#125; &#125; item_rate = &#123; \"a\": &#123;\"U1\": 2, \"U3\": 4, \"U4\": 3&#125;, \"b\": &#123;\"U1\": 3, \"U2\": 4, \"U3\": 2&#125;, \"c\": &#123;\"U1\": 3, \"U2\": 2, \"U3\": 3, \"U4\": 5&#125;, \"d\": &#123;\"U1\": 4, \"U2\": 3, \"U4\": 4&#125;, \"e\": &#123;\"U2\": 3, \"U3\": 2, \"U4\": 3&#125; &#125; return user_rate,item_rate 计算物品之间的评分偏差12345678910111213141516def cal_item_avg_diff(self): avgs_dict = &#123;&#125; for item1 in self.item_rate.keys(): for item2 in self.item_rate.keys(): avg = 0.0 user_count = 0 if item1 != item2: for user in self.user_rate.keys(): user_rate = self.user_rate[user] if item1 in user_rate.keys() and item2 in user_rate.keys(): user_count += 1 avg += user_rate[item1] - user_rate[item2] avg = avg / user_count avgs_dict.setdefault(item1,&#123;&#125;) avgs_dict[item1][item2] = avg return avgs_dict 计算预估评分123456789101112131415def item_both_rate_user(self, item1, item2): count = 0 for user in self.user_rate.keys(): if item1 in self.user_rate[user].keys() and item2 in self.user_rate[user].keys(): count += 1 return countdef predict(self, user, item, avgs_dict): total = 0.0 # 分子 count = 0 # 分母 for item1 in self.user_rate[user].keys(): num = self.item_both_rate_user(item, item1) count += num total += num * (self.user_rate[user][item1] - avgs_dict[item][item1]) return total/count 主函数调用12345if __name__ == \"__main__\": slope = SlopeOne() avgs_dict = slope.cal_item_avg_diff() result = slope.predict(\"U2\", \"a\", avgs_dict) print(\"U2 对 a的预测评分为: %s\" % result) 打印结果为：1U2 对 a的预测评分为: 3.111111111111111 和上边我们计算的结果一致。 完整代码在：https://github.com/Thinkgamer/Machine-Learning-With-Python/tree/master/Recommend Slope One的应用场景该算法适用于物品更新不频繁，数量相对较稳定并且物品数目明显小于用户数的场景。比较依赖用户的用户行为日志和物品偏好的相关内容。 其优点： 算法简单，易于实现，执行效率高； 可以发现用户潜在的兴趣爱好； 其缺点： 依赖用户行为，存在冷启动问题和稀疏性问题。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》已经在京东上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"http://thinkgamer.cn/tags/推荐算法/"},{"name":"Slope One","slug":"Slope-One","permalink":"http://thinkgamer.cn/tags/Slope-One/"}]},{"title":"【技术分享】你想知道的网易云音乐推荐架构解析，都在这里！","slug":"Share/【技术分享】你想知道的网易云音乐推荐架构解析，都在这里！","date":"2019-07-31T17:17:24.000Z","updated":"2019-10-14T06:42:35.672Z","comments":true,"path":"2019/08/01/Share/【技术分享】你想知道的网易云音乐推荐架构解析，都在这里！/","link":"","permalink":"http://thinkgamer.cn/2019/08/01/Share/【技术分享】你想知道的网易云音乐推荐架构解析，都在这里！/","excerpt":"本文选自网易云音乐推荐算法负责人-肖强前辈在全球人工智能峰会上的分享，主要介绍了三方面：关于网易云音乐，AI算法在音乐推荐中的应用和AI场景下的音乐思考。这里拿来分享给大家，并加上自己的理解，希望对大家有所帮助。","text":"本文选自网易云音乐推荐算法负责人-肖强前辈在全球人工智能峰会上的分享，主要介绍了三方面：关于网易云音乐，AI算法在音乐推荐中的应用和AI场景下的音乐思考。这里拿来分享给大家，并加上自己的理解，希望对大家有所帮助。 首先说明我是网易云音乐的深度用户，目前级别LV9，每天都会去听日推。喜欢网易云音乐的原因不仅是友好的用户交互设计，而且还是因为在网易云音乐中能看到一个个陌生的故事。虽不知这些故事是真是假，但总会找到一些共鸣，在这里像是一个心灵的寄托一样。我相信大多数人和我一样，喜欢在敲代码的时候戴上耳机，来一个燥一点的音乐，所有的事情与我无关，我只想专心写代码，哈哈，开篇小小的题外话，下面进入正题。 关于本文的PDF，可关注公号 合作=&gt;私信 获取小编微信，私聊获取！ 本文将从三个方面介绍AI算法在网易云音乐推荐中的应用： 关于网易云音乐 AI算法在音乐推荐中的应用 音乐场景下的AI思考 关于网易云音乐 关于网易云音乐的介绍就不用多说了，相信大家都知道这个产品。但是这个产品里边也有很多其他的业务，如下这些。当然推荐也会在各个业务线进行应用，最大化的提高用户体验。 AI算法在音乐推荐中的应用 除了上图中介绍的三个场景以外，推荐在云音乐还有其他很多的应用，比如推荐的MV/视频，推荐的电台，推荐的Look直播等。 几乎所有的推荐系统或者业务系统的分析和底层数据支持都离不开用户的行为日志，在对基础的日志进行ETL处理之后，进行数仓的存储，画像模型，特征工程等均基于这个日志来进行构建。 在此之上这是推荐系统的召回模块，然后进行粗排，精排和展示。这是所有推荐系统的通用架构，然后各个公司，各个部门会在此基础上进行适合各自业务的开发和精细化应用，以适应具体的需求，继而最大化的发挥推荐系统的价值。 不同的业务场景下，推荐的侧重点和实现方法是不一样的。音乐推荐，视频推荐，商品推荐，新闻推荐等，这些各自有各自的特点，音乐本身的复杂性，就要要求系统能够更好的理解音乐，网易云音乐则主要从NLP和视频，图像层面去理解音乐。 传统的CF算法应用的是余弦相似度或者Jaccard距离进行计算，云音乐这里则对其相似度计算方法进行了优化，其计算公式如上图所示，与传统相比，效果提升显著。PS：CF即协同过滤，虽然传统，但是在推荐中扮演的角色至关重要。 接下来主要介绍下云音乐中的排序模型，其经历了线性模型，树模型，FTRL，深度学习模型，深度时序模型。PS：不过在这里小编要提醒的，做排序模型要一步一个脚印，一步一步来，我们不可能在建设推荐系统之时，直接上深度学习，因为只有经历过每个阶段的排序模型，我们才能更好的去理解业务，去提升业务。 音乐场景下的AI思考 当某种算法在推荐中发挥的价值很难再进行提升时，我们需要进行的是业务的深层次的思考和对更加有效或者先进的算法进行探索。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编的最新出版的技术图书，已经在京东，当当上线，感兴趣的朋友可以进行购买阅读！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"http://thinkgamer.cn/tags/技术分享/"}]},{"title":"【技术分享】美团外卖的商业变现的技术思考和实践","slug":"Share/【技术分享】美团外卖的商业变现的技术思考和实践","date":"2019-07-31T16:55:31.000Z","updated":"2019-10-14T06:42:35.673Z","comments":true,"path":"2019/08/01/Share/【技术分享】美团外卖的商业变现的技术思考和实践/","link":"","permalink":"http://thinkgamer.cn/2019/08/01/Share/【技术分享】美团外卖的商业变现的技术思考和实践/","excerpt":"本文选自美团-王永康前辈在全球人工智能峰会上的分享，主要介绍了四方面：业务介绍，平台侧收入优化，商家侧转化优化和用户侧体验优化。这里拿来分享给大家，并加上自己的理解，希望对大家有所帮助。","text":"本文选自美团-王永康前辈在全球人工智能峰会上的分享，主要介绍了四方面：业务介绍，平台侧收入优化，商家侧转化优化和用户侧体验优化。这里拿来分享给大家，并加上自己的理解，希望对大家有所帮助。 本文将从四个方面介绍美团外卖商业变现实践： 业务介绍 平台侧：收入优化 商家侧：转化优化 用户侧：体验优化 业务介绍首先介绍了美团外卖的业务情况，其包含了外卖商家360w，用户数3亿+，日活跃骑手数60w，覆盖城市2500+。其次介绍了外卖的业务形态，包含： 展示广告 搜索广告 feed流广告 消息push广告 其广告的转化形式由曝光到点击再到下单，则为一条有效的转化。其中涉及的名次含义为： CPT：Cost Per Time（成本/时间），即按时长计费广告。按时长计费是包时段包位置投放广告的一种形式。 GD：Guarentee Delivery（保证交货），保证递送的广告，即保量广告，按展示量定价。 CPM：Cost Per Mille（成本/千次），千次展示成本，即按展示付费。 CPC：Cost Per Click（每次点击成本），每次点击成本，按点击付费，如关键词广告。 CPA：Cost Per Action（每次行为成本），CPA计价方式是指按广告投放实际效果，即按回应的有效问卷或定单来计费，而不限广告投放量。 另外补充两个名次含义： oCPC：optimization Cost Per Click（每次点击优化成本），目标转化成本，仍按点击付费。 刷次：用户在APP信息流界面，手指每次下滑刷新，叫做一次刷次。 同时介绍了计算广告的核心——最佳匹配。​ 平台侧：收入优化 需要注意的是这里提到了一个使用Side Information框架解决冷启动的方法，感兴趣的读者可以自己研究下什么是side information 这里基于用户的行为序列数据，可以使用wode2vec，LSTM，VGG，Inception进行Embedding序列的生成 商家侧：转化优化 用户侧：体验优化 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编的最新出版的技术图书，已经在京东，当当上线，感兴趣的朋友可以进行购买阅读！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"http://thinkgamer.cn/tags/技术分享/"}]},{"title":"Spark MLlib 之 数据类型与大规模数据集的相似度计算原理探索","slug":"Spark/Spark MLlib 之 数据类型与大规模数据集的相似度计算原理探索","date":"2019-07-29T07:41:15.000Z","updated":"2019-10-14T06:42:35.674Z","comments":true,"path":"2019/07/29/Spark/Spark MLlib 之 数据类型与大规模数据集的相似度计算原理探索/","link":"","permalink":"http://thinkgamer.cn/2019/07/29/Spark/Spark MLlib 之 数据类型与大规模数据集的相似度计算原理探索/","excerpt":"本文出自「xingoo」在原文的基础上加以小编自己的理解形成的学习笔记，希望对读者有帮助。原文出自：Spark MLlib 之 大规模数据集的相似度计算原理探索","text":"本文出自「xingoo」在原文的基础上加以小编自己的理解形成的学习笔记，希望对读者有帮助。原文出自：Spark MLlib 之 大规模数据集的相似度计算原理探索 背景最近小编在做的是计算两两用户的粉丝重合度，根据粉丝重合度去评估两个用户之间的相似度，根据条件进行过滤之后大概有3000个用户，但每个用户的粉丝量参差不齐，有上百万的，有几千的，这样在去构建笛卡尔积的时候，进行粉丝数据关联，得到的用户集就会特别大，spark运行的时候就会很慢，而且会出现很严重的数据倾斜。这个时候了解到了spark支持的数据类型，看到了CoordinateMatrix，然后深究其原理，便看到了这篇文章，经过整理形成了此文。 Spark支持的数据类型官方文档地址：https://spark.apache.org/docs/latest/mllib-data-types.html 1.Local Vector（本地向量）本地向量是从0开始的下标和double类型的数据组成，存储在本地机器上，所以称为Local Vector。它支持两种形式： Dense （密集的向量） Sparse （稀疏的向量） 比如一个向量[1.0,0.0,3.0]，用Dense表示为：[1.0,0.0,3.0]，用Sparse表示为：(3,[0,2],[1.0,3.0])，其中3为向量的长度，[0,2]表示元素[1.0,3.0]的位置，可见sparse形式下0.0是不存储的。 1234567891011121314import org.apache.spark.mllib.linalg.Vectorsval denseVector = Vectors.dense(1.0,0.0,3.0)val sparseVector1 = Vectors.sparse(3,Array(0,2),Array(1.0,3.0))val sparseVector2 = Vectors.sparse(3,Seq((0,1.0),(2,3.0)))println(s\"DenseVector is : $denseVector\")println(s\"DenseVector to Sparse is : $&#123;denseVector.toSparse&#125;\")println(s\"sparseVector1 is : $sparseVector1\")println(s\"sparseVector1 to Dense is : $&#123;sparseVector1.toDense&#125;\")println(s\"sparseVector2 is : $sparseVector2\")println(s\"sparseVector2 to Dense is : $&#123;sparseVector2.toDense&#125;\") 输出为：12345678DenseVector is : [1.0,0.0,3.0]DenseVector to Sparse is : (3,[0,2],[1.0,3.0])sparseVector1 is : (3,[0,2],[1.0,3.0])sparseVector1 to Dense is : [1.0,0.0,3.0]sparseVector2 is : (3,[0,2],[1.0,3.0])sparseVector2 to Dense is : [1.0,0.0,3.0] 2. Labeled point(带标签的点)labeled point由本地向量组成，既可以是dense向量，也可以是sparse向量。在mllib中常用于监督类算法，使用double类型来保存该类型的数据，因为也可以用于回归和分类算法。例如二分类，label可以是0（负例）或1（正例），对于多分类，label可以是0，1，2… 12345import org.apache.spark.mllib.linalg.Vectorsimport org.apache.spark.mllib.regression.LabeledPointval pos = LabeledPoint(1.0, Vectors.dense(1.0,0.0,3.0))val neg = LabeledPoint(0.0, Vectors.sparse(3, Array(0, 2), Array(1.0, 3.0))) sparse data 稀疏数据存储是非常普遍的现象，mllib支持读取libsvm格式的数据，其数据格式如下：1label index1:value1,index2:value2 ... 其读取方式包括：1234567import org.apache.spark.mllib.util.MLUtils// method 1spark.read.format(\"libsvm\") .load(\"libsvm data path\")// method 2MLUtils.loadLibSVMFile(spark.sparkContext, \"libsvm data path\") 3. Local Matrix（本地矩阵）local matrix由行下标，列索引和double类型的值组成，存储在本地机器上，mllib支持密集矩阵和稀疏矩阵，其存储是按照列进行存储的。 例如下面的为密集矩阵: 通过数组存储的形式为： [1.0, 3.0, 5.0, 2.0, 4.0, 6.0]，矩阵大小为[3，2] 1234567// Create a dense matrix ((1.0, 2.0), (3.0, 4.0), (5.0, 6.0))val denseMatrix = Matrices.dense(3,2, Array(1.0,3.0,5.0,2.0,4.0,6.0))println(s\"denseMatrix is : $denseMatrix\")// Create a sparse matrix ((9.0, 0.0), (0.0, 8.0), (0.0, 6.0))val sparseMatrix = Matrices.sparse(3,2, Array(0,1,3),Array(0,2,1),Array(9,6,8))println(s\"sparseMatrix is : $sparseMatrix\") 注：稀疏矩阵解释，首先指定矩阵是3行2列，Array(0, 1, 3)是指，第0个非零元素在第一列，第一第二个非零元素在第二列。 Array(0, 2, 1)是指，第一个非零元素在第0行，第二个非零元素在第2行，第三个非零元素在第1行。 此处设计比较好，假设100个元素分两列，不需要把每个元素所在列都标出来，只需要记录3个数字即可。Array(9, 6, 8)表示按顺序存储非零元素. Array(0,1,3)比较难理解，可以参考以下文章： https://www.cnblogs.com/lyy-blog/p/9288701.html https://www.tuicool.com/articles/A3emmqi 4. Distributed Matrix（分布式矩阵）一个分布式矩阵由下标和double类型的数据组成，不过分布式的矩阵的下标不是int类型，而是long类型，数据保存在一个或多个rdd中，选择一个正确的格式去存储分布式矩阵是非常重要的。分布式矩阵转换成不同的格式需要一个全局的shuffle(global shuffle)，而全局shuffle的代价会非常高。到目前为止，Spark MLlib中已经实现了三种分布式矩阵。 最基本的分布式矩阵是RowMatrix，它是一个行式的分布式矩阵，没有行索引。比如一系列特征向量的集合。RowMatrix由一个RDD代表所有的行，每一行是一个本地向量。假设一个RowMatrix的列数不是特别巨大，那么一个简单的本地向量能够与driver进行联系，并且数据可以在单个节点上保存或使用。IndexedRowMatrix与RowMatrix类似但是有行索引，行索引可以用来区分行并且进行连接等操作。CoordinateMatrix是一个以协同列表（coordinate list)格式存储数据的分布式矩阵，数据以RDD形式存储。 注意：因为我们需要缓存矩阵的大小，所以分布式矩阵的RDDs格式是需要确定的，使用非确定RDDs的话会报错。 Row MatrixRowMatrix它是一个行式的分布式矩阵，没有行索引。比如一系列特征向量的集合。RowMatrix由一个RDD代表所有的行，每一行是一个本地向量。因为每一行代表一个本地向量，所以它的列数被限制在Integer.max的范围内，在实际应用中不会太大。 一个RowMatrix可以由一个RDD[Vector]的实例创建。因此我们可以计算统计信息或者进行分解。QR分解（QR decomposition）是A=QR，其中Q是一个矩阵，R是一个上三角矩阵。对sigular value decomposition(SVD和principal component analysis（PCA）,可以去参考降维的部分。 123456789101112// Row Matrixprintln(\"Row Matrix ...\")val arr = Array(Vectors.dense(1,0),Vectors.dense(0,1))val rows = spark.sparkContext.parallelize(arr)val mat: RowMatrix = new RowMatrix(rows)val m = mat.numRows()val n = mat.numCols()val qrResult = mat.tallSkinnyQR(true)println(s\"m is: $m，n is $n，\\nqrResult is :\")qrResult.Q.rows.foreach(println)println()qrResult.R.rowIter.foreach(println) 输出为：12345678Row Matrix ...m is: 2，n is 2，qrResult is :[1.0,0.0][0.0,1.0][1.0,0.0][0.0,1.0] IndexedRowMatrixIndexedRowMatrix与RowMatrix类似，但是它有行索引。由一个行索引RDD表示，索引每一行由一个long型行索引和一个本地向量组成。 一个IndexedRowMatrix可以由RDD[IndexedRow]的实例来生成，IndexedRow是一个（Long, Vector)的封装。去掉行索引，IndexedRowMatrix能够转换成RowMatrix。 12345678910111213141516// IndexedRowMatrixprintln(\"Indexed Row Matrix ...\")val arr2 = Array( IndexedRow(0,Vectors.dense(1,0)), IndexedRow(1,Vectors.dense(0,1)) )val rows2: RDD[IndexedRow] = spark.sparkContext.parallelize(arr2)val mat2 = new IndexedRowMatrix(rows2)val m2 = mat2.numRows()val n2 = mat2.numCols()// 去掉行索引，转换成RowMatrixval qrResult2 = mat2.toRowMatrix().tallSkinnyQR(true)println(s\"m2 is: $m2，n2 is $n2，\\nqrResult2 is :\")qrResult2.Q.rows.foreach(println)println()qrResult2.R.rowIter.foreach(println) 输出为： 12345678Indexed Row Matrix ...m2 is: 2，n2 is 2，qrResult2 is :[1.0,0.0][0.0,1.0][1.0,0.0][0.0,1.0] CoordinateMatrixCoordinateMatrix是一个分布式矩阵，其实体集合是一个RDD，每一个是一个三元组(i:Long, j:Long, value:Double）。其中i是行索引，j是列索引，value是实体的值。当矩阵的维度很大并且是稀疏矩阵时，才使用CoordinateMatrix。 一个CoordinateMatrix可以通过一个RDD[MatrixEntry]的实例来创建，MatrixEntry是一个(Long, Long, Double)的封装。CoordinateMatrix可以通过调用toIndexedRowMatrix转换成一个IndexedRowMatrix。CoordinateMatrix的其他降维方法暂时还不支持（Spark-1.6.2)。 123456789101112131415// CoordinateMatrixprintln(\"Coordinate Matrix ...\")val arr3 = Array( MatrixEntry(0,0,1), MatrixEntry(1,1,1))val entries = spark.sparkContext.parallelize(arr3)val mat3 = new CoordinateMatrix(entries)val m3 = mat.numRows()val n3 = mat.numCols()val qrResult3 = mat3.toIndexedRowMatrix().toRowMatrix().tallSkinnyQR(true)println(s\"m3 is: $m3，n3 is $n3，\\nqrResult3 is :\")qrResult3.Q.rows.foreach(println)println()qrResult3.R.rowIter.foreach(println) 输出为： 12345678Coordinate Matrix ...m3 is: 2，n3 is 2，rowMat3 is :[1.0,0.0][0.0,1.0][1.0,0.0][0.0,1.0] BlockMatrix一个BlockMatrix是一个分布式的矩阵，由一个MatrixBlocks的RDD组成。MatrixBlock是一个三元组((Int, Int), Matrix),其中(Int, Int)是block的索引，Matrix是一个在指定位置上的维度为rowsPerBlock * colsPerBlock的子矩阵。BlockMatrix支持与另一个BlockMatrix对象的add和multiply操作。BlockMatrix提供了一个帮助方法validate，这个方法可以用于检测该`BlockMatrix·是否正确。 可以通过IndexedRowMatrix或者CoordinateMatrix调用toBlockMatrix快速得到BlockMatrix对象。默认情况下toBlockMatrix方法会得到一个1024 x 1024的BlockMatrix。使用时可以通过手动传递维度值来设置维度，toBlockMatrix(rowsPerBlock, colsPerBlock)。 12345678910111213141516171819// BlockMatrixprintln(\"Block Matrix ...\")val arr4 = Array( MatrixEntry(0,0,1), MatrixEntry(1,1,1))val entries4: RDD[MatrixEntry] = spark.sparkContext.parallelize(arr4)val coordMat: CoordinateMatrix = new CoordinateMatrix(entries4)val matA: BlockMatrix = coordMat.toBlockMatrix().cache()// 检测BlockMatrix格式是否正确，错误的话会抛出异常，正确的话无其他影响matA.validate()matA.blocks.foreach(println)val m4 = matA.numRowBlocksval n4 = matA.numColBlocksprintln(s\"m4 is: $m4，n4 is $n4\")// 计算A^T * A.val ata = matA.transpose.multiply(matA)ata.blocks.foreach(println) 输出为： 1234567Block Matrix ...((0,0),2 x 2 CSCMatrix(0,0) 1.0(1,1) 1.0)m4 is: 1，n4 is 1((0,0),1.0 0.0 0.0 1.0 ) 相似度计算原理探索 无论是ICF基于物品的协同过滤、UCF基于用户的协同过滤、基于内容的推荐，最基本的环节都是计算相似度。如果样本特征维度很高或者的维度很大，都会导致无法直接计算。设想一下100w*100w的二维矩阵，计算相似度怎么算？ 在spark中RowMatrix提供了一种并行计算相似度的思路，下面就来看看其中的奥妙吧！ 相似度计算相似度有很多种，每一种适合的场景都不太一样。比如： 欧氏距离，在几何中最简单的计算方法 夹角余弦，通过方向计算相似度，通常在用户对商品评分、NLP等场景使用 杰卡德距离，在不考虑每一样的具体值时使用 皮尔森系数，与夹角余弦类似，但是可以去中心化。比如评分时，有人倾向于打高分，有人倾向于打低分，他们的最后效果在皮尔森中是一样的 曼哈顿距离，一般在路径规划、地图类中常用，比如A*算法中使用曼哈顿来作为每一步代价值的一部分（F=G+H, G是从当前点移动到下一个点的距离，H是距离目标点的距离，这个H就可以用曼哈顿距离表示） 上面两个向量(x1,y1)和(x2,y2)计算夹角的余弦值就是两个向量方向的相似度，其公式为： cos(\\theta )=\\frac { a\\cdot b }{ ||a||\\ast ||b|| } \\\\ =\\quad \\frac { { x }_{ 1 }\\ast { x }_{ 2 }\\quad +\\quad { y }_{ 1 }\\ast y_{ 2 } }{ \\sqrt { { x }_{ 1 }^{ 2 }+{ y }_{ 1 }^{ 2 } } \\ast \\sqrt { { x }_{ 2 }^{ 2 }+{ y }_{ 2 }^{ 2 } } }其中，||a||表示a的模，即每一项的平方和再开方。 公式拆解那么如果向量不只是两维，而是n维呢？比如有两个向量： 第一个向量：({x}_{1}, {x}_{2}, {x}_{3}, ..., {x}_{n})\\\\ 第二个向量：({y}_{1}, {y}_{2}, {y}_{3}, ..., {y}_{n})他们的相似度计算方法套用上面的公式为： cos(\\theta )\\quad =\\quad \\frac { \\sum _{ i=1 }^{ n }{ ({ x }_{ i }\\ast { y }_{ i }) } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } } \\ast \\sqrt { \\sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } } } } \\\\ =\\quad \\frac { { x }_{ 1 }\\ast { y }_{ 1 }+{ x }_{ 2 }\\ast { y }_{ 2 }+...+{ x }_{ n }\\ast { y }_{ n } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } } \\ast \\sqrt { \\sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } } } } \\\\ =\\quad \\frac { { x }_{ 1 }\\ast { y }_{ 1 } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } } \\ast \\sqrt { \\sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } } } } +\\frac { { x }_{ 2 }\\ast { y }_{ 2 } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } } \\ast \\sqrt { \\sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } } } } +...+\\frac { { x }_{ n }\\ast { y }_{ n } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } } \\ast \\sqrt { \\sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } } } } \\\\ =\\quad \\frac { { x }_{ 1 } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } } } \\ast \\frac { { y }_{ 1 } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } } } } +\\frac { { x }_{ 2 } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } } } \\ast \\frac { { y }_{ 2 } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } } } } +...+\\frac { { x }_{ n } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } } } \\ast \\frac { { y }_{ n } }{ \\sqrt { \\sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } } } }通过上面的公式就可以发现，夹角余弦可以拆解成每一项与另一项对应位置的乘积x1∗y1，再除以每个向量自己的 \\sqrt { \\sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } } }就可以了。 矩阵并行画个图看看，首先创建下面的矩阵： 注意，矩阵里面都是一列代表一个向量….上面是创建矩阵时的三元组，如果在spark中想要创建matrix，可以这样： 123456789101112131415161718val df = spark.createDataFrame(Seq( (0, 0, 1.0), (1, 0, 1.0), (2, 0, 1.0), (3, 0, 1.0), (0, 1, 2.0), (1, 1, 2.0), (2, 1, 1.0), (3, 1, 1.0), (0, 2, 3.0), (1, 2, 3.0), (2, 2, 3.0), (0, 3, 1.0), (1, 3, 1.0), (3, 3, 4.0) ))val matrix = new CoordinateMatrix(df.map(row =&gt; MatrixEntry(row.getAs[Integer](0).toLong, row.getAs[Integer](1).toLong, row.getAs[Double](2))).toJavaRDD) 然后计算每一个向量的normL2，即平方和开根号。 以第一个和第二个向量计算为例，第一个向量为(1,1,1,1)，第二个向量为(2,2,1,1)，每一项除以对应的normL2，得到后面的两个向量： $$ 0.5*0.63+0.5*0.63+0.5*0.31+0.5*0.31 \\approx 0.94 $$ 两个向量最终的相似度为0.94。 那么在Spark如何快速并行处理呢？通过上面的例子，可以看到两个向量的相似度，需要把每一维度乘积后相加，但是一个向量一般都是跨RDD保存的，所以可以先计算所有向量的第一维，得出结果 $$ (向量1的第1维，向量2的第1维，value)\\\\ (向量1的第2维，向量2的第2维，value)\\\\ ...\\\\ (向量1的第n维，向量2的第n维，value)\\\\ (向量1的第1维，向量3的第1维，value)\\\\ ..\\\\ (向量1的第n维，向量3的第n维，value)\\\\ $$ 最后对做一次reduceByKey累加结果即可..... ## 阅读源码 首先创建dataframe形成matrix： 1234567891011121314151617181920212223242526272829303132333435import org.apache.spark.mllib.linalg.distributed.&#123;CoordinateMatrix, MatrixEntry&#125;import org.apache.spark.sql.SparkSessionobject MatrixSimTest &#123; def main(args: Array[String]): Unit = &#123; // 创建dataframe，转换成matrix val spark = SparkSession.builder().master(\"local[*]\").appName(\"sim\").getOrCreate() spark.sparkContext.setLogLevel(\"WARN\") import spark.implicits._ val df = spark.createDataFrame(Seq( (0, 0, 1.0), (1, 0, 1.0), (2, 0, 1.0), (3, 0, 1.0), (0, 1, 2.0), (1, 1, 2.0), (2, 1, 1.0), (3, 1, 1.0), (0, 2, 3.0), (1, 2, 3.0), (2, 2, 3.0), (0, 3, 1.0), (1, 3, 1.0), (3, 3, 4.0) )) val matrix = new CoordinateMatrix(df.map(row =&gt; MatrixEntry(row.getAs[Integer](0).toLong, row.getAs[Integer](1).toLong, row.getAs[Double](2))).toJavaRDD) // 调用sim方法 val x = matrix.toRowMatrix().columnSimilarities() // 得到相似度结果 x.entries.collect().foreach(println) &#125;&#125; 得到的结果为： 123456MatrixEntry(0,3,0.7071067811865476)MatrixEntry(0,2,0.8660254037844386)MatrixEntry(2,3,0.2721655269759087)MatrixEntry(0,1,0.9486832980505139)MatrixEntry(1,2,0.9128709291752768)MatrixEntry(1,3,0.596284793999944) 直接进入columnSimilarities方法看看是怎么个流程吧！ 123def columnSimilarities(): CoordinateMatrix = &#123; columnSimilarities(0.0)&#125; 内部调用了带阈值的相似度方法，这里的阈值是指相似度小于该值时，输出结果时，会自动过滤掉。 1234567891011def columnSimilarities(threshold: Double): CoordinateMatrix = &#123; //检查参数... val gamma = if (threshold &lt; 1e-6) &#123; Double.PositiveInfinity &#125; else &#123; 10 * math.log(numCols()) / threshold &#125; columnSimilaritiesDIMSUM(computeColumnSummaryStatistics().normL2.toArray, gamma)&#125; 这里的gamma用于采样，具体的做法咱们来继续看源码。然后看一下computeColumnSummaryStatistics().normL2.toArray这个方法： 1234567def computeColumnSummaryStatistics(): MultivariateStatisticalSummary = &#123; val summary = rows.treeAggregate(new MultivariateOnlineSummarizer)( (aggregator, data) =&gt; aggregator.add(data), (aggregator1, aggregator2) =&gt; aggregator1.merge(aggregator2)) updateNumRows(summary.count) summary&#125; 之前有介绍这个treeAggregate是一种带“预reduce”的map-reduce，返回的summary，里面帮我们统计了每一个向量的很多指标，比如 123456currMean 为 每一个向量的平均值currM2 为 每个向量的每一维的平方和currL1 为 每个向量的绝对值的和currMax 为 每个向量的最大值currMin 为 每个向量的最小值nnz 为 每个向量的非0个数 这里我们只需要currM2，它是每个向量的平方和。summary调用的normL2方法： 12345678910111213override def normL2: Vector = &#123; require(totalWeightSum &gt; 0, s\"Nothing has been added to this summarizer.\") val realMagnitude = Array.ofDim[Double](n) var i = 0 val len = currM2.length while (i &lt; len) &#123; realMagnitude(i) = math.sqrt(currM2(i)) i += 1 &#125; Vectors.dense(realMagnitude)&#125; 上面这步就是对平方和开个根号，这样就求出来了每个向量的分母部分。 下面就是最关键的地方了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687private[mllib] def columnSimilaritiesDIMSUM( colMags: Array[Double], gamma: Double): CoordinateMatrix = &#123; // 一些参数校验 // 对gamma进行开方 val sg = math.sqrt(gamma) // sqrt(gamma) used many times // 这里把前面算的平方根的值设置一个默认值，因为如果为0，除0会报异常，所以设置为1 val colMagsCorrected = colMags.map(x =&gt; if (x == 0) 1.0 else x) // 把抽样概率数组 和 平方根数组进行广播 val sc = rows.context val pBV = sc.broadcast(colMagsCorrected.map(c =&gt; sg / c)) val qBV = sc.broadcast(colMagsCorrected.map(c =&gt; math.min(sg, c))) // 遍历每一行，计算每个向量该维的乘积，形成三元组 val sims = rows.mapPartitionsWithIndex &#123; (indx, iter) =&gt; val p = pBV.value val q = qBV.value // 获得随机值 val rand = new XORShiftRandom(indx) val scaled = new Array[Double](p.size) iter.flatMap &#123; row =&gt; row match &#123; case SparseVector(size, indices, values) =&gt; // 如果是稀疏向量，遍历向量的每一维，除以平方根 val nnz = indices.size var k = 0 while (k &lt; nnz) &#123; scaled(k) = values(k) / q(indices(k)) k += 1 &#125; // 遍历向量数组，计算每一个数值与其他数值的乘机。 // 比如向量(1, 2, 0 ,1) // 得到的结果为 (0,1,value)(0,3,value)(2,3,value) Iterator.tabulate (nnz) &#123; k =&gt; val buf = new ListBuffer[((Int, Int), Double)]() val i = indices(k) val iVal = scaled(k) // 判断当前列是否符合采样范围，如果小于采样值，就忽略 if (iVal != 0 &amp;&amp; rand.nextDouble() &lt; p(i)) &#123; var l = k + 1 while (l &lt; nnz) &#123; val j = indices(l) val jVal = scaled(l) if (jVal != 0 &amp;&amp; rand.nextDouble() &lt; p(j)) &#123; // 计算每一维与其他维的值 buf += (((i, j), iVal * jVal)) &#125; l += 1 &#125; &#125; buf &#125;.flatten case DenseVector(values) =&gt; // 跟稀疏同理 val n = values.size var i = 0 while (i &lt; n) &#123; scaled(i) = values(i) / q(i) i += 1 &#125; Iterator.tabulate (n) &#123; i =&gt; val buf = new ListBuffer[((Int, Int), Double)]() val iVal = scaled(i) if (iVal != 0 &amp;&amp; rand.nextDouble() &lt; p(i)) &#123; var j = i + 1 while (j &lt; n) &#123; val jVal = scaled(j) if (jVal != 0 &amp;&amp; rand.nextDouble() &lt; p(j)) &#123; buf += (((i, j), iVal * jVal)) &#125; j += 1 &#125; &#125; buf &#125;.flatten &#125; &#125; // 最后再执行一个reduceBykey，累加所有的值，就是i和j的相似度 &#125;.reduceByKey(_ + _).map &#123; case ((i, j), sim) =&gt; MatrixEntry(i.toLong, j.toLong, sim) &#125; new CoordinateMatrix(sims, numCols(), numCols()) &#125; 这样把所有向量的平方和广播后，每一行都可以在不同的节点并行处理了。 总结来说，Spark提供的这个计算相似度的方法有两点优势： - 通过拆解公式，使得每一行独立计算，加快速度 - 提供采样方案，以采样方式抽样固定的特征维度计算相似度 不过杰卡德目前并不能使用这种方法来计算，因为杰卡德中间有一项需要对向量求dot，这种方式就不适合了；如果杰卡德想要快速计算，可以去参考LSH局部敏感哈希算法，这里就不详细说明了。 --- 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编的最新出版的技术图书，已经在京东，当当上线，感兴趣的朋友可以进行购买阅读！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"}]},{"title":"《推荐系统开发实战》之业内推荐系统架构介绍","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之业内推荐系统架构介绍","date":"2019-07-20T00:38:45.000Z","updated":"2019-10-14T06:42:35.667Z","comments":true,"path":"2019/07/20/RecSys/推荐系统开发实战/《推荐系统开发实战》之业内推荐系统架构介绍/","link":"","permalink":"http://thinkgamer.cn/2019/07/20/RecSys/推荐系统开发实战/《推荐系统开发实战》之业内推荐系统架构介绍/","excerpt":"不管是电商网站，还是新闻资讯类网站，推荐系统都扮演着十分重要的角色。一个优秀的推荐系统能够推荐出让人满意的物品，但这不仅是推荐算法的功劳，整个推荐架构所扮演的角色也举足轻重。","text":"不管是电商网站，还是新闻资讯类网站，推荐系统都扮演着十分重要的角色。一个优秀的推荐系统能够推荐出让人满意的物品，但这不仅是推荐算法的功劳，整个推荐架构所扮演的角色也举足轻重。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/96265282博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 学术界往往更加关注推荐算法的各项评估指标。从基本的协同过滤到点击率预估算法，从深度学习到强化学习，学术界都始终走在最前列。一个推荐算法从出现到在业界得到广泛应用是一个长期的过程，因为在实际的生产系统中，首先需要保证的是稳定、实时地向用户提供推荐服务，在这个前提下才能追求推荐系统的效果。 在生产系统中，不管是用户维度、物品维度还是用户和物品的交互维度，数据都是极其丰富的，学术界对算法的使用方法不能照搬到工业界。当一个用户访问推荐模块时，系统不可能针对该用户对所有的物品进行排序，那么推荐系统是怎么解决的呢？对应的商品众多，如何决定将哪些商品展示给用户？对于排序好的商品，如何合理地展示给用户？ 架构介绍图14-1所示是业界推荐系统通用架构图，主要包括：底层基础数据、数据加工存储、召回内容、计算排序、过滤和展示、业务应用。底层基础数据是推荐系统的基石，只有数据量足够多，才能从中挖掘出更多有价值的信息，进而更好地为推荐系统服务。底层基础数据包括用户和物品本身数据、用户行为数据、用户系统上报数据等。 图14-2～图14-4所示为用户本身数据、物品本身数据和用户行为数据。 得到底层基础数据之后，就要对数据进行加工处理和分析了，如结合用户属性信息和行为信息构建用户画像，结合物品属性信息和用户对物品的行为信息构建物品画像。基于用户对物品的行为数据构建特征工程，同时进行相关的数据分析。数据在处理之后存储到相应的位置（业务推荐系统使用的数据一般存储在redis中），供推荐系统实时调用。 召回内容电商网站、内容网站、视频网站中数据量很大，并不能直接把所有的物品数据全部输送到推荐系统进行排序，那么如何对物品进行筛选就成了很关键的问题。第4章中介绍了一些常用的数据挖掘算法和应用场景，在进行物品召回时可以基于一些常用的机器学习算法构建用户偏好模型、用户兴趣模型、物品相似模型、物品互补模型等。在进行内容召回时，只召回和用户有偏好关系、和用户有直接关联、和用户有直接关系的相关物品，输入排序模型，进行打分排序。例如，在某新闻类网站中，根据用户对新闻的相关行为信息构建用户对新闻标签的兴趣模型，在为用户推荐时就可以推荐用户偏好标签下的新闻数据，如图14-5所示。 在物品召回过程中，重点是如何构建合适的用户偏好模型，只有保证偏好模型的准确性才能确保用户召回物品的准确性。 计算排序特征工程“数据决定了机器学习的上限，而算法只是尽可能逼近这个上限”，这里的数据指的就是经过特征工程得到的数据。特征工程指的是把原始数据转变为模型的训练数据的过程，目的就是获取更好的训练数据特征，使得机器学习模型逼近这个上限。特征工程能使模型的性能得到提升，有时甚至在简单的模型上也能取得不错的效果。 特征工程在机器学习中起着非常重要的作用，一般认为包括特征构建、特征提取、特征选择三部分。 特征提取与特征选择都是为了从原始特征中找出最有效的特征。它们之间的区别是： 特征提取强调通过特征转换的方式得到一组具有明显物理意义或统计意义的特征； 特征选择是从特征集合中挑选一组具有明显物理意义或统计意义的特征子集。 两者都能帮助减少特征维度、数据冗余，特征提取有时能发现更有意义的特征属性，特征选择的过程经常能表示出每个特征对于模型构建的重要性。特征工程的标准化流程主要分为以下几步：（1）基于业务理解，找到对因变量有影响的所有自变量，即特征。（2）评估特征的可用性、覆盖率、准确率等。（3）特征处理：包括特征清洗、特征预处理（特征预处理可参考第4章“数据预处理”部分）、特征选择。（4）特征监控：特征对算法模型的影响很大，微小的浮动都会带来模型效果的很大波动，因此做好重要特征的监控可防止特征异常变动带来线上事故。 特征分类在工业界的推荐系统中，典型的特征主要分为以下四类。 相关性特征：评估内容的属性与用户是否匹配。显性的匹配包括关键词匹配、分类匹配、来源匹配、主题匹配等。 环境特征：包括地理位置、时间。这些既是偏差特征，又能以此构建一些匹配特征。 热度特征：包括全局热度、分类热度、主题热度及关键词热度等。内容热度信息在大的推荐系统中特别是在用户冷启动时非常有效。 协同特征：可以在一定程度上帮助解决所谓算法越推越窄的问题。协同特征并不考虑用户已有历史，而是通过用户行为分析不同用户间的相似性，如点击相似、兴趣分类相似、主题相似、兴趣词相似，甚至向量相似，从而扩展模型的探索能力。排序算法在得到召回的物品之后，就要考虑如何对这些物品进行正确的排序。目前业界在机器学习领域最普遍的做法是将排序推荐模型作为二分类模型来训练，即在构造样本集的过程中对应的标签为0或1（未点击或点击）。常用的排序算法包括但不局限于GBDT、LR、XGBoost等，当然也有很多把GBDT和LR结合起来使用的，但是模型融合后的效果在不同的业务场景中带来的提升并不是很大。 物品过滤和展示 过滤和展示直接影响用户体验，因此在做推荐系统时一定要注意相关的过滤和展示规则。 物品过滤经常会听到人们说“电商网站经常给我推荐我已经买过的东西”。其实在做推荐系统的过程中会有相关的过滤规则，在电商推荐系统中，最常用的过滤规则是：用户购买过滤，即在进行商品召回时过滤掉用户过去一段时间内已经购买过的商品和相似商品。例如，用户昨天买了一个机械键盘，今天的推荐系统就不会再给该用户推荐机械键盘了。同时也会有一些其他过滤规则如： 项目指定的一些敏感词汇或敏感商品等过滤。 刷单商品过滤。 曝光商品过滤（有时会认为那些曝光过的商品是用户不感兴趣的，即看到了没有进行点击）。 无货商品过滤。 至于为什么推荐系统会给用户推荐已经购买过的商品，是因为在用户购买该商品之后，又对该类型的商品产生了新的行为，所以推荐系统会再次进行推荐。 物品展示展示即用户看到的推荐结果。不同类型的推荐系统中展示的规则不一样，但基本原则是：品类隔离展示，即同类型的商品不能出现在相邻的位置。例如推荐系统返回的推荐结果集中有两个手机，这两个手机就不能在相邻的位置展示。 有的推荐系统会要求第一屏内不能出现同类型的商品，如推荐系统给用户的第一屏展示了8个商品，那么这8个商品中就不能出现同类型的商品（如不能出现两个手机）。 效果评估无论是推荐架构最开始的召回内容、计算排序，还是最后的过滤和展示，每次新上一个方案之后都要进行效果统计，生产系统中最常用的效果评估方法就是ABTest，更多关于ABTest的使用介绍可以参考第10章。在生产系统中，进行ABtest之后，往往会将不好的方案下线，保留效果更好的一方，同时也会不断上线新的召回、排序特征等，迭代优化模型，提升线上效果。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之三大案例带你从0到1自己实现一个推荐系统","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之三大案例带你从0到1自己实现一个推荐系统","date":"2019-07-20T00:38:08.000Z","updated":"2019-10-14T06:42:35.667Z","comments":true,"path":"2019/07/20/RecSys/推荐系统开发实战/《推荐系统开发实战》之三大案例带你从0到1自己实现一个推荐系统/","link":"","permalink":"http://thinkgamer.cn/2019/07/20/RecSys/推荐系统开发实战/《推荐系统开发实战》之三大案例带你从0到1自己实现一个推荐系统/","excerpt":"俗话说的好：“眼看千遍,不如手写一遍”，前几篇介绍了推荐系统的来源、发展、数据预处理、常见的推荐算法，以及冷启动和推荐系统效果评估。本篇文章将会通过实例介绍推荐系统的完整开发过程，以便大家有更加直观、系统的理解。","text":"俗话说的好：“眼看千遍,不如手写一遍”，前几篇介绍了推荐系统的来源、发展、数据预处理、常见的推荐算法，以及冷启动和推荐系统效果评估。本篇文章将会通过实例介绍推荐系统的完整开发过程，以便大家有更加直观、系统的理解。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/96211201博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 在学习了《推荐系统开发实战》的一些基础知识之后，如何才能将这些知识应用到实际的案例中呢，本文介绍了以下三个案例，来带领大家温习和应用学到的知识。三大案例包含： 新闻推荐系统 音乐推荐系统 图书推荐系统 新闻推荐系统实现的第一个案例是新闻推荐系统，这里使用的数据集为：某新闻网站指定日期前的部分新闻数据，节选的几个主题为：国际要闻、互联网、经济要闻、社会公益、书评、影视综艺。爬取的每条数据包含三个字段：标题、时间、正文，如图所示。 在得到基础数据之后就是对数据的预处理，其主要包括： - 对原始数据的加工 - 新闻相似度计算 - 新闻热度值计算 - 指定标签下的新闻统计 其系统的整体架构如下所示： 其中各个模块介绍如下。 MySQL数据存储：这里使用MySQL存储系统所使用的数据。系统实现选用的是Python的Django框架，在框架中有对数据对象的封装，在第11.4节中将会说明所创建的数据对象。 用户选择：系统指定了三个用户（张三、李四、王五）作为演示用户，只是为了区分不同用户、不同行为，“为你推荐”的内容也不同。 选择标签：用户与系统的交互过程，解决系统的冷启动。当然用户也可以不选择相应的标签，此时“为你推荐”模块显示的是热度数据。 用户点击浏览文章：即用户在系统中产生了相关行为，每篇文章的详细页都会推荐该篇文章的相似文章。 热度榜：按照第11.2.2节中计算的热度值进行排序，显示热度值较大的新闻。 为你推荐：如果用户是初次登录，则根据用户选择的标签返回“为你推荐”的内容；若用户没有选择标签，则返回热度值较高的新闻作为“为你推荐”的内容；如果用户是在点击\u001f\u001f浏览过新闻之后返回“为你推荐”模块，则返回用户有行为文章的相似文章，作为“为你推荐”的内容。 系统整体架构设计比较简单，和线上真正应用的复杂的推荐系统是有很大差距的，但实现思路是一致的。 接下来就是系统实现了，本实例采用前后端分离的形式进行实现，后端采用Python的Django框架进行开发，前端采用Vue.js框架开发。 后端开发依赖于Python 3.6版本，其中使用的包为：Django==2.1，PyMySQL==0.9.2，jieba==0.39，xlrd==1.1.0，gensim==3.6.0。 前端开发依赖于node.js环境，使用的是Vue.js框架，node.js对应的版本是10.13。 其最终实现的效果图如下： 通过这样一个实例，推荐系统变得不那么抽象，更加直观地展示在读者眼前。当然，每一个推荐系统背后都要付出很多，而不仅是算法层面，在从事相关工作时，更要拥有全局意识，要明白一个好的推荐系统是数据、算法、架构和展示等共同决定的，而不是靠“一己之力”。 音乐推荐系统过多的内容这里不展开介绍，大家看下效果图，感兴趣的化可以关注《推荐系统开发实战》 图书推荐系统 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之效果评估","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之效果评估","date":"2019-07-19T00:18:07.000Z","updated":"2019-10-14T06:42:35.671Z","comments":true,"path":"2019/07/19/RecSys/推荐系统开发实战/《推荐系统开发实战》之效果评估/","link":"","permalink":"http://thinkgamer.cn/2019/07/19/RecSys/推荐系统开发实战/《推荐系统开发实战》之效果评估/","excerpt":"推荐系统的评估方法分为用户调研、在线评估和离线评估。","text":"推荐系统的评估方法分为用户调研、在线评估和离线评估。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/96207006博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 用户调研推荐系统的离线实验指标和实际商业指标之间存在差异。例如，预测准确率和用户满意度之间就存在很大的差异，高预测准确率不等于高用户满意度。因此，要准确评估一个算法，需要相对真实的环境，最好的方法就是将算法直接上线测试。但如果对算法是否会降低用户满意度不太有把握，那么直接上线往往有较大的风险，所以在上线测试前一般需要做一次用户调研。在进行用户调研的过程中，需要保证测试用户的分布和真实用户分布相同。例如，男女各一半，年龄、活跃度的分布都和真实用户分布尽量相同。此外，用户调查要尽量保证是双盲实验，即不要让实验人员和用户事先知道测试的目标，以免用户的回答和实验人员的测试受主观成分的影响。 用户调研的优缺点也很明显。 优点：可以获得很多体现用户主观感受的指标，比在线实验风险低，出现错误后很容易弥补。 缺点：招募测试用户代价较大；很难组织大规模的测试用户，因此测试结果的统计意义不足。 此外，在很多时候设计双盲实验非常困难，而且用户在测试环境下的行为和真实环境下的行为可能有所不同，因而，在测试环境下收集到的测试指标可能与真实环境下的不太相同。所以，在实际推荐系统评估过程中，基本不会采用该方式进行评估，相反，会通过线上的一些行为统计得出结果。例如，豆瓣FM频道的点赞和删除，界面如图10-1所示。 在线评估在线评估：设计一个在线实验，然后根据用户的在线反馈结果来衡量推荐系统的表现。在线评估中，比较重要的两个选择点是——在线实验方式和在线评估指标，10.3和10.4节将分别介绍这两个知识点。 ABTest介绍ABTest就是为了实现同一个目标制定两个方案，让一部分用户使用A方案，另一部分用户使用B方案，记录下两部分用户的反馈情况，然后根据相应的评估指标确认哪种方案更好。 互联网行业里，在软件快速上线的过程中，ABTest是一个帮助我们快速试错的实验方法。在统计学上，ABTest其实是假设检验的一种形式。它能帮助开发者了解推荐系统的改动是否有效、能够带来多大的KPI提升。 在推荐系统中，为了对比不同算法、不同数据集对最终结果的影响，通过一定的规则将用户随机分成几组，并对不同组采取不同的召回或推荐算法，最终通过不同组用户的各种评估指标来进行对比分析。 一个典型得到ABTest架构图如下所示： 这里需要注意的是，在对用户进行分桶并召回商品之后，需要重新将用户打散并分桶，这样能确保不同桶之间的用户没有相关性，召回池中的ABTest和排序部分的ABTest没有关联，互不影响。 ABTest注意事项ABTest是一种在线上测试算法好坏的方法，由于其简单、直接、便于实施，被广泛应用在公司中。但在使用过程中仍要注意以下几个问题。（1）证实偏差。证实偏差是指：遇到一个命题时，人们倾向于寻找支持这个命题的证据，而忽略否定这个命题的证据。在ABTest中，算法工程师在调优的过程中，会自然地将测试假设和设计建立在他们自己的态度和观点上，而忽略了一些互相矛盾的信息，不去测试和设计与自己意见不一致的想法。这就会导致：一旦推荐系统出现符合预期的结果，他们会认为此前的想法是对的，也就不再进行实验了。这样就会导致很大的误差，不同的业务场景会受到营销和外界其他活动的影响。因此，在进行ABTest时要注意外界因素对系统的影响，应适当拉长测试周期。（2）幸存偏差。幸存偏差是一种认知偏差，其逻辑谬误为：推荐系统倾向于关注经常来访用户，而忽略他们在访问推荐系统的过程中已经被影响。例如“乔布斯勇于挑战体制取得了成功，所以大家都应该都去尝试挑战体制”，在这句话中没有提到那些挑战体制失败的人，仅以一名成功者为例说明，没有说明失败者的下场。在推荐系统中也一样，不能只关注来访者的行为特征和偏好，更要注意那些没有来访的用户的行为特征和偏好，这样才能保证推荐系统的泛化能力。（3）辛普森悖论。开始进行ABTest后，就不要更改设置、变量或对照的设计，并且不要在实验过程中更改已经分配到变量的流量。在测试期间调整变量的流量分配，可能会影响测试结果。当两组数据合并时，不同数据组中的趋势消失，便会产生“辛普森悖论”现象。（4）均值回归。在进行ABTest几天后，如果发现KPI指标有大幅提升，请不要立即下结论。因为这种早期的显著提升往往会在接下来的几天或几周的测试中逐渐消失，此时看到的不过是均值回归。也就是说，如果某一指标在第一次评估时出现极端结果，在后续的观察中，该指标会逐渐趋向于平均值。小样本尤其容易生产极端结果，因此不要在刚开始生成数据时就将所得到的结果解读成转化率，要适当增加测试时间，至少保证一个时间周期（如一周）。 在线评估指标在线评估指标是指在实际的业务场景中去评估推荐系统好坏的指标。常见的在线评估指标包括点击率、转化率、GMV等。 这里不展开介绍，欢迎阅读《推荐系统开发实战》 离线评估离线评估：根据待评估推荐系统在实验数据集上的表现，基于一些离线评估指标来衡量推荐系统的效果。相比于在线评估，离线评估更方便、更经济，一旦数据集选定，只需将待评估的推荐系统在此数据集上运行即可。离线评估最主要的环节有两个：拆分数据集、选择离线评估指标。 数据集拆分在机器学习中，通常将数据集拆分为训练数据集、验证数据集和测试数据集。它们的功能分别如下。 训练数据集（Train Dataset）：用来构建机器学习模型。 验证数据集（Validation Dataset）：辅助构建模型，用于在构建过程中评估模型，为模型提供无偏估计，进而调整模型的超参数。 测试数据集（Test Dataset）：评估训练完成的最终模型的性能。三类数据集在模型训练和评估过程中的使用顺序如图所示。 数据集拆分的方式有： 留出法 K-折交叉验证法 自助法 具体每种方法是什么意思，以及他们的实现，这里不展开介绍，欢迎阅读《推荐系统开发实战》 离线评估指标离线评估指标用于预估模型上线前在整个推荐系统中能达到的效果。常见的离线评估指标可以分为两大类： 准确度指标：评估推荐系统的最基本的指标，衡量的是指标推荐算法在多大程度上能够准确预测用户对推荐商品的偏好程度，可以分为分类准确度指标、预测评分准确度指标、预测评分指标关联。 非准确度指标：在推荐系统达到一定的准确度之后，衡量推荐系统丰富度和多样性等的指标。 其中预测分类准确度指标包含： AUC 准确率（Accuracy） 精确率（Precision） 召回率（Recall） F-measure值。 预测评分准确度指标包含： 平均绝对误差（MAE） 均方误差（MSE） 均方根误差（RMSE） 预测评分关联指标包含： 皮尔逊积距相关系统 斯皮尔曼等级相关系数 肯德尔等级相关系数 预测排序准确度指标包含： 评价排序分 非准确度的指标包含： 多样性 新颖性 惊喜度 覆盖率 信任度 实时性 健壮性 商业目标 具体指标的含义这里不过多介绍，欢迎阅读《推荐系统开发实战》了解具体含义和实现以及应用场景。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之冷启动介绍与解决","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之冷启动介绍与解决","date":"2019-07-18T14:37:44.000Z","updated":"2019-10-14T06:42:35.668Z","comments":true,"path":"2019/07/18/RecSys/推荐系统开发实战/《推荐系统开发实战》之冷启动介绍与解决/","link":"","permalink":"http://thinkgamer.cn/2019/07/18/RecSys/推荐系统开发实战/《推荐系统开发实战》之冷启动介绍与解决/","excerpt":"推荐系统基于用户大量的历史行为做出事物呈现，因此用户的历史行为数据是构建一个优质推荐系统的先决条件，但在实际场景中并非所有的用户都拥有丰富的历史数据，如首次进入电商网站的用户。如何在没有丰富历史数据的情况下为用户推荐个性化的商品，这就是冷启动问题。","text":"推荐系统基于用户大量的历史行为做出事物呈现，因此用户的历史行为数据是构建一个优质推荐系统的先决条件，但在实际场景中并非所有的用户都拥有丰富的历史数据，如首次进入电商网站的用户。如何在没有丰富历史数据的情况下为用户推荐个性化的商品，这就是冷启动问题。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/96203152博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 冷启动介绍冷启动主要分为三类：用户冷启动、物品冷启动、系统冷启动。 用户冷启动：解决的是如何给新用户进行个性化推荐的问题。当一个新用户进入网站或APP时，由于系统之前没有任何关于该用户的历史行为数据，导致无法对用户进行兴趣建模，从而无法为该用户进行个性化推荐。 物品冷启动：解决的是如何将新加入系统的物品推荐给用户。由于新物品没有任何被动行为，在系统中所占的权重几乎为0，这会导致在对商品排序或进行协同过滤推荐时该物品无法出现在推荐列表中。 系统冷启动：解决的是在一个新系统中没有用户，也没有用户行为，只有物品信息，如何给用户进行个性化推荐的问题。 针对推荐系统的冷启动，主要有以下几种实现方法： 基于热门数据推荐； 利用用户注册信息； 利用用户上下文信息； 利用第三方数据； 利用用户和系统之间的交互； 利用物品内容属性； 利用专家标注数据。下面将对如何解决推荐系统中的冷启动问题进行解答。 基于热门数据推荐实现冷启动热门数据是指（某类）物品按照一定规则进行排序得到的排名靠前的数据。热门数据反映的是大众的偏好，但受外界影响因素较大。例如某电商网站上的一个商品推广广告，可能会导致该商品在很短的时间内热度飙升；某新闻网站中的一条娱乐新闻，热度容易受舆论和明星效应的影响。虽然热门数据不能够准确地传达出用户偏好，但在某种程度上也是用户群体中大部分人的短期兴趣点。将热门数据作为解决用户冷启动的推荐数据，“个性化”地展示给用户，用户在这些数据中产生行为之后，再进行个性化推荐。 热门数据排行榜在实际场景中应用十分广泛。例如，当用户新到达一个地方，打开某生活服务APP的美食频道后，附近的商家就会默认以热度排序展示给用户，如图9-1所示。 在工业界的推荐系统中，召回的类型是多种多样的，但往往也会召回性别热门、地域热门或群体热门等数据，进而扩展推荐系统的丰富性。同时，在用户行为较少或偏好较少的情况下，也能准确地为用户进行商品推荐。 利用用户注册信息实现冷启动用户注册信息是指用户在新注册一个系统时所填写的信息。这些信息是联系新用户和系统的关键，也是系统获取的用户直接信息。 当一个新用户注册某个网站时，系统并不知道该用户喜欢什么物品，系统可以基于热门数据推荐为用户进行商品推荐。但如果系统能在用户进行注册时获取一些信息，则可以根据这些信息为用户进行商品推荐。例如，系统知道该用户来自东北，就可以给他推荐一些东北区域的热门物品；若知道该用户是来自东北的女性朋友，那么就会在地域的约束条件内，再给她推荐一些适合女性使用的物品，或者在性别的约束条件内，给她推荐一些区域内的热门商品。 用户在进行注册时，所填写的注册信息可以分为以下三类。 人口统计学信息：包括用户的年龄、身高、体重、居住地等。 用户兴趣的描述：某些网站或APP会让用户填写自己的兴趣爱好。 其他网站的导入数据：如用户通过微信、微博等登录第三方网站。 网站获取这些数据之后，就可以对用户进行粗粒度的个性化推荐了。其推荐的大致流程如下： 获取用户注册信息； 根据用户注册信息对用户进行分类（可以是多分类，即一个用户被分到多个类别中）； 给用户推荐其所在分类的用户最喜欢的物品，对不同类别下的物品进行加权求和。利用用户上下文信息实现冷启动前边介绍了用户的时间和地域等上下文信息在推荐系统中的应用。在实际的业务场景中，用户的上下文信息所构造的特征维度更加丰富，如用户使用的设备信息、用户所处的时间地域信息、用户看到商品的展示信息。 上下文特征是代表用户当前时空状态、最近一段时间的行为抽象的特征。 设备信息特征设备信息主要是用户进行浏览的载体（手机、平板电脑、电脑等）的信息。不同设备所携带的信息是不一样的。例如，手机或平板的操作系统分为iOS、Android、PC等；计算机的操作系统分为Windows、MacOS、UNIX等，手机和计算机品牌更是多种多样，不同设备的分辨率、屏幕尺寸、价格也是不一样的。不同设备下用户的偏好也是不一样的。例如，iOS系统的用户可能是个“苹果粉”，那么在冷启动时就可以推荐一些苹果相关的产品，为了提升推荐系统的丰富度，也可以推荐一些手机数码类别的商品。再如，用户是用UNIX系统进行商品浏览的，那么该用户有可能是IT工作者，可以给该用户推荐一些数码、技术书籍等商品。当然，除了在冷启动中使用这些特征，在正常训练推荐系统模型时也可以对设备的相关信息进行特征构造，进而作为特征来训练模型。 时间地域信息特征时间和地域是推荐系统中比较重要的信息，在第7章中介绍了相关内容。那么针对冷启动，时间和地域是怎样发挥它们作用的呢？时间可以是节假日、季节、周末等。地域可以是省市区、经纬度等，也可以是逻辑上的区域划分（如中关村软件园、商务中心区、海滨城市等）。当一个新用户来访时，通过对其建立时间和地域上的映射来为用户召回相关的商品并进行推荐。在构建特征时，时间和地域也是非常重要的。例如，对于时间，可以构造如下特征：是否是工作日、是否是休息日、访问时间所属的时间段（早上、上午、中午、下午、晚上、凌晨）等。 实现原理针对用户的上下文信息，可以根据用户的历史数据分析出用户在相应属性下的行为偏好，为相应的商品打上对应的时间和地域信息。在新用户来访时，系统通过获取时间和地域信息，召回对应属性下的数据，并按照一定的规则进行排序，然后返回前 K条数据给用户。例如，服装、食物类商品有着明显的季节属性，特产、海鲜类商品有着明显的节日属性，每个商品都有产地属性和品牌属性，这样通过相应的标签就可以将用户的上下文信息和已经构建好的标签进行关联了。同样，不仅可以将用户的上下文信息作为召回的标签数据，也可以对信息属性进行One-Hot编码，作为训练模型的特征使用。 利用第三方数据实现冷启动目前很多APP支持第三方账户登录，通过第三方的授权登录，系统可以获取到用户在第三方平台上的相关信息（包括用户本身的属性信息和朋友关系信息），从而可以使用协同过滤算法计算出用户可能感兴趣的商品，进而解决用户的冷启动问题，为用户推荐个性化的内容。 利用用户和系统之间的交互实现冷启动交互，即用户对系统的推荐结果做出反馈，或者系统通过一定的方式向用户进行兴趣征集。交互不仅在冷启动方面有着比较重要的作用，在推荐系统的结果反馈中也有着很重要的作用。 交互实现冷启动的原理和推荐系统中实时交互的应用有那些呢？ 利用物品的内容属性实现冷启动前边介绍的是如何解决推荐系统中的用户冷启动问题，对于物品冷启动问题该怎么解决呢？物品冷启动要解决的问题是，如何将新加入系统的物品推荐给对它感兴趣的用户。 物品的冷启动在新闻、娱乐、资讯类网站中格外重要。由于新闻的生命周期较短，如果无法在短期内将其曝光给更多的用户，那么其本身的价值将大大减小。 对于物品的冷启动，可以利用物品的内容属性将物品展示给尽可能符合其偏好的用户。 物品内容属性的分类物品的内容属性多种多样，不同类型的物品有不同的内容属性，这里将物品的内容属性概括为三大类： 物品本身的属性：用来描述物品本身的属性，具有宏观上的唯一性，如物品编码、标题名字、产出时间等。 物品的归纳属性：用来形容物品的类别信息属性，具有宏观概括性，如类别、品牌、标签、风格等。 物品的被动属性：用户表示物品的被动行为属性，具有客观概括性，如物品的浏览量、点击率、评论等。 物品内容属性分析？ 物品内容属性应用？ 利用专家标注数据实现冷启动很多推荐系统在刚开始建立时，既没有用户行为数据，也没有能用来准确计算物品相似度的物品信息。那么为了在刚开始就让用户获得良好的体验，很多系统都会采用专家标数据。这方面的代表是Pandora音乐电台。 Pandora是一个给用户播放音乐的个性化网络电台。计算音乐、视频之间的相似度是非常难的，音乐属于流媒体，如果从音频分析入手计算音乐的相似度，技术门槛很高，而且结果也难以令人满意。另外，仅仅利用音乐的专辑、歌手等信息也难以得到令人满意的结果。 为了解决这个问题，Pandora启动了一项称为“音乐基因组”的项目。这个名为“音乐基因组”的项目开始于1999年，该项目雇用一批懂计算机的音乐人，听了几万名歌手的歌，并对这些歌从各个维度进行标注，最终他们提供了450多维的特征来区分不同的音乐，这些标签可以细化到一首歌是否有吉他的和弦、是否有架子鼓、主唱的年龄等。在得到这些维度的特征之后就可以利用基于内容的推荐算法进行相似度计算了。这里的内容指的是音乐本身所表现出来的内容。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之基于点击率预估的推荐算法介绍和案例开发实战","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之基于点击率预估的推荐算法介绍和案例开发实战","date":"2019-07-17T15:24:05.000Z","updated":"2019-10-14T06:42:35.670Z","comments":true,"path":"2019/07/17/RecSys/推荐系统开发实战/《推荐系统开发实战》之基于点击率预估的推荐算法介绍和案例开发实战/","link":"","permalink":"http://thinkgamer.cn/2019/07/17/RecSys/推荐系统开发实战/《推荐系统开发实战》之基于点击率预估的推荐算法介绍和案例开发实战/","excerpt":"本系列之前介绍的都是一些基本的推荐算法，将这些算法真正应用到工业界（即应用推荐系统的地方，如电商网站、广告推广等）其实是很难的。并不是说这些算法没有用武之地，而是要根据具体的场景来判断是否能使用推荐系统。本篇会先对传统的推荐算法进行总结和说明，然后对目前业界用得最广的GBDT算法和LR算法进行介绍。","text":"本系列之前介绍的都是一些基本的推荐算法，将这些算法真正应用到工业界（即应用推荐系统的地方，如电商网站、广告推广等）其实是很难的。并不是说这些算法没有用武之地，而是要根据具体的场景来判断是否能使用推荐系统。本篇会先对传统的推荐算法进行总结和说明，然后对目前业界用得最广的GBDT算法和LR算法进行介绍。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/95519780博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 传统推荐算法的局限和应用1. 海量数据例如，协同过滤算法能够容易地为“千万”级的用户提供推荐，但是对于电子商务网站（其用户数和物品数往往以“亿”来计量），协同过滤算法就很难提供服务了。在协同过滤算法中，能利用最新的信息及时为用户产生相对准确的用户兴趣度预测，或者进行推荐。但是面对日益增多的用户，数据量急剧增加，算法的扩展性问题（即适应系统规模不断扩大的问题）成为制约推荐系统实施的重要因素。与基于模型的算法相比，全局数值算法虽然节约了为建立模型而花费的训练时间，但是其用于识别“最近邻居”算法的计算量会随着用户和物品的增加而急剧增大。对于以“亿”来计量的用户和物品，通常的算法会遇到严重的扩展性瓶颈问题。对于采用了协同过滤技术的推荐系统，该问题解决不好，直接会影响其实时性。推荐系统的实时性越好、精确度越高，该系统才越会被用户所接受。 2. 稀疏性伴随着海量数据的一个问题便是数据的稀疏性。在电子商务网站中，活跃用户所占的比例很小，大部分用户都是非活跃用户，非活跃用户购买或点击的商品数目也很少。因此，在使用协同过滤算法构建矩阵时，矩阵会非常稀疏；使用基于内容的推荐算法为用户构建的偏好矩阵也是非常稀疏的。这样，一方面难以找到最近邻的用户集，或者难以准确地得到用户行为偏好；另一方面，在计算的过程中会消耗大量的资源。 3. 实时性实时性是评判一个推荐系统能否及时捕捉用户兴趣变化的重要指标。推荐系统的实时性主要包括两方面： 推荐系统能实时地更新推荐列表来满足用户新的行为变化； 推荐系统能把新加入系统的物品推荐给用户。而传统的协同过滤算法每次都需要计算所有用户和物品的数据，难以在“秒”级内捕捉到用户的实时兴趣变化。 点击率预估在推荐系统中的应用点击率预估（CTR）最早应用于搜索广告中。时至今日，点击率预估的应用场景不仅从最开始的搜索广告扩展到展示广告、信息流广告等各种各样的广告，而且在推荐系统的场景中也得到了广泛应用。 从用户的点击行为来分析，“点击率预估”在广告或推荐场景中的应用是一致的。广告的“点击率预估”计算的是用户点击广告的可能性；而在推荐系统中，推荐商品也被预测用户的兴趣，如果用户对一个商品感兴趣便会去点击。这也是近些年CTR在推荐系统中被广泛应用的原因。目前在CTR领域应用较多的算法包含LR、GBDT、XGBoost、FM、FFM、神经网络算法等，这些算法也被应用到推荐系统中。其中，GBDT是一种非线性算法，基于集成学习中的Boosting（提升方法）思想，每次迭代都在减少残差的梯度方向新建立一棵决策树，迭代多少次就会生成多少棵决策树。 GBDT算法的思想使其具有天然优势：可以发现多种有区分性的特征和特征组合；决策树的路径可以直接作为LR输入特征使用；省去了人工寻找特征、特征组合的步骤。 点击率预估算法的基础集成学习机器学习算法分为有监督学习算法和无监督学习算法。在有监督学习算法中，我们的目标是学习出一个稳定的且在各个方面都表现较好的模型。但实际情况往往不理想，有时只能得到多个在某些方面表现比较好的“弱监督模型”。集成学习就是组合多个“弱监督模型”以得到一个更好、更全面的“强监督模型”。集成学习本身不是一个单独的机器学习算法，而是通过构建并组合多个弱学习器来完成学习任务，如图所示 集成学习包括Boosting算法（提升法）、Bagging算法（自助法）和Stacking算法（融合法）三种算法。 > 那么三种集成学习方法的具体含义是什么呢？ ## 导数、偏导数、方向导数、梯度 了解这些概念是学习点击率预估算法的基础，很多算法都是基于梯度下降进行求解的，但要了解梯度下降就必须要明白导数，偏导数，方向导数的概念。 这里不展开介绍，大家可以从《推荐系统开发实战》中获取内容。 # GBDT算法 GBDT算法（Gradient Boosting Decision Tree）又叫 MART（Multiple Additive Regression Tree)，是一种迭代的决策树算法。 该算法中构建多棵决策树组成，所有决策树的结论累加起来作为最终答案。它在被提出之初就和SVM一起被认为是泛化能力较强的算法。 ## GBDT的算法原理 GBDT算法可以看成是T棵树组成的加法模型，其对应的公式如下： 式中： x：输入样本； w：模型参数； h：分类回归树； α：每棵树的权重。GBDT算法的实现过程如下。（1）初始化函数F0常量（其中L为损失函数）： （2）循环执行M次，建立M棵分类回归树。创建第m（m=1,2,…,M）棵树的过程见步骤（3）~步骤（6）。（3）计算第m棵树对应的响应值（伪残差），计算公式如下： （4）使用CART回归树拟合数据得到第m棵树的叶子节点区域Rj,m，其中j=1,2,… ,Jm。（5）对于j=1,2, … ,Jm，计算： （6）更新Fm为: （7）输出Fm(x) 具体的GBDT算法实例，这里不展开介绍。 回归分析回归分析算法（Regression Analysis Algorithm）是机器学习算法中最常见的一类机器学习算法。就是利用样本（已知数据），产生拟合方程，从而（对未知数据）进行预测。例如有一组随机变量X（x1，x2，x3，…）和另外一组随机变量Y（y1，y2，y3，…），那么研究变量X与Y之间关系的统计学方法就叫作回归分析。因为这里X和Y是单一对应的，所以这里是一元线性回归。 回归分析算法分为线性回归算法和非线性回归算法。 线性回归 线性回归可以分为一元线性回归和多元线性回归。当然线性回归中自变量的指数都是1，这里的线性并非真的是指用一条线将数据连起来，也可以用一个二维平面、三维曲面等。一元线性回归：只有一个自变量的回归。例如房子面积（Area）和房子总价（Money）的关系，随着面积（Area）的增大，房屋价格也是不断增加。这里的自变量只有面积，所以是一元线性回归。多元线性回归：自变量大于或等于两个的回归。例如房子面积（Area）、楼层（floor）和房屋价格（Money）的关系，这里自变量有两个，所以是二元线性回归。典型的线性回归方程如下： 在统计意义上，如果一个回归等式是线性的，那么它相对于参数就必须是线性的。如果相对于参数是线性的，那么即使相对于样本变量的特征是二次方或多次方的，这个回归模型也是线性的。例如下面的式子： 甚至可以使用对数或指数去形式化特征，如下： 非线形回归 有一类模型，其回归参数不是线性的，也不能通过转换的方法将其变为线性的参数，这类模型称为非线性回归模型。非线性回归可以分为一元回归和多元回归。非线性回归中至少有一个自变量的指数不为1。回归分析中，当研究的因果关系只涉及因变量和一个自变量时，叫作一元回归分析；当研究的因果关系涉及因变量和两个或两个以上自变量时，叫作多元回归分析。 例如下面的两个回归方程： 与线性回归模型不一样的是，这些非线性回归模型的特征因子对应的参数不止一个。 广义线性回归 有些非线性回归也可以用线性回归的方法来进行分析，这样的非线性回归叫作广义线性回归。 典型的代表是Logistic回归。 LR算法逻辑回归与线性回归本质上是一样的，都是通过误差函数求解最优系数，在形式上只不过是在线性回归上增加了一个逻辑函数。与线性回归相比，逻辑回归（Logistic Regression，LR）更适用于因变量为二分变量的模型，Logistic 回归系数可用于估计模型中每个自变量的权重比。 我们都知道LR算法使用的是Sigmoid函数作为结果值的区分函数，那么LR为什么要使用Sigmoid呢？ LR的算法原理机器学习模型实际上把决策函数限定在某一组条件下，这组限定条件就决定了模型的假设空间。当然，还希望这组限定条件简单而合理。逻辑回归模型所做的假设是： 这里的g(h)就是Sigmoid函数，相应的决策函数为： 选择0.5作为阈值是一般的做法，实际应用时，特定的情况下可以选择不同的阈值。如果对正例的判别准确性要求高，可以使阈值大一些；如果对正例的召回要求高，则可以使阈值小一些。在函数的数学形式确定之后，就要求解模型中的参数了。统计学中常用的一种数学方法是最大似然估计，即找到一组参数，使得在这组参数条件下数据的似然度（概率）更大。在逻辑回归算法中，似然函数可以表示为： 取对数，可以得到对数形式的似然函数： 同样这里也使用损失函数来衡量模型预测结果准确的程度，这里采用lg损失函数，其在单条数据上的定义为： 如果取整个数据集上的平均lg损失，可以得到： 在逻辑回归模型中，最大化似然函数和最小化lg损失函数实际上是等价的。对于该优化问题，存在多种求解方法，这里以梯度下降的情况为例说明。基本步骤如下：沿梯度负方向选择一个较小的步长可以保证损失函数的值是减小的，另外，逻辑回归模型的损失函数是凸函数（加入正则项后是严格凸函数），可以保证找到的局部最优值是全局最优值。 正则化当模型中参数过多时，容易产生过拟合，这时就要控制模型的复杂度，其中最常见的做法是在目标中加入正则项，通过惩罚过大的参数来防止过拟合。常见的正则化方法包括L1 正则化和L2 正则化。其分别对应如下两个公式： L1 正则化是指权值向量w 中各个元素的绝对值之和，通常表示为||w||1。 L2 正则化是指权值向量w 中各个元素的平方和然后再求平方根（可以看到Ridge 回归的L2 正则化项有平方符号），通常表示为||w||2。 模型融合背景介绍在CTR 预估问题发展初期，使用最多的方法就是逻辑回归（LR），LR 使用了Sigmoid 变换将函数值映射到0~1 区间，映射后的函数值就是CTR 的预估值。LR 属于线性模型，容易并行化，可以轻松处理上亿条数据，但是学习能力十分有限，需要大量的特征工程来增强模型的学习能力。GBDT 是一种常用的非线性模型，它基于集成学习中的Boosting 思想，每次迭代都在减少残差的梯度方向新建立一棵决策树，迭代多少次就会生成多少棵决策树。GBDT 的思想使其具有天然优势，可以发现多种有区分性的特征及特征组合。决策树的路径可以直接作为LR 输入特征使用，省去了人工寻找特征、特征组合的步骤。这种通过GBDT 生成LR 特征的方式（GBDT+LR），业界已有实践（Facebook、Kaggle 等），且取得了不错的效果。 为什么使用GBDT和LR进行模型融合在介绍模型融合之前，需要先了解下面两个问题。 为什么使用集成的决策树 一棵树的表达能力很弱，不足以表达多个有区分性的特征组合，多棵树的表达能力更强一些。GBDT 中，每棵树都在学习前面的树存在的不足，迭代多少次就会生成多少棵树。按Facebook的论文及Kaggle 竞赛中的GBDT+LR 融合方式，多棵树正好满足LR 每条训练样本可以通过GBDT 映射成多个特征的需求。 为什么使用GBDT 构建决策树而不是RandomForest（RF） RF（随机森林）也是多棵树组成的，但从效果上有实践证明不如GBDT。对于GBDT 前面的树，特征分裂主要体现对多数样本有区分度的特征；对于后面的树，主要体现的是经过前N棵树，残差仍然较大的少数样本。优先选用在整体上有区分度的特征，再选用针对少数样本有区分度的特征，这样的思路更加合理，这也是用GBDT 的原因。 GBDT+LR 模型融合的原理GBDT+LR 模型融合思想来源于Facebook 公开的论文Practical Lessons from PredictingClicks on Ads at Facebook。其主要思想是：GBDT 每棵树的路径直接作为LR 的输入特征使用。即用已有特征训练GBDT 模型，然后利用GBDT 模型学习到的树来构造新特征，最后把这些新特征加入原有特征一起训练模型。构造的新特征向量是取值0/1 的，向量的每个元素对应于GBDT 模型中树的叶子节点。若一个样本点通过某棵树最终落在这棵树的一个叶子节点上，那么在新特征向量中这个叶子节点对应的元素值为1，而这棵树的其他叶子节点对应的元素值为0。新特征向量的长度等于GBDT 模型里所有树包含的叶子节点数之和。在Facebook 的公开论文中，有一个例子，如图8-10 所示。 图8-10 中共有两棵树，x 为一条输入样本，遍历两棵树后，x 样本分别落到两棵树的叶子节点上，每个叶子节点对应LR一维特征，那么通过遍历树就得到了该样本对应的所有LR特征。构造的新特征向量是取值0/1 的。举例来说：图8-10 中有两棵子树，左子树有三个叶子节点，右子树有两个叶子节点，最终的特征即为五维的向量。对于输入x，假设x 落在左子树第一个节点时，编码[1,0,0]，落在右子树第二个节点时编码[0,1]，则整体的编码为[1,0,0,0,1]，这类编码作为特征，输入到LR 中进行分类。 电信客户流失案例这里将会介绍使用GBDT，LR和模型融合三种方式实现电信客户流失，在三种情况的对比下，模型融合的方法效果更好，具体不展开介绍，可以参考《推荐系统开发实战》 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之基于标签的推荐算法介绍和案例实战开发","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之基于标签的推荐算法介绍和案例实战开发","date":"2019-07-15T14:20:17.000Z","updated":"2019-10-14T06:42:35.669Z","comments":true,"path":"2019/07/15/RecSys/推荐系统开发实战/《推荐系统开发实战》之基于标签的推荐算法介绍和案例实战开发/","link":"","permalink":"http://thinkgamer.cn/2019/07/15/RecSys/推荐系统开发实战/《推荐系统开发实战》之基于标签的推荐算法介绍和案例实战开发/","excerpt":"标签系统的传统用法是，在一些网站中，用户会为自己感兴趣的对象打上一些标签，如豆瓣、网易云音乐、Last.fm等。这些社会化标签即资源的分类工具，也是用户个人偏好的反映，因此社会化标签为推荐系统获得用户偏好提供了一个新的数据来源。之所以说“传统”，是因为这些标签是用户主观意愿的表达，是主动行为。但是，有些电商网站也会对用户或商品进行一些客观的打标，如对一个经常网购数码产品的用户打上一个“数码达人”的标签，以便后继给该用户推荐数码类商品。","text":"标签系统的传统用法是，在一些网站中，用户会为自己感兴趣的对象打上一些标签，如豆瓣、网易云音乐、Last.fm等。这些社会化标签即资源的分类工具，也是用户个人偏好的反映，因此社会化标签为推荐系统获得用户偏好提供了一个新的数据来源。之所以说“传统”，是因为这些标签是用户主观意愿的表达，是主动行为。但是，有些电商网站也会对用户或商品进行一些客观的打标，如对一个经常网购数码产品的用户打上一个“数码达人”的标签，以便后继给该用户推荐数码类商品。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/95403294博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 标签系统的应用推荐系统的目的是联系用户和物品，这种联系需要不同的“媒介”。例如： 相似用户（给用户推荐相似用户喜欢的物品），媒介是用户。 相似物品（给用户推荐他喜欢物品的相似物品），媒介是物品。 隐含的特征（根据用户的历史行为构造特征，进而预测对新物品的偏好程度），媒介是行为特征。 本章将介绍一种新的联系媒介——标签。工业界中的主流标签系统包含： Last.fm Delicious 豆瓣 网易云音乐 数据标注与关键词提取关键词是指能够反映文本语料主题的词语或短语。在不同的业务场景中，词语和短语具有不同的意义。例如： 从电商网站商品标题中提取标签时，词语所传达的意义就比较突出。 从新闻类网站中生成新闻摘要时，短语所传达的意义就比较突出。 数据标注数据标注即利用人工或AI（人工智能）技术对数据（文本、图像、用户或物品）进行标注。标注有许多类型，如: 分类标注：即打标签，常用在图像、文本中。一般是指，从既定的标签中选择数据对应的标签，得到的结果是一个封闭的集合。 框框标注：常用在图像识别中，如有一张环路上的行车照片，从中框出所有的车辆。 区域标注：常见于自动驾驶中。例如从一张图片中标出公路对应的区域。 其他标注：除了上述常见的标注类型外，还有许多个性化需求。例如，自动摘要、用户或商品的标签（因为其中总有一些未知标签，当然也可以看成是多分类）。 数据标注的一般步骤为：（1）确定标注标准：设置标注样例和模板（如标注颜色时对应的比色卡等）。对于模棱两可的数据，制定统一的处理方式。（2）确定标注形式：标注形式一般由算法人员确定。例如，在垃圾问题识别中，垃圾问题标注为1，正常问题标注为0。（3）确定标注方法：可以使用人工标注，也可以针对不同的标注类型采用相应的工具进行标注。 那么，数据标注与标签的对应关系是什么呢？ 数据标注在推荐系统中的应用关键词提取在推荐系统中的应用也十分广泛，主要用于用户物品召回（根据用户对关键词的行为偏好，召回相应关键词下的物品）和特征属性构造（对物品的属性进行补充）。具体的案例这里不过多做介绍。 推荐系统中的关键词提取关键词是指能够反映文本语料主题的词语或短语。在不同的业务场景中，词语和短语具有不同的意义。例如： 从电商网站商品标题中提取标签时，词语所传达的意义就比较突出。 从新闻类网站中生成新闻摘要时，短语所传达的意义就比较突出。 这里所介绍的关键提取和数据标注同样都是一个动作，都是为了得到一些标签或属性特征。关键词提取从最终的结果反馈上来看可以分为两类： 关键词分配：给定一个指定的词库，选取和文本关联度最大的几个词作为该文本的关键词。 关键词提取：没有指定的词库，从文本中抽取代表性词作为该文本的关键词。不管通过哪种方式生成，关键词都是对短文本所传达含义的抽取概述，都直接反映了短文本的所传达的属性或特征 标签的分类在推荐系统中，不管是数据标注还是关键词提取，其目的都是得到用户或物品的标签。但是在不同场景下，标签的具体内容是不定的。例如，同样是分类标注，新闻的类别里可以有军事、科技等，但音乐的类别里就很少会涉及军事或科技了。对于社会化标签在标识项目方面的功能，Golder和Huberman将其归纳为以下7种： 标识对象的内容。此类标签一般为名词，如“IBM”“音乐”“房产销售”等。 标识对象的类别。例如标识对象为“文章”“日志”“书籍”等。 标识对象的创建者或所有者。例如博客文章的作者署名、论文的作者署名等。 标识对象的品质和特征。例如“有趣”“幽默”等。 用户参考用到的标签。例如“myPhoto”“myFavorite”等。 分类提炼用的标签。用数字化标签对现有分类进一步细化，如一个人收藏的技术博客，按照难度等级分为“1”“2”“3”“4”等。 用于任务组织的标签。例如“to read”“IT blog”等。当然以上7种类别标签是一个通用框架，在每一个具体的场景下会有不同的划分。 基于TF-IDF提取标题中的关键词TF-IDF（Term Frequency–Inverse Document Frequency）是一种用于资讯检索与文本挖掘的常用加权技术。TF-IDF算法的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或短语具有很好的类别区分能力，适合用来分类。TF-IDF实际是TF*IDF。 那么TF-IDF的具体算法原理是什么？以及我们如何从商品标题中提取关键词呢？ 基于标签的推荐系统标签是用户描述、整理、分享网络内容的一种新的形式，同时也反映出用户自身的兴趣和态度。标签为创建用户兴趣模型提供了一种全新的途径。本节将展开介绍基于标签的用户如何进行兴趣建模。 标签评分算法用户对标签的认同度可以使用二元关系表示，如“喜欢”或“不喜欢”；也可以使用“连续数值”表示喜好程度。 二元表示方法简单明了，但精确度不够，在对标签喜好程度进行排序时，也无法进行区分。所以，这里选用“连续数值”来表达用户对标签的喜好程度。 为了计算用户对标签的喜好程度，需要将用户对物品的评分传递给这个物品所拥有的标签，传递的分值为物品与标签的相关度。 1.用户对标签的依赖程度如图6-13所示，用户u对艺术家A的评分为5星，对艺术家B的评分为3星，对艺术家C的评分为4星。艺术家A与标签1、2、3的相关度分别为：0.6，0.8，0.4；艺术家B与标签1、2、3的相关度分别为：0.3，0.6，0.9；艺术家C与标签1、2、3的相关度分别为：0.5，0.7，0.6。 对应的用户（u）对标签（t）的喜好程度计算公式为： 式中： rate(u,t)表示用户u对标签t的喜好程度。 rate(u,i)表示用户u对艺术家i的评分。 rel(i,t)表示艺术家i与标签t的相关度。 根据式（6.4）计算出用户u对标签1的喜好程度为：（50.6+30.3+40.5）/（0.6+0.3+0.5）=4.21 同理可以计算出用户u对标签2的喜好程度为 4.10，对标签3的喜好程度为3.74。 2.优化用户对标签的喜好程度 如果一个用户的评分行为较少，就会导致预测结果存在误差。那么该如何改进呢？ 标签评分算法改进 这里使用TF-IDF算法来计算每个标签的权重，用该权重来表达用户对标签的依赖程度。TF-IDF算法在6.3.1节中进行了介绍，这里不再赘述。每个用户标记的标签对应的TF值的计算公式为： 式中： n(u,ti)表示用户u使用标签ti标记的次数。 分母部分表示用户u使用所有标签标记的次数和。TF(u,t)表示用户u使用标签t标记的频率，即用户u对标签t的依赖程度。 优化用户对标签的依赖程度在社会化标签的使用网站中存在“马太效应”，即热门标签由于被展示的次数较多而变得越来越热门，而冷门标签也会越来越冷门。大多数用户标注的标签都集中在一个很小的集合内，而大量长尾标签则较少有用户使用。事实上，较冷门的标签才能更好地体现用户的个性和特点。为了抑制这种现象，更好地体现用户的个性化，这里使用逆向文件频率（IDF）来对那些热门标签进行数值惩罚。 每个用户标记的标签对应的IDF值的计算公式为： 分子表示所有用户对所有标签的标记计数和。 分母表示所有用户对标签t的标记计数和。 IDF( u, t)表示t的热门程度，即一个标签被不同用户使用的概率。对于一个标签而言，如果使用过它的用户数量很少，但某一个用户经常使用它，说明这个用户与这个标签的关系很紧密。 用户对标签的兴趣读综合式（6.6）和式（6.7），用户对标签的依赖度为： 在6之前分析了用户对标签的主观喜好程度，本节分析了用户对标签的依赖程度，综合可以得到用户u对标签的兴趣度为： 标签基因标签基因是GroupLens研究组的一个项目。在社会化标签系统中，每个物品都可以被看作与其相关的标签的集合，rel(i, t)以从0（完全不相关）到1（完全正相关）的连续值衡量一个标签与一个物品的符合程度。例如图6-13中： rel(艺术家A，标签1)=0.6； rel(艺术家A，标签2)=0.8； rel(艺术家A，标签3)=0.4。采用标签基因可以为每个艺术家i计算出一个标签向量rel(i)，其元素是i与T中所有标签的相关度。这里，rel( i)相当于以标签为基因描绘出了不同物品的基因图谱。形式化的表达如下： 例如，图6-13中，艺术家A的标签基因为：rel(艺术家A)=[0.6,0.8,0.4]。选用标签基因来表示标签与物品的关系有以下三个原因：（1）它提供了从0到1的连续数值；（2）关系矩阵是稠密的，它定义了每个标签t∈ T与每个物品 i∈ I的相关度；（3）它是基于真实数据构建的。 用户兴趣建模根据训练数据，可以构建所有商品的标签基因矩阵Ti和用户最终对标签的兴趣度Tu，则用户对商品的可能喜好程度为： 式中： Tu：用户u对所有标签的兴趣度矩阵（1行m列，m为标签个数）。 Ti^T：所有商品的标签基因矩阵Ti的转置矩阵（m行n列，m为标签个数，n为商品个数）。 T(u,i)：用户u对所有商品的喜好程度矩阵（1行n列，n为商品个数）。最终从计算结果中选取前K个推荐给用户。基于标签推荐算法实现艺术家推荐利用标签推荐算法实现一个艺术家推荐系统，即，根据用户已经标记过的标签进行标签兴趣建模，进而为用户推荐喜好标签下最相关的艺术家。 这里使用Last.fm数据集中的数据作为基础数据，该数据集在3.3节有相关的介绍。该实例的具体实现思路如下：（1）加载并准备数据；（2）计算每个用户对应的标签基因；（3）计算用户最终对每个标签的兴趣度；（4）进行艺术家推荐和效果评估。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之基于上下文的推荐算法介绍和案例实战开发","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之基于上下文的推荐算法介绍和案例实战开发","date":"2019-07-15T14:12:17.000Z","updated":"2019-10-14T06:42:35.669Z","comments":true,"path":"2019/07/15/RecSys/推荐系统开发实战/《推荐系统开发实战》之基于上下文的推荐算法介绍和案例实战开发/","link":"","permalink":"http://thinkgamer.cn/2019/07/15/RecSys/推荐系统开发实战/《推荐系统开发实战》之基于上下文的推荐算法介绍和案例实战开发/","excerpt":"在本系列之前介绍的推荐算法主要是为了联系用户的偏好和物品，将符合用户偏好的物品推荐给用户。例如“基于标签的推荐算法”中介绍的偏好是“用户的主观意见表达”，物品本身所传达的含义和用户所处的客观环境对推荐系统而言也是极其重要的，如冬天推荐短袖、中秋节推荐粽子等都是不合理的，不能说用户在冬天搜索了短袖或在中秋节搜索了粽子就给用户推荐不合时节的物品。因此，准确地了解用户的上下文信息（包括用户访问推荐系统的时间、地点、访问时的心情等），并将这些信息应用到推荐系统中，是实现一个好的推荐系统的关键。","text":"在本系列之前介绍的推荐算法主要是为了联系用户的偏好和物品，将符合用户偏好的物品推荐给用户。例如“基于标签的推荐算法”中介绍的偏好是“用户的主观意见表达”，物品本身所传达的含义和用户所处的客观环境对推荐系统而言也是极其重要的，如冬天推荐短袖、中秋节推荐粽子等都是不合理的，不能说用户在冬天搜索了短袖或在中秋节搜索了粽子就给用户推荐不合时节的物品。因此，准确地了解用户的上下文信息（包括用户访问推荐系统的时间、地点、访问时的心情等），并将这些信息应用到推荐系统中，是实现一个好的推荐系统的关键。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/95445593博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 基于时间特征的推荐什么是时间效应？时间效应在日常生活中随处可见。例如，随着年龄的增长，人们的穿衣风格会改变，钟爱的课外读物也会改变；季节不同，人们的穿着会改变，果蔬供给也会改变等。 在推荐系统中，时间效应可以定义为：用户的偏好兴趣、物品的生命周期等随着时间的变化而发生变化。 时间效应对推荐系统的效果有着直接的影响，其对用户兴趣的影响主要表现在以下几方面。 偏好迁移。由于用户自身原因，随着时间的变化其偏好、兴趣发生了改变。例如，人们在不同年龄所热爱的事物不一样，用户A小时候喜欢吃糖果，长大了却不再吃糖果了；用户B在上高中时喜欢读一些小说之类的读物，可在念了大学之后，便开始阅读一些和专业课相关的读物。 用户的偏好直接影响着推荐的结果集，所以，推荐系统需要实时关注用户的实时兴趣变化。例如，用户在某个时刻点击或关注了某个商品，那么在下一刻，用户已经点击或者关注的相关商品就应该出现在推荐结果集中。但是，推荐系统还要注意挖掘用户的短期偏好和长期偏好（即挖掘用户兴趣中的长尾商品），这时就需要根据用户过去一段时间内的行为习惯进行兴趣建模。 生命周期。 生命周期即事物合理存在的时间周期。例如某个热门新闻，在新闻刚发布时，受关注的程度很高，各大媒体网站都会进行报道，但随着时间的推移，该新闻的热度在逐渐减小，最后慢慢被人遗忘，这就是该热门新闻的生命周期。 推荐系统在进行事物推荐时，要注意该事物的有效性。一个合理的推荐系统不会在2018年推荐2004年雅典奥运会刘翔打破奥运纪录的新闻，也不会推荐某种过时的食物。不同场景下的推荐系统中，推荐事物的生命周期长度也不尽相同。新闻的生命周期较短，一般在几天之内就会褪去热度，而食物的生命周期就较长。 季节效应。 季节效应：事物的流行度与季节是强相关的，反映的是时间本身对用户偏好兴趣的影响。例如，人们在夏天穿短袖，在冬天穿羽绒服，在夏天喝啤酒，在冬天吃火锅等。 在不同季节，人们的衣食住行选择都会发生变化。在推荐系统中要实时捕捉到季节的变化，进而给用户推荐符合时节的物品。 节日选择。 节日选择：不同的节日对用户的选择会产生影响，也是时间效应中的一种。例如，端午节人们会选购一些粽子送给亲朋好友，而在中秋节则会选购一些月饼、螃蟹。又如，美国的感恩节，人们会购买火鸡作为餐桌上的主菜。 在不同的节日适当地给用户推送一些节日主打物品，不仅可以提高用户点击率，而且可以在一定程度上发掘用户的隐含兴趣 时间效应分析推荐系统中引入时间信息后，就从一个静态的推荐系统变成了一个动态的推荐系统。时间信息对推荐系统的影响主要表现在以下三方面： 个人兴趣度会随时间发生变化； 物品流行度会随时间发生变化； 社会群体兴趣度会随时间发生变化。 那么个人兴趣，物品流行度，社会群体兴趣度是如何随时间变化呢？ 推荐系统的实时性用户的兴趣是不断发生变化的，其变化体现在用户不断增加的行为中。例如电商网站中的点击、加购、分享、收藏等，或者新闻网站中的点击、评论、停留时长等。 一个实时的推荐系统应实时响应用户的新行为，让推荐结果不断发生变化，从而满足用户实时兴趣需求。 现在几乎所有的电商网站中都引入了实时推荐，而且响应时间在“秒”之内。例如当当，京东，淘宝等电商，内容，娱乐平台。 那么他们是如何做到实时推荐呢？实时推荐的具体表现是什么？ 协同过滤中的实时推荐1.UserCF中的时间特征使用UserCF为用户推荐物品时，先找到与目标用户兴趣相近的用户集合，然后根据这些用户的购买行为为用户进行物品推荐，故该算法的关键是“找到相似用户集合”（即计算用户之间的相似度）。两个用户产生过行为的物品集合交集越大，则两个用户越相似。用户相似度计算公式如下： 式中，N(x)表示用户x产生过行为的物品集合，分子表示的是用户u和用户v有交集的物品的个数，分母表示的是用户u和用户v产生行为的并集物品的个数。但是由于热门物品被很多用户有过行为，但相对于热门共有物品而言，冷门物品更能说明两个用户之间的相似性，所以在计算两个用户之间的相似度时，对热门物品加一个惩罚项，所以这里的用户相似度计算式可以修改为： 式（7.2）中，N(i)表示对物品i产生过行为的所有用户的个数。但由于最近的行为最能表达用户当前的兴趣，所以在计算两个用户相似度时要增加时间衰减函数，可得到以下公式： 式中，f(|tui-tvi|)为时间衰减函数，其形式为： 式中，为时间衰减因子，tui表示用户u对物品i产生行为的时间，tvi表示用户v对物品i产生行为的时间。用户当前的评分受相似用户集合最近评分的影响比较大，所以在计算用户对物品的评分时还要加上时间衰减函数f(|t0-tvi|)，所以最终得到的用户u对物品i的偏好程度为： 其中f(|t0-tvi|)的表达式如下： 式中，t0表示当前时间，tvi表示用户v对物品i产生行为的时间。 那么ItemCF中的时间特征如何理解呢？我们如何使用代码来实现CF中的时间衰减呢？ 基于地域和热度特征的推荐除了时间，地域特征在推荐系统中也十分重要，不同地区的用户喜欢的事物不一样，用户到了不同的地方喜欢的事物也会发生变化。例如南方人喜欢吃米，北方人喜欢吃面；又如，一个国内的人去韩国可能是为了购物和旅游等。而另外一种经常和地域一同出现的是热度特征，最常见的如排行榜，就是基于地域和统计的一种排序。 为什么要把时间和地域特征放在一起讨论呢？ 明尼苏达大学的研究人员提出过一个称为LARS（Location Aware Recommender System，位置感知推荐系统）的推荐系统。该系统首先将物品分为两类： 有空间属性（如餐厅、商店、景点等）物品； 无空间属性（如图书、电影、音乐）物品。同时，也将用户分为两类： 有空间属性（如用户包含相应的空间属性信息）用户。 无空间属性（如用户没有相应的空间属性信息）用户。 基于地域和热度的推荐算法的基本原理是：按照地域对事物进行划分，然后根据热度对事物进行排序，进而推荐给用户。下面以新闻为例说明热度算法的基本原理。 在一则新闻录入数据库后，初始化一个热度分（S0），此时该新闻就进入了新闻推荐的候选池。 随着新闻不断被用户点击（click）、转发（share）、关注（follow）、评论（comment）、点赞（up）等，对应的和用户交互维度的热度（S1）不断增加。 另外，新闻要求具有时效性，因此在新闻发布后，热度（S2）会随着时间衰减。随着时间的后移，新闻的热度不断发生变化，对应的推荐抽选池排序也在不断地发生变化。最终新闻热度对应的计算公式为： 但这里需要考虑三个因素： 新闻的初始热度应该不一致 用户的行为规则应该发生变化 热度随时间衰减的趋势非线性 其他上下文特征信息上述介绍了时间、地域和热度信息在推荐系统中的应用。但在实际的应用环境中，上下文信息更加丰富（如用户使用的客户端、用户的性别、天气、用户调用接口的次数、推荐商品的位置等），这些信息在很大程度上影响用户浏览物品时的心情和兴趣。 在实际的建模应用过程中，如果能够正确地使用这些信息，可提高推荐系统的效率。 文中的相关疑问和更详细的介绍都可以在《推荐系统开发实战》一书中找到答案。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之基于用户行为特征的推荐算法介绍和案例实战开发","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之基于用户行为特征的推荐算法介绍和案例实战开发","date":"2019-07-14T15:02:04.000Z","updated":"2019-10-14T06:42:35.670Z","comments":true,"path":"2019/07/14/RecSys/推荐系统开发实战/《推荐系统开发实战》之基于用户行为特征的推荐算法介绍和案例实战开发/","link":"","permalink":"http://thinkgamer.cn/2019/07/14/RecSys/推荐系统开发实战/《推荐系统开发实战》之基于用户行为特征的推荐算法介绍和案例实战开发/","excerpt":"推荐系统的受众对象为用户，只有明白用户的意图，才能给用户推荐更好的内容。基于用户行为特征的推荐，其实在真正的“个性化推荐系统”诞生之前就已经存在了。最简单的就是各种排行榜，它们基于简单的用户统计，又对其他选择提供一定的指引。","text":"推荐系统的受众对象为用户，只有明白用户的意图，才能给用户推荐更好的内容。基于用户行为特征的推荐，其实在真正的“个性化推荐系统”诞生之前就已经存在了。最简单的就是各种排行榜，它们基于简单的用户统计，又对其他选择提供一定的指引。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/95302470博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 用户行为分类用户行为分为两种——显性反馈行为和隐性反馈行为。 显性反馈行为 显性反馈行为是指，用户很明显地表达出自己的喜好，如对内容评分、表示喜欢/不喜欢等。例如，豆瓣电影中的评分机制和YouTube中的“点赞”功能都是典型的显性反馈。 隐性反馈行为 隐性反馈行为是指，用户不明确表达出自己的喜好信息。例如，用户在京东APP中的商品浏览日志、在网易云上听歌的日志等，实际上京东和网易已经得到了一定的用户行为数据，但没有以显性方式直接反馈，而是在其他地方间接地反馈出来。 疑问：显性反馈行为 和 隐性反馈行为的区别是什么？ 基于内容的推荐算法 基于内容的推荐算法，根据用户过去一段时间内喜欢的物品，以及由此推算出来用户偏好，为用户推荐相似物品。其中的“内容”指的便是：用户过去一段时间内喜欢的物品，以及由此推算出来的用户偏好。 图5-2所示是一个基于内容推荐的例子，用户A和用户C喜欢爱情、浪漫类型的电影，用户B喜欢恐怖、惊悚的电影，因此将类型为爱情、浪漫且用户A没有行为的电影C推荐给用户A。 原理分析基于内容（Content Based，CB）的推荐原理非常简单：向用户推荐所喜欢的Item的相似Item。其中包含了三步：（1）构造Item的特征； 在真实应用场景中，往往会用一些属性描述Item的特征，这些属性通常分为以下两种： 结构化属性：意义比较明确，其取值固定在某个范围内。 非结构化属性：特性意义相对不太明确，取值没有什么限制，不可以直接使用 （2）计算Item之间的相似度； 在确定好Item的特征和用户的偏好模型后，需要计算两个Item间的相似度。根据具体场景，往往需要使用不同的相似度计算方法。 疑问：相似度计算方法有哪些？ （3）评判用户是否喜欢某个Item。 在推荐算法中评判用户是否喜欢某个Item就是：利用监督学习或非监督学习的方法，来评判用户喜欢哪些Item，不喜欢哪些Item，从而根据用户的喜好，为他生成一个偏好模型，进而对未知的Item进行喜好评判。 在基于内容的推荐算法中，使用的则是监督学习，利用用户对Item的已知评分和Item所属的类别，学习得到用户对每种类型的偏好程度，然后结合Item的类别特征计算用户对Item的偏好程度。 疑问：监督学习和非监督学习的区别？ 实际案例利用基于内容的推荐算法编写一个电影推荐系统，当用户在浏览某部电影时，为其推荐所浏览电影的相似电影。其实现步骤如下： 构建电影的特征信息矩阵 构建用户的偏好信息 计算用户与每部电影的距离 介于篇幅原理这里的具体实现步骤和代码不再赘述，欢迎关注《推荐系统开发实战》一书。 基于近邻的推荐算法基于近邻的推荐算法是比较基础的推荐算法，在学术界和工业界应用十分广泛。这里讨论的基于近邻的推荐算法指的是协同过滤（Collaborative Filtering）算法。基于近邻的协同过滤推荐算法分为： 基于用户的协同过滤（User-CF-Based）算法 基于物品的协同过滤（Item-CF-Based）算法 关于协同过滤，一个最经典的例子就是看电影：有时不知道哪一部电影是我们喜欢的或评分比较高的，通常的做法就是问问周围的朋友，看看最近有什么好的电影推荐。在询问时，都习惯于问与自己品味差不多的朋友，这就是协同过滤的核心思想。 UserCF算法原理分析基于用户的协同过滤通过用户的历史行为数据发现用户喜欢的物品，并对这些偏好进行度量和打分，然后根据不同用户对相同物品的评分或偏好程度来评测用户之间的相似性，对有相同偏好的用户进行物品推荐。 简单地讲，基于用户的协同过滤就是给用户推荐“和他兴趣相投的其他用户”喜欢的物品。 图5-5所示是一个基于用户的协同过滤推荐的例子，用户A和用户C同时喜欢电影A和电影C，用户C还喜欢电影D，因此将用户A没有表达喜好的电影D推荐给用户A。 又如，现在有A、B、C、D四个用户，分别对a、b、c、d、e五个物品表达了自己喜好程度（通过评分的高低来表现自己的偏好程度高低），现在要为C用户推荐物品：（1）计算得到C用户的相似用户；（2）找到这些相似用户喜欢的但C没有进行过评分的物品并推荐给C。 实际案例利用UserCF编写一个电影推荐系统，根据被推荐用户的相似用户的喜好，为被推荐用户推荐电影。 介于篇幅原理这里的具体实现步骤和代码不再赘述，欢迎关注《推荐系统开发实战》一书。 ItemCF算法原理分析基于物品的协同过滤推荐则通过不同对item的评分来评测item之间的相似性，从而基于item的相似性做推荐。 简单地讲就是，给用户推荐他之前喜欢物品的相似物品。 从原理上理解可以得知：基于item的协同过滤推荐和被推荐用户的偏好没有直接关系。例如，用户A买了一本书a，那么会给用户A推荐一些和书a相似的书。这里要考虑的是如何衡量两本书的相似度。 图5-8所示是一个基于物品的协同过滤推荐的例子，用户C喜欢电影A，电影C和电影A相似，那么便把用户C没有表达喜好的电影C推荐给用户C。 实际案例利用ItemCF算法编写一个推荐系统，当用户进行电影浏览时，向用户推荐和该部电影相似的电影。 介于篇幅原理这里的具体实现步骤和代码不再赘述，欢迎关注《推荐系统开发实战》一书。 对比分析UserCF与ItemCF从用适用场景、推荐系统多样性、用户特点对推荐的影响三方面来分析下两者的对比。 在适用场景上的比较ItemCF算法利用物品间的相似性来推荐，所以当用户数量远远超过物品数量时，可以考虑使用ItemCF算法。例如，购物网站和技术博客网站的商品或文章数据相对稳定，因此计算物品相似度时不但计算量小，而且不必频繁进行更新。 UserCF算法利用用户间的相似性来推荐，所以当物品数量远远超过用户数量时，可以考虑UserCF算法。UserCF算法更适合新闻类和短视频类等快消素材网站。例如，在社交网站中，UserCF是一个不错的选择，而且可解释性也更强。因为这类网站的内容更新比较频繁，且用户更加注重社会化热点。 举例：略～ 在推荐系统多样性上的比较单用户的多样性方面：ItemCF算法不如UserCF算法多样性丰富。因为，ItemCF算法推荐的是和之前有行为物品的相似物品，物品覆盖面比较小，丰富度低。 系统的多样性方面：ItemCF算法的多样性要远远好于UserCF算法。因为，UserCF算法更加注重推荐热门物品。 ItemCF算法的推荐有很好的新颖性，容易发现并推荐长尾里的物品。所以大多数情况下，ItemCF算法的精度稍微小于UserCF算法。如果考虑多样性，ItemCF算法比UserCF算法好很多。而ItemCF算法只推荐A领域给用户，这样有限的推荐列表中就可能包含了一定数量的不热门的长尾物品。 由于UserCF算法经常推荐热门的物品，所以它在推荐长尾里的物品方面能力不足。 在用户特点上的比较（1）UserCF算法推荐的原则是“假设用户喜欢那些和他有相同喜好的用户喜欢的东西”。但是，如果用户暂时找不到兴趣相同的邻居，那么基于用户的推荐效果就打了大打折扣了。因此，用户是否适应UserCF，与“他有多少邻居”是成正比的。（2） 基于物品的协同过滤算法的前提是“用户喜欢和他以前购买过的物品类型相同的物品”，可以计算一个用户喜欢的物品的自相似度。 一个用户喜欢物品的自相似度大，即用户喜欢的物品的相关度大，则说明他喜欢的东西是比较相似的。即，这个用户比较符合ItemCF算法的基本假设，他对ItemCF算法的适应度比较好。 反之，如果自相似度小，即用户喜欢物品的相关度小，就说明这个用户的喜好习惯并不满足ItemCF算法的基本假设，那么用ItemCF算法所做出的推荐对于这种用户来说效果可能不是很好。基于内容与基于近邻基于内容（Content-Based，CB）的推荐算法和基于物品（Item-Based，IB）的协同过滤算法十分相似，因为两种算法都在Item的基础上进行相似度计算。但是两者基于的Item特征是不一样的： 基于内容的推荐算法中，计算用户相似度用的是Item本身的特征。 基于物品的协同过滤算法中，则用“用户对Item的行为”来构造Item的特征。 举例：略～ 基于隐语义模型的推荐算法原理分析从矩阵的角度来理解，LFM原理矩阵表示图如图5-12所示。 R矩阵表示用户对物品的偏好信息。其中，R_ij代表User i对Item j的兴趣度。 P矩阵表示用户对各物品类别的一个偏好信息。其中，P_ij代表User i对Class j的兴趣度。 Q矩阵表示各个物品归属到各个类别的信息。其中，Q_ij代表Item j在Class i中的权重或概率。隐语义模型就是要将矩阵R分解为P和Q的乘积，即通过矩阵中的物品类别（Class）将用户User和物品Item联系起来。实际上需要根据用户当前的物品偏好信息R进行计算，从而得到对应的矩阵P和矩阵Q。从上述矩阵转换关系中可以得到隐语义模型计算用户对物品兴趣度的公式：其中参数说明如下。 Pu,k：用户u兴趣和第k个隐类的关系。 Qi,k：第k个隐类和物品i的关系。 k：隐类的数量。 R：用户对物品的兴趣度。 疑问：LFM解决的问题是什么？LFM的样本集问题？LFM的推导？LFM的优缺点？请持续关注《推荐系统开发实战》 实际案例编写一个基于隐语义模型的电影推荐系统。当用户在浏览电影并表达自己的兴趣后，系统向用户推荐用户可能喜欢的电影。其实现思路如下：（1）初始化用户对每个隐分类的兴趣度矩阵P，以及每个物品与每个隐分类的匹配程度矩阵Q；（2）根据训练数据集指定损失函数，迭代更新矩阵P和Q；（3）使用测试机对模型结果进行测试。 由于篇幅原因，具体的代码实现和过程，这里不过多介绍，请参考《推荐系统开发实战》 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之推荐系统的灵魂伴侣-数据挖掘","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之推荐系统的灵魂伴侣-数据挖掘","date":"2019-07-12T00:04:04.000Z","updated":"2019-10-14T06:42:35.670Z","comments":true,"path":"2019/07/12/RecSys/推荐系统开发实战/《推荐系统开发实战》之推荐系统的灵魂伴侣-数据挖掘/","link":"","permalink":"http://thinkgamer.cn/2019/07/12/RecSys/推荐系统开发实战/《推荐系统开发实战》之推荐系统的灵魂伴侣-数据挖掘/","excerpt":"个性化推荐是数据挖掘（Data Mining）中的一个目的明确的应用场景，所以，可以利用数据挖掘技术为推荐系统做一些基本工作，如了解数据、异常值处理、对用户群进行分类、对物品的价格进行聚类、构建用户的价格段偏好等，从而让推荐系统能够“千人千面”。本篇文章主要介绍一下常见的数据挖掘算法应用案例。","text":"个性化推荐是数据挖掘（Data Mining）中的一个目的明确的应用场景，所以，可以利用数据挖掘技术为推荐系统做一些基本工作，如了解数据、异常值处理、对用户群进行分类、对物品的价格进行聚类、构建用户的价格段偏好等，从而让推荐系统能够“千人千面”。本篇文章主要介绍一下常见的数据挖掘算法应用案例。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/95162286博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 数据预处理数据预处理（Data Preprocessing）是指：在使用数据进行建模或分析之前，对其进行一定的处理。真实环境中产生的数据往往都是不完整、不一致的“脏数据”，无法直接用来建模或进行数据分析。为了提高数据挖掘质量，需要先对数据进行一定的处理。 常见的数据预处理包括：标准化、离散化、抽样、降维、去噪等。 数据标准化数据标准化（Normalization）是指：将数据按照一定的比例进行缩放，使其落入一个特定的小区间。其中，最典型的就是数据的归一化处理，即将数据统一映射到0～1之间。 数据标准化的好处有：加快模型的收敛速度，提高模型的精度。 常见的数据标准化方法包括： Min-Max标准化Min-Max标准化是指对原始数据进行线性变换，将值映射到[0,1]之间。其计算公式为：式中，x为原始数据中的一个数据，x_min表示原始数据中的最小值，x_max表示原始数据中的最大值，x’为Min-Max标准化后的数据。 Z-Score标准化Z-Score（也叫Standard Score，标准分数）标准化是指：基于原始数据的均值（mean）和标准差（standard deviation）来进行数据的标准化。Z-Score标准化的计算公式为： 式中，x为原始数据中的一个数据，μ表示原始数据的均值，σ表示原始数据的标准差，x'为Z-Score标准化后的数据。 - 小数定标（Decimal scaling）标准化 小数定标标准化是指：通过移动小数点的位置来进行数据的标准化。小数点移动的位数取决于原始数据中的最大绝对值。小数定标标准化的计算公式为： 例如，一组数据为[-309, -10, -43,87,344,970]，其中绝对值最大的是970。为使用小数定标标准化，用1000（即j=3）除以每个值。这样，-309被标准化为-0.309，970被标准化为0.97。 均值归一化法均值归一化是指：通过原始数据中的均值、最大值和最小值来进行数据的标准化。均值归一化法的计算公式为： 向量归一化向量归一化是指：通过用原始数据中的每个值除以所有数据之和来进行数据的标准化。向量归一化的计算公式为： 指数转换指数转换是指：通过对原始数据的值进行相应的指数函数变换来进行数据的标准化。常见的函数方法有lg函数、Softmax函数和Sigmoid函数。 由于篇幅原因，数据标准化的具体实现不贴代码了，可在《推荐系统开发实战》一书中找到找到！ 数据离散化数据离散化（也叫数据分组）是指将连续的数据进行分组，使其变为一段段离散化的区间。根据离散化过程中是否考虑类别属性，可以将离散化算法分为有监督算法和无监督算法两类。由于有监督算法（如基于熵进行数据的离散化）充分利用了类别属性的信息，所以在分类中能获得较高的正确率。常见的数据离散化方法有以下几种： 等宽分组 等频分组 单变量分组 基于信息熵分组 由于篇幅原因，基于信息熵的数据离散化实例这里贴代码了，可在《推荐系统开发实战》一书中找到! 数据抽样数据抽样也叫数据采样。数据抽样是选择数据子集对象的一种常用方法。 在统计学中，抽样的目的是实现数据的调查和分析。 在数据挖掘中，抽样的目的是压缩数据量，减小数据挖掘算法的资源开销。 在数据挖掘中，抽样主要是从海量数据中产生训练集（Train Set）、测试集（Test Set）和验证集（Validation Set）。训练集、测试集和验证集三者的区别如下： 训练集用来进行模型训练。 测试集用来衡量模型的一些统计指标，如准确率、召回率等。在训练模型的过程中不允许使用测试集，否则会导致模型过拟合。验证集用来验证模型、辅助构建模型。在使用机器学习算法时，验证集是可选的。 “过拟合”表示：模型学习特征过于彻底时，噪声数据也会进入模型，导致后期测试时不能很好地识别数据，泛化能力太差。“欠拟合”表示：没有很好地捕捉到数据特征，不能很好地拟合数据。 常见的数据抽样方法包括： 随机抽样 分层抽样 系统抽样 渐进抽样 数据降维在构建机器学习模型时，有时特征是极其复杂的，当特征的维度达到几千维时，模型训练将会耗费大量的时间。另外，如果特征较多，还会出现多重共线性、稀疏性的问题。因此，需要简化属性、去噪、去冗余，以求取更典型的属性，但同时又希望不损失数据本身的意义，这时就需要对特征进行降维。 数据降维分为线性降维和非线性降维。 线性降维：分为主成分分析（PCA）、线性判断分析（LDA）。 非线性降维：分为基于核函数的KPCA、KICA、KDA和基于特征值的ISOMAP、LLE、LE、LPP、LTSA、MVU等。 数据清理“脏数据”对算法模型的直接影响是不能被使用，间接影响是降低模型的精度。这种情况下就需要对数据进行清理，包括（但不局限于）：不合格数据修正、缺失值填充、噪声值处理、离群点处理。 不合格数据修正 缺失值填充 噪声值处理 离群点处理相似度计算相似度计算在数据挖掘和推荐系统中有着广泛的应用场景。例如： 在协同过滤算法中，利用相似度计算用户之间或物品之间的相似度。 在利用k-means进行聚类时，利用相似度计算公式计算个体到簇类中心的距离，进而判断个体所属的类别。 利用KNN进行分类时，利用相似度计算个体与已知类别之间的相似性，从而判断个体所属的类别等。下面将依次介绍常见的相似度计算方法。 欧式距离 曼哈顿距离 切比雪夫距离 马氏距离 夹交余弦距离 杰卡德相似系数与杰卡德距离 相关系数与相关距离数据分类分类算法是数据挖掘中常用的基本算法之一，属于有监督学习算法（Supervised Learning）。在实际应用场景中，往往利用分类算法对基础数据进行处理，或者做一些基础模型供推荐系统使用。KNN算法KNN算法的原理和具体的代码实现，这里不过多介绍，可参考《推荐系统开发实战》 KNN是一个分类算法，但可以使用KNN的原始算法思路进行推荐，即，为每个内容或物品寻找K个与其最相似的内容或物品，然后推荐给用户。例如，在一个简单的电商网站中，用户浏览了一本图书，则推荐系统会依据图书的一些性质特征为用户推荐前 K个与该图书最相似的图书。 对性别进行预测在电商网站中也常用到。某些用户在填写注册信息时并没有注明性别，或者填写的数据不正确。如果在性别未知的情况下进行商品推荐，则容易将男性商品推荐给女性，或者将女性商品推荐给男性。这种情况下就需要对用户性别进行判定。这时候KNN算法就可以被派上用场了。 决策树在点击率预估场景中我们经常使用的GBDT/XGBoost，其底层也是一棵棵决策树。了解决策树的算法和原因对我们后续学习GBDT也是很重要的。决策树（Decision Tree）是根据一系列规则对数据进行分类的过程。分为回归决策树和分类决策树。 回归决策树是对连续变量构建决策树。 分类决策树是对离散变量构建决策树。其中分类决策树的代表为ID3算法，C4.5和CART既可构建分类决策树也可以构建回归决策树。 朴素贝叶斯算法在电商网站中，往往会存在一些异常用户，包括恶意刷单用户、爬虫爬取数据的用户等。这些异常用户产生的数据信息在推荐场景中往往是没有用的，即所说的“脏数据”。那么在准备推荐算法相关数据时，应过滤掉这些异常用户所产生的数据。 这个时候就可以使用贝叶斯算法了，贝叶斯算法是一类算法的总称，这些算法均以贝叶斯定理为基础。 贝叶斯理论是以18世纪的一位神学家托马斯•贝叶斯（Thomas Bayes）的名字命名的。通常，在事件B已经发生的前提下事件A发生的概率，与事件A已经发生的前提下事件B发生的概率是不一样的，然而这两者是有关系的。贝叶斯定理就是针对这种关系所做的陈述。 P(A|B)表示在事件B已经发生的前提下事件A发生的概率。其基本求解公式为： 贝叶斯定理便是基于条件概率的等式定理，其计算公式如下： 特征独立性假设是指，假设每个特征之间是没有联系的，朴素贝叶斯算法则是建立在这样的基础之上的。 朴素贝叶斯算法有三种常见模型： 多项式模型 高斯模型 伯努利模型。数据聚类聚类算法也是数据挖掘中常用的基本算法之一，属于无监督学习算法（Unsupervised Learning）。在实际应用场景中，会利用聚类算法对基础数据进行处理，或者做一些基础模型供推荐系统使用。K-means算法在电商网站中，商品的数目很多，对应的商品价格也很多。但对于用户来讲，并不是对所有价格的商品都感兴趣。例如，一个经常网购1000元左右手机的用户，通常没必要向他推荐价格超过5000元的手机。 所以，需要对商品的价格进行聚类，进而求出用户感兴趣的价格段，从而提高推荐系统的准确度和可信赖度。 这时候基于kMeans算法进行商品价格聚类算法就随之产生了。 kMeans（K均值聚类算法）的基本原理是：（1）随机初始化K个初始簇类中心，对应K个初始簇类，按照“距离最近”原则，将每条数据都划分到最近的簇类；（2）第一次迭代之后，更新各个簇类中心，然后进行第二次迭代，依旧按照“距离最近”原则进行数据归类；（3）直到簇类中心不再改变，或者前后变化小于给定的误差值，或者达到迭代次数，才停止迭代。 具体的执行步骤如下：（1）在数据集中初始K个簇类中心，对应K个初始簇类；（2）计算给定数据集中每条数据到K个簇类中心的距离；（3）按照“距离最近”原则，将每条数据都划分到最近的簇类中；（4）更新每个簇类的中心；（5）迭代执行步骤（2）～步骤（4），直至簇类中心不再改变，或者变化小于给定的误差区间，或者达到迭代次数；（6）结束算法，输出最后的簇类中心和对应的簇类。 二分-Kmeans算法二分-kMeans算法（二分-K均值聚类算法）是分层聚类（Hierarchical Clustering）的一种，是基于kMeans算法（K-均值聚类算法）实现的。 在二分-kMeans算法中，调用kMeans（k =2）把一个簇类分成两个，迭代此过程，直至分成k个。其实现的具体思路为：（1）初始化簇类表，使之包含所有的数据；（2）对每一个簇类应用k均值聚类算法（k = 2）；（3）计算划分后的误差，选择所有被划分的聚簇中总误差最小的并保存；（4）迭代步骤（2）和步骤（3），簇类数目达到K后停止。 相对于kMeans算法，二分-kMeans的改进点有以下两点： 加速了kMeans的执行速度，减少了相似度的计算次数； 能够克服“kMeans收敛于局部最优”的缺点。 关联分析关联分析的目的是，找到具有某种相关性的物品。这种分析在推荐系统中也有很大的作用，如经常出现在一个购物篮中的商品就可以相互推荐。关联算法最常见的就是Apriori。 该算法中涉及的一些概念解释为： 关联分析（Association Analysis）：从大规模数据集中寻找商品的隐含关系。 项集（Item Set）：包含0个或多个项的集合。 频繁项集：那些经常一起出现的物品集合。 支持度计数（Support Count）：一个项集出现的次数（即，整个交易数据集中包含该项集的事物数）。 项集支持度：一个项集出现的次数与数据集所有事物数的百分比，计算公式如下： 项集置信度（confidence）：数据集中同时包含A、B的百分比，计算公式如下： Apriori算法使用一种称为逐层搜索的迭代方法，其中k项集用于探索（k+1）项集（如使用频繁1项集找到频繁2项集），其实现过程如下： （1）通过扫描数据库，累计每个项的计数，并收集满足最小支持度的项，找出频繁1项集的集合。该集合记作L1； （2）使用L1找出频繁2项集的集合L2，使用L2找出L3； （3）如此下去，直至不能再找到频繁k项集，每找出一个Lk需要一次完整的数据库扫描。 数据挖掘在推荐系统中的应用非常广泛，无论是数据预处理还是基础模型开发，他都发挥着举足轻重的作用，因此在理解推荐算法的同时，对数据挖掘也要进行一定程度的掌握。关于文中的更多详细内容请持续关注《推荐系统开发实战》 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之从搭建一个电影推荐系统开始学推荐系统开发实战","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之从搭建一个电影推荐系统开始学推荐系统开发实战","date":"2019-07-10T15:46:04.000Z","updated":"2019-10-14T06:42:35.668Z","comments":true,"path":"2019/07/10/RecSys/推荐系统开发实战/《推荐系统开发实战》之从搭建一个电影推荐系统开始学推荐系统开发实战/","link":"","permalink":"http://thinkgamer.cn/2019/07/10/RecSys/推荐系统开发实战/《推荐系统开发实战》之从搭建一个电影推荐系统开始学推荐系统开发实战/","excerpt":"推荐系统在我们的生活中无处不在，比如购物网站，视频音乐网站，新闻网站等，那么推荐系统是如何工作的，他是基于什么方式实现的？可以在《推荐系统开发实战》这本书中进行系统的了解和学习，本篇文章是该系列文章的开篇之作，带领大家认识一下基于最近相似用户的推荐。以下内容摘自于《推荐系统开发实战》","text":"推荐系统在我们的生活中无处不在，比如购物网站，视频音乐网站，新闻网站等，那么推荐系统是如何工作的，他是基于什么方式实现的？可以在《推荐系统开发实战》这本书中进行系统的了解和学习，本篇文章是该系列文章的开篇之作，带领大家认识一下基于最近相似用户的推荐。以下内容摘自于《推荐系统开发实战》 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/93927941博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 嗨，Susan，最近有什么好看的电影吗？ Thinkgamer，我觉得《芳华》不错，推荐你可以去看下。 这样的场景相信我们会经常遇到，当我们不知道要看哪部电影时，会咨询一下身边的朋友，从他们那里得到一些意见。当我们在咨询别人时，往往会有自己的判断，Thinkgamer喜欢文艺片，他不会去征求喜欢动画片的Jake，但是他会去咨询同样喜欢文艺片的Susan。 基于上边的描述，我们可以总结出UserCF的算法过程： 计算用户相似度 寻找给定用户最相近的K个用户 将K个用户喜欢的且给定用户没有行为的物品推荐给给定用户 简单的讲就是：给用户推荐“和他兴趣相投的其他用户”喜欢的物品。 上图所示是一个基于用户的协同过滤推荐的例子，用户A和用户C同时喜欢电影A和电影C，用户C还喜欢电影D，因此将用户A没有表达喜好的电影D推荐给用户A。 针对上述过程，可以分为以下步骤： 构建用户物品评分表假设用户与物品所表达的喜好程度（即评分），如下表所示： 用户 物品a 物品b 物品c 物品d 物品e A 3.0 4.0 0 3.5 0 B 4.0 0 4.5 0 3.5 C 0 3.5 0 0 3 D 0 4 0 3.5 3 相似度计算计算用户之间相似度的方法有很多，这里选用的是余弦相似度，如下： 针对用户u和v，上述公式中的参数如下。 N(u)：用户u有过评分的物品集合； N(v)：用户v有过评分的物品集合； Wuv：用户u和用户v的余弦相似度。 结合上表，可以分别求得用户C和其他三个用户的相似度，见下面三公式： 从计算结果来看，D用户与C用户相似度最大。 从表中也可以直接看出，用户D和C都在b和e物品上进行了评分，用户A、B和C也都在b物品上进行了评分。 ## 计算推荐结果 用户C进行评分的物品是b和e，接下来计算用户C对物品a、c、d的偏好程度，见下面三公式： 从上面的计算可以得到，在用户C没有进行评分的物品中倒序排列为a→c→e。这样就可以根据需要取前 K个物品推荐给C用户。 完整代码可参考《推荐系统开发实战》 ## 算法复杂度优化 但是上面的计算存在一个问题——需要计算每一对用户的相似度。代码实现对应的时间复杂度为O(|U|*|U|)，U为用户个数。 在实际生产环境中，很多用户之间并没有交集，也就是并没有对同一样物品产生过行为，所以很多情况下分子为0，这样的稀疏数据就没有计算的必要。 上面的代码实现将时间浪费在计算这种用户之间的相似度上，所以这里可以进行优化： （1）计算出的用户对（u，v）； （2）对其除以分母得到u和v的相似度。 针对以上优化思路，需要两步： （1）建立物品到用户的倒排表T，表示该物品被哪些用户产生过行为； （2）根据倒查表T，建立用户相似度矩阵W： - 在T中，对于每个物品i，设其对应的用户为j、k， - 在W中，更新对应位置的元素值，W[j][k]=W[j][k]+1，W[k][j]=W[k][j]+1。 以此类推，这样在扫描完倒查表T之后，就能得到一个完整的用户相似度矩阵W了。 这里的W对应的是前面介绍的余弦相似度中的分子部分，然后用W除以分母，便能最终得到两个用户的兴趣相似度。 以上表为例，总共有4个用户，那么要建一个4行4列的倒排表，具体建立过程如下： （1）由用户的评分数据得到每个物品被哪些用户评价过，如图5-6所示。 （2）建立用户相似度矩阵W，如图5-7所示。 得到的相似度矩阵W对应的是计算两两用户相似度的分子部分，然后除以分母得到的便是两两用户的相似度。 还是以C用户为例。从图5-7可知，A、B用户与C用户相似度计算的分子都为1，D用户与C用户相似度计算的分子部分为2。其他用户与C用户的相似度计算如下： 得到用户的相似度之后，就可以计算用户对未评分物品的可能评分了。采用的计算方式依旧是： 其中各参数说明如下。 P(u,i)：用户u对物品i的感兴趣程度； S(u,K)：和用户u兴趣最接近的K个用户； N(i)：对物品i有过行为的用户集合； Wuv：用户u和用户v的兴趣相似度； rvi：用户v对物品i的兴趣，即用户对物品的评分。依据上式，分别计算用户C对物品a、c、d的可能评分：同样，对比优化前后的计算可知，结果是一致的。 具体的代码实现可参考：《推荐系统开发实战》一书。 惩罚热门物品如果两个用户都买过《新华字典》，这并不能说明他们兴趣相同，因为绝大多数中国人都买过《新华字典》。但如果两个用户都买过《机器学习实战》，那可以认为他们的兴趣比较相似，因为只有研究机器学习的人才可能买这本书。因此，John S. Breese在论文中提出了式（5.4），根据用户行为计算用户的兴趣相似度： 分子中的倒数部分，惩罚了用户u和用户v共同兴趣列表中热门物品，减小了热门物品对用户相似度的影响。 N(i)是对物品i有过行为的用户集合。物品i越热门，N(i)越大。 对此，修改用户相似度的计算方式，具体的代码实现如函数userSimilarityBest()所示。 具体的代码实现可参考：《推荐系统开发实战》一书。 案例实战在了解完UserCF的算法原理之后，来开发一个电影推荐系统。这里我们选用的MovieLens数据集，该数据集在《实战》一书中的第三章有详细介绍。 搭建一个推荐系统的步骤包括： 准备数据 选择算法 模型训练 效果评估 这里不过多进行介绍，欢迎关注小编图书。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：文中多次提到的《推荐系统开发实战》是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"《推荐系统开发实战》之推荐系统的前世今生与古往今来","slug":"RecSys/推荐系统开发实战/《推荐系统开发实战》之推荐系统的前世今生与古往今来","date":"2019-07-10T00:03:04.000Z","updated":"2019-10-14T06:42:35.670Z","comments":true,"path":"2019/07/10/RecSys/推荐系统开发实战/《推荐系统开发实战》之推荐系统的前世今生与古往今来/","link":"","permalink":"http://thinkgamer.cn/2019/07/10/RecSys/推荐系统开发实战/《推荐系统开发实战》之推荐系统的前世今生与古往今来/","excerpt":"接下来将会用10篇文章介绍下推荐系统的起源，应用，算法和案例，并带领大家从0到1实现属于自己的推荐系统。本篇文章为该系列文章的第一篇，不会涉及具体的技术，用科普的形式让大家对推荐系统有一个感性的认识。","text":"接下来将会用10篇文章介绍下推荐系统的起源，应用，算法和案例，并带领大家从0到1实现属于自己的推荐系统。本篇文章为该系列文章的第一篇，不会涉及具体的技术，用科普的形式让大家对推荐系统有一个感性的认识。 推荐系统在我们的生活中应用的非常广泛，无论是生活，娱乐，工作都会或多或少的涉及一些，接下来将会整理一个系列的文章，介绍一下推荐系统，并从0到1的去实现一个推荐系统，本篇内容主要涉及的是推荐系统的背景发展和开发一个自己的推荐系统需要掌握的技能和知识。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/95116871博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 前世“啤酒”与“尿布”的故事对推荐系统的学习有着积极的影响。从该故事出发，我们依旧能看到从20世纪90年代到现在个性化推荐系统的演进和发展。 “啤酒与尿布”的故事相信很多人都知道。它讲述的是20世纪90年代，在美国沃尔玛超市中，管理人员分析数据时，发现了一个奇怪的现象：在某些特定的情况下，“啤酒”与“尿布”两件看上去毫无关系的商品出现在了同一个购物篮中。这种独特的销售现象引起了管理人员的注意，经过后续调查发现，一些年轻的爸爸常到超市去购买婴儿尿布，有30％～40％的新爸爸，会顺便买点啤酒犒劳自己。随后，沃尔玛对啤酒和尿布进行了捆绑销售，不出意料，销售量双双增加。 该案例出自于涂子沛先生的《数据之巅》一书。在这个案例中，数据和情节让这个故事不容置疑，然而据吴甘沙先生透漏，该案例是TeraData公司一位经理编出来的“故事”。目的是让数据分析看起来更有力，更有趣。在历史上该案例并没有出在美国的任何一个沃尔玛超市中。虽然这个“故事”是杜撰的，但其中涉及的“捆绑销售”却不失为一种购物推荐。物品A与物品B经常出现在一个购物篮中，那么向购买物品A（物品B）的人推荐物品B（物品A）是有数据依据和理论基础的。依据该理论，后来衍生出了关联规则算法，很多电商类或者视频类的网站都使用到该类算法进行商品或者视频的推荐。 今生在19世纪和20世纪，推荐系统在互联网这片肥沃的土壤中得到了充分的发展，如今已经在各个公司开发结果。以下列了一些有代表性的发展点： Xerox公司在1992年设计的应用协同过滤算法的邮件系统——Tapestry。同年，Goldberg提出了“推荐系统”这个概念。 1994年，明尼苏达大学的GroupLens研究组使用基于主动协同过滤的推荐算法，开发了第一个自动化推荐系统 GroupLens，并将其应用在Usenet新闻组中。 1996年，卡内基梅隆大学的Dunja Mladenic在Web Watcher的基础上进行了改进，提出了个性化推荐系统Personal Wgb Watchero。1996年，著名的网络公司Yahoo也注意到了个性化服务的巨大优势和潜在商机，推出个性化入口MyYahoo。 1997年，Resnick和Varian首次在学术届正式提出推荐系统的定义。他们认为：推荐系统可以帮助电子商务网站向用户提供商品和建议，促成用户的产品购买行为，模拟销售人员协助客户完成购买过程。 1998年，亚马逊（Amazon.com）上线了基于物品的协同过滤算法，将推荐系统的规模扩大至服务千万级用户和处理百万级商品，并带来了良好的推荐效果。 2003年，亚马逊（Amazon.com）的Linden等人发表论文，公布了“基于物品的协同过滤算法”。 2005年，Adomavicius等人发表综述论文，将推荐系统分为3类——基于内容的推荐、基于协同过滤的推荐和混合推荐，并提出了未来可能的主要研究方向。 2006年10月，北美在线视频服务提供商 Netflix 宣布了一项竞赛，任何人只要能够将它现有电影推荐算法 Cinematch 的预测准确度提高10%，就能获得100万美元的奖金。 2007年，第一届ACM推荐系统大会在美国举行，到2017年已经是第11届。这是推荐系统领域的顶级会议，展示了推荐系统在不同领域的最近研究成果、系统和方法。 2016年，YouTube发表论文，将深度神经网络应用推荐系统中，实现了从“大规模可选的推荐内容”中找到“最有可能的推荐结果”。 2018年，阿里巴巴提出论文《基于注意力机制的用户行为建模框架以及在推荐领域的应用（ATRank）》，被AAAI录用。 用途推荐系统已经广泛存在于我们的生活之中，其主要应用场景如下： 电商类（京东/淘宝/拼多多…） 社交类（微博/微信/豆瓣…） 音乐类（网易云音乐/QQ音乐/虾米…） 视频类（YouTube/爱奇艺/腾讯视频…） 阅读类（头条/知乎/书旗…） 服务类（美团/饿了么/口碑…） 技术栈目前工业界所使用的推荐系统整个框架是比较大的，并非一个人所能完成，那么作为初学者，我们如何能够充分理解推荐算法的知识，如何自己手动开发一个推荐系统呢？ 首先是选定开发语言，Python作为使用最广泛的编程语言，当之无愧，而且py也已经成为了算法工程师的必备知识技能。同时在开发Python版本推荐系统过程中，不能缺失的是数据结构思想，不能缺失的是工程能力！ 那如何去定义一个人工程能力的好坏呢？主要从以下几方面去判断： 编码能力 强悍的编码能力，并不是说在很短的时间内完成一个业务开发，而是说在高效完成的同时能够追求代码的质量和可读性。只有同时具备高效、质量和可读性，才能说是工程能力很强。 解决问题能力 工程能力的核心在于发现问题、分析问题和解决问题。能够发现问题，说明拥有创新能力和自觉性的态度。而对于已经发生的问题，能够慎密地进行分析、定位，继而快速解决，这样才真正到了“知其然，知其所以然”的境界。 快速学习能力 计算机行业中，知识的迭代是非常快的。就好比，2014年左右Hadoop分布式计算框架是主流的，但到2017年，基于内存计算的Spark框架成了分布式处理的新宠。如果一个从业者没有很强的学习、适应和突破能力，是不行的。好的学习能力前提是：拥有一个好的学习技巧，在学习之初就明白学习的目的是什么。然后围绕该目的，列出一系列的问题，然后在学习的过程中进行解决，同时进行手动实践，总结和积累经验。 文档梳理能力 工程能力的强弱很多时候体现在文档上。是否完成过一个项目，对项目的理解是不一样的。对项目是否有深入的思考，写出的文档深浅也是不一样的。一个优秀的文档，除了对自己，对于团队、他人来说也是十分重要的。 产品质量责任心 好的工程能力还要拥有一个负责任的心。试想一下，上级交给你一个任务，你如果敷衍了事，那么你在这个岗位上是走不远的。 沟通协作 在实际的工作环境中，往往每个任务都需要多人协作完成。一个从业者，如果不懂得沟通和协作，所完成的任务必然是不能满足需求的。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 注：以上内容摘自于《推荐系统开发实战》，该书是小编近期要上的一本图书，预计本月（7月末）可在京东，当当上线，感兴趣的朋友可以进行关注！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐系统开发实战","slug":"推荐系统开发实战","permalink":"http://thinkgamer.cn/tags/推荐系统开发实战/"}]},{"title":"Thinkgamer's 简历","slug":"随缘/关于我","date":"2019-06-21T01:18:08.000Z","updated":"2019-10-14T12:28:36.845Z","comments":true,"path":"2019/06/21/随缘/关于我/","link":"","permalink":"http://thinkgamer.cn/2019/06/21/随缘/关于我/","excerpt":"个人信息I&nbsp;&nbsp;&nbsp;D：&nbsp;&nbsp;&nbsp;&nbsp;Thinkgamer邮箱：&nbsp;&nbsp;&nbsp;&nbsp;thinkgamer@163.com毕业：&nbsp;&nbsp;&nbsp;&nbsp;沈阳航空航天大学-计算机学院-软件工程就职：&nbsp;&nbsp;&nbsp;&nbsp;北京 | 某厂 | 算法工程师","text":"个人信息I&nbsp;&nbsp;&nbsp;D：&nbsp;&nbsp;&nbsp;&nbsp;Thinkgamer邮箱：&nbsp;&nbsp;&nbsp;&nbsp;thinkgamer@163.com毕业：&nbsp;&nbsp;&nbsp;&nbsp;沈阳航空航天大学-计算机学院-软件工程就职：&nbsp;&nbsp;&nbsp;&nbsp;北京 | 某厂 | 算法工程师 技术园地： CSDN：http://blog.csdn.net/gamer_gyt Github：https://github.com/Thinkgamer 知乎: https://www.zhihu.com/people/thinkgamer/activities 公众号：搜索与推荐Wiki 工作经历2017-12～2019-06 | 京东商城 个性化消息Push 简称“种草”。针对京东用户进行消息的个性化Push，增强用户黏性和交互。负责种草整个联动方案，组织会议进行讨论和需求下发，资源安排等。基于机器学习的个性化消息push模型开发，训练，调优，上线等。深度学习模型调研，基于公司内部平台，上线基于tensorflow-serving的深度学习模型，效果较ML模型提升显著。 Plus会员个性化推荐 理解内部推荐架构原理，负责开发方案，资源安排。基于机器学习的个性化消息push模型开发，训练，调优，上线等。相关CTR预估模型研究与在plus业务数据集上的离线测试。 商品价格段模型 基于KMeans构建商品价格段模型，实现了基于MR和Spark两个版本的代码。 商品质量分模型 基于线性模型构建商品质量分模型，用户推荐架构中的召回粗排。 特征监控模型 数据和特征决定了机器学习的上限,而模型和算法只是逼近这个上限。特征对于模型来说极其重要，因为对于特征的监控十分有必要，该模型支持使用者自定义监控指标和监控字段，能够有效的减少出现问题时的排查时间提高效果，并进行预警。 基础数据开发 业务内特征开发 全站特征开发 召回数据开发 2016-10～2017-12 | 北京万维星辰科技有限公司 搭建基于 Hadoop 和 ELK 技术栈的日志分析系统 参与设计了基于 ELK 的日志分析系统，提出并搭建了 Hadoop 数据备份系统，研究了 ELK 周边的开源产品 ，学习并使用 rails 实现 es 数据的快照备份。 异常检测算法研究与实现 1：根据合作方提供的 wlan 上网数据，对用户进行肖像刻画，从而对后入数据进行异常值估计。 2：研究基于指数平滑和线性回归的异常值检测，并使用 python 的 elasticsearch 进行实现。 中彩/德州银行日志审计项目 利用公司的日志分析系统对中国福利彩票和德州银行的日志进行分析，并形成安全事件，提出相应的整改和解决意见，形成月度报告。 2016-07～2016-09 | 北京广联达软件有限公司 实习以课题形式（课题为：基于质量数据的数据分析平台搭建）展开，利用 Hadoop 等开源组件搭建了 5 台分布式系统，包含 Hadoop，Hive，Spark，Zookeeper，Sqoop 和 Hbase，在该平台上完成了豆瓣影评数据分析 Demo 技能掌握 熟练掌握基于机器学习和深度学习的CTR预估算法，包括GBDT/LR/FM/FFM/FTRL/XGBoost/Wide&amp;Deep/DeepFM/DNN/FNN等。 熟悉推荐系统的数据流和过滤，召回，排序，展示等架构。 熟练掌握相关机器学习算法并用来构建基本模型。 熟练用户画像/物品画像/特征工程。 熟练Spark/MR/Hive/Python开发，了解相关大数据产品。 了解爬虫/Web后端开发，曾开发多个基于Django的网站后端。 了解强化学习/迁移学习/NLP。 熟悉ELK技术栈/Linux/Docker。 大学经历项目经历 基于 Hadoop 和机器学习的博客统计分析平台 采用 Django 作为 Web 开发基础，Python 爬取了 CSDN 博客的部分数据，存储到 hdfs 上，利用 MapReduce 对数据进行了离线计算，将解析好的字段存储到 Hive 中，利用 python 开发实现了协同过滤算法和 PangRank 算法。最终此项目在辽宁省计算机作品大赛中获得二等奖，中国大学生计算机作品大赛中获得三等奖。 图书推荐系统 python 爬取了豆瓣图书数据，对数据进行清洗之后，使用基于 Item 和 User 的协同过滤算法对登录用户产生图书推荐，此项目为大三期间为一个网友做的毕业设计。 荣誉奖励 单项一等奖学金 * 2 综合二等奖学金 * 2 单项支援服务标兵 优秀团干 * 2 辽宁省ACM优秀志愿者 校ACM三等奖 沈阳航空航天大学计算机作品大赛二等奖【网站】 辽宁省计算机作品大赛二等奖【博客统计分析系统】 中国大学生作品大赛三等奖【博客统计分析系统】 工作经历 助理辅导员 | 2014.09-2015.07 计算机学院 2014 级新生助理辅导员，协助辅导员进行大一班级的日常管理 活动部部长 | 2014.09-2015.07 爱心联合会活动部部长，负责相关活动的宣传推广与执行 班级团支书 | 2013.09-2017.06 协助辅导员进行班级日常的管理和相关共青团工作的开展 自我评价 不服输，爱钻研，具有自学能力和解决问题能力。 喜欢看书，看文章，整理笔记。 文艺Coder。 联系我： PS：加我微信，拉你进数据与算法交流群，进行头脑风暴","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"Thinkgamer","slug":"Thinkgamer","permalink":"http://thinkgamer.cn/tags/Thinkgamer/"}]},{"title":"陆月，我想说的和我要改名了！","slug":"随手记/陆月，我想说的和我要改名了！","date":"2019-06-21T01:00:00.000Z","updated":"2019-10-14T06:42:35.694Z","comments":true,"path":"2019/06/21/随手记/陆月，我想说的和我要改名了！/","link":"","permalink":"http://thinkgamer.cn/2019/06/21/随手记/陆月，我想说的和我要改名了！/","excerpt":"当你看到这篇文章的时候不要惊讶，因为我已经两个月没有发技术文章了！突然又接着更新了，不要害怕，因为这就是我，我都不确定我什么时候会发出一篇文章来。 首先要明确的是这不是一篇技术文章，只是这一段时间内我的一些胡思乱想和东拼西凑。其中不免包含了近段时间我的经历和思考，也会包含一些接下来做事的计划和思考。","text":"当你看到这篇文章的时候不要惊讶，因为我已经两个月没有发技术文章了！突然又接着更新了，不要害怕，因为这就是我，我都不确定我什么时候会发出一篇文章来。 首先要明确的是这不是一篇技术文章，只是这一段时间内我的一些胡思乱想和东拼西凑。其中不免包含了近段时间我的经历和思考，也会包含一些接下来做事的计划和思考。 转载请注明出处：https://thinkgamer.blog.csdn.net博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io 点击阅读原文 Chapter 15月和6月对我来讲其实挺难熬的，五一回家开始打算装修房子，回家了7天，每天都在奔波，终于在回京前一天把相关事情敲定。回京之后，我突然萌生了一个念头——辞职，最终这个念头在我心里生了根，发了芽，长成了参天大树。这其中有很多原因，并不是因为某一件事而促就的，不是京东不好，也不是我有多么优秀，而是纵横交错的心结最终都指向了那一个方向。 过了今天，我若再踏进这座大楼，恐怕就是以一个“访客”的身份进来了，一度秋冬，两番春夏，感恩京东带给我的成长和经历，让我自己有了一个质的改变，也很团队和老大们的帮助，鼓励，让我能够在工作和生活中得心应手。但天下没有不散的宴席，相遇是缘，再见是份，不管身处何方，心中的那份情不会忘。今日挥手，再见已是江湖。祝福彼此，逆风翻盘，涅槃重生！ 我不确定现在的我是一个怎么样的水平，我也不知道我接下来的工作会是一场怎样的经历，但是万变不离其宗，不管在哪，在接下来几年内，我要做的就是好好沉淀自己。无论是为人处事，还是工作生活，都要静下来，好好吸收一下！有时候走的太快真的不一定是好事。 转眼间已经六月了，岁月真的是一场有去无回的游戏，想想曾经自己立的那些flag，现在真的是啪啪打脸了，但无论如何，有梦固然是好的，因为有梦才有方向，没有梦你就没有方向。 过完了在这的最后一个618，就要告辞了，原谅在这个时候我做了一个“逃兵”，但无风不起浪，空穴不来风，真心希望京东能好，能够在未来的时代中站起来，做一些能够改变世界的事情，愿你不固步自封，愿你能任人唯贤，愿你能斗志昂扬，愿你能让勇士不流浪，愿你能让智者挺脊梁。愿我们都能被时光善待，都能未来可期。 Chapter 2这个公众号最早叫《码农故事多》，因为我本是一个“码农”，我喜欢旅行，喜欢摄影，喜欢写作，还喜欢敲代码，我觉得我曾经的经历颇多，如果围炉小坐，我能滔滔诉说。后来不知怎么的我又觉得这个名字很Low，没有定位，没有方向，更像是一个大杂烩，于是我思前想后，起了个《数据与算法联盟》的名字，其寓意是把大数据和算法结合起来，重塑世界！愿景很大，但其实没什么卵用，我太渺小了，渺小的像是沧海一粟，像是浩瀚宇宙中的日月星辰，我觉得我配不上这个名字。 我的新书《推荐系统开发实战》即将上市，趁着这个机会，我想把我的公众号定位到推荐系统相关的，但我们都知道，推荐，搜索，广告其实都差不太多，无非就是CTR/CVR。至于用什么技术去解决，与预估，这都可以。所以呢，我打算给我的公众号重新赋予一个名字《搜索与推荐Wiki》生效时间2019.06.22，目前小编从事的是推荐算法相关的工作，后序也会涉及搜索/文本相关的工作，后序在更新文章上也会有所选材和注重文章的连续性，之前更新文章算是随意自由的更新，但今后我会在一定程度上约束自己，希望我的读者能够和我一起进步，一起用技术改变世界！ 最后我想说的是：公号还是那个公号，只是名字变了，小编还是那个小编，只是规划更清晰了！那么你还愿意做我的读者吗？ 愿你雨天有伞，黑天有灯，余生有良人！ 感恩，祝福！ 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/tags/随手记/"}]},{"title":"Spark排序算法系列之（MLLib、ML）LR使用方式介绍","slug":"RecSys/Spark排序算法/Spark排序算法系列之（MLLib、ML）LR使用方式介绍","date":"2019-05-07T02:47:27.000Z","updated":"2019-10-14T06:42:35.664Z","comments":true,"path":"2019/05/07/RecSys/Spark排序算法/Spark排序算法系列之（MLLib、ML）LR使用方式介绍/","link":"","permalink":"http://thinkgamer.cn/2019/05/07/RecSys/Spark排序算法/Spark排序算法系列之（MLLib、ML）LR使用方式介绍/","excerpt":"【Spark排序算法系列】主要介绍的是目前推荐系统或者广告点击方面用的比较广的几种算法，和他们在Spark中的应用实现，本篇文章主要介绍LR算法。","text":"【Spark排序算法系列】主要介绍的是目前推荐系统或者广告点击方面用的比较广的几种算法，和他们在Spark中的应用实现，本篇文章主要介绍LR算法。 本系列还包括（持续更新）： Spark排序算法系列之GBDT（梯度提升决策树） Spark排序算法系列之模型融合（GBDT+LR） Spark排序算法系列之XGBoost Spark排序算法系列之FTRL（Follow-the-regularized-Leader） Spark排序算法系列之FM与FFM 背景逻辑回归（Logistic Regression，LR）是较早应用在推荐排序上的，其属于线性模型，模型简单，可以引入海量离散特征，这样的好处就是模型可以考虑更加细节或者说针对具体个体的因素。如果想要引入非线性因素需要做特征交叉，这样很容易产生百亿特征，在很早之前ctr就主要靠堆人力搞特征工程工作来持续优化效果。 虽然目前在工业界LR应用的并不多，但是对于初学者,一些中小企业或者应用场景不需要负责排序模型的时候，LR扔不失为一个不错的选择。 关于LR的算法原理，这里不做过多说明，可参考： 回归分析之逻辑回归-Logistic Regression 线性模型篇之Logistic Regression数学公式推导 LR介绍LR的数学表达式可以简写为： L(w,x,y)=log(1+exp(-yw^Tx))对于二分类模型，LR是一个分类算法，模型计算得到预测值后会通过以下函数进转化。 f(z) = \\frac{1}{1+e^{-zx}}如果L(w,x,y) &gt; 0.5 则是1 否则为0。当然在实际应用过程中，并不是一定取0.5作为界限值，而是根据实际情况进行调整。 二进制回归可以转化为多分类回归问题。关于多分类介绍和基于Spark实现多分类可参考多分类实现方式介绍和在Spark上实现多分类逻辑回归（Multinomial Logistic Regression） 在Spark.mllib包中提供了两种LR分类模型，分别是： mini-batch gradient descent（LogisticRegressionWithLBFGS） L-BFGS（LogisticRegressionWithSGD） 但官方给出的建议是：推荐使用LBFGS，因为基于LBFGS的LR比基于SGD的能更快的收敛。其原话如下： We implemented two algorithms to solve logistic regression: mini-batch gradient descent and L-BFGS. We recommend L-BFGS over mini-batch gradient descent for faster convergence. 而且LRWithLBFGS不仅支持二分类还支持多分类，但LRWithSGD只支持二分类。所以后续只介绍下Spark mllib中的LogisticRegressionWithLBFGS相关操作。 mllib中的LRWithLBFGS设置变量和创建spark对象123456789val file = \"data/sample_libsvm_data.txt\"val model_path = \"model/lr/\"val model_param = \"numInterations:5,regParam:0.1,updater:SquaredL2Updater,gradient:LogisticGradient\"val spark = SparkSession.builder() .master(\"local[5]\") .appName(\"LogisticRegression_Model_Train\") .getOrCreate()Logger.getRootLogger.setLevel(Level.WARN) 拆分数据集123// 记载数据集 并拆分成训练集和测试集val data = MLUtils.loadLibSVMFile(spark.sparkContext,file).randomSplit(Array(0.7,0.3))val (train, test) = (data(0), data(1)) LRWithLBFGS模型设置参数12345678910111213141516171819// 定义分类的数目，默认为2，是logisticregression的参数private var numClass: Int = 2// 定义是否添加截距,默认值为false，是logisticregression的参数private var isAddIntercept: Option[Boolean] = None// 定义是否在训练模型前进行验证，是logisticregression的参数private var isValidateData: Option[Boolean] = None// 定义迭代的次数，默认值是100，LBFGS的参数private var numInterations: Option[Int] = None// 定义正则化系数值，默认值是0.0，LBFGS的参数private var regParam: Option[Double] = None// 定义正则化参数，支持：L1Updater[L1]、SquaredL2Updater[L2]、SimpleUpdater[没有正则项]，LBFGS的参数private var updater: Option[String] = None// 定义计算梯度的方式，支持：LogisticGradient、LeastSquaresGradient、HingeGradient ，LBFGS的参数private var gradient: Option[String] = None// 人工定义的收敛阈值private var threshold:Option[Double]=None// 定义模型收敛阈值，默认为 10^-6private var convergenceTol: Double= 1.0e-6 创建模型123456789101112131415161718192021222324252627282930313233343536373839404142def createLRModel(model_param: String): LogisticRegressionWithLBFGS=&#123; // 设置模型参数 val optimizer = new LROptimizer() optimizer.parseString(model_param) println(s\"模型训练参数为：$&#123;optimizer.toString&#125;\") // 创建模型并指定相关参数 val LRModel = new LogisticRegressionWithLBFGS() // 设置分类数目 LRModel.setNumClasses(optimizer.getNumClass) // 设置是否添加截距 if(optimizer.getIsAddIntercept.nonEmpty) &#123;LRModel.setIntercept(optimizer.getIsAddIntercept.get)&#125; // 设置是否进行验证模型 if(optimizer.getIsValidateData.nonEmpty)&#123;LRModel.setValidateData(optimizer.getIsValidateData.get)&#125; // 设置迭代次数 if(optimizer.getNumInterations.nonEmpty)&#123;LRModel.optimizer.setNumIterations((optimizer.getNumInterations.get))&#125; // 设置正则项参数 if(optimizer.getRegParam.nonEmpty) &#123; LRModel.optimizer.setRegParam(optimizer.getRegParam.get) &#125; // 设置正则化参数 if(optimizer.getUpdater.nonEmpty)&#123; optimizer.getUpdater match &#123; case Some(\"L1Updater\") =&gt; LRModel.optimizer.setUpdater( new L1Updater()) case Some(\"SquaredL2Updater\") =&gt; LRModel.optimizer.setUpdater(new SquaredL2Updater()) case Some(\"SimpleUpdater\") =&gt; LRModel.optimizer.setUpdater(new SimpleUpdater()) case _ =&gt; LRModel.optimizer.setUpdater(new SquaredL2Updater()) &#125; &#125; // 设置梯度计算方式 if(optimizer.getGradient.nonEmpty)&#123; optimizer.getGradient match &#123; case Some(\"LogisticGradient\") =&gt; LRModel.optimizer.setGradient(new LogisticGradient()) case Some(\"LeastSquaresGradient\") =&gt; LRModel.optimizer.setGradient(new LeastSquaresGradient()) case Some(\"HingeGradient\") =&gt; LRModel.optimizer.setGradient(new HingeGradient()) case _ =&gt; LRModel.optimizer.setGradient(new LogisticGradient()) &#125; &#125; // 设置收敛阈值 if(optimizer.getThreshold.nonEmpty)&#123; LRModel.optimizer.setConvergenceTol(optimizer.getThreshold.get)&#125; else &#123;LRModel.optimizer.setConvergenceTol(optimizer.getConvergenceTol)&#125; LRModel&#125; 模型效果评估12345678910111213141516def evaluteResult(result: RDD[(Double,Double,Double)]) :Unit = &#123; // MSE val testMSE = result.map&#123; case(real, pre, _) =&gt; math.pow((real - pre), 2)&#125;.mean() println(s\"Test Mean Squared Error = $testMSE\") // AUC val metrics = new BinaryClassificationMetrics(result.map(x =&gt; (x._2,x._1)).sortByKey(ascending = true),numBins = 2) println(s\"0-1 label AUC is = $&#123;metrics.areaUnderROC&#125;\") val metrics1 = new BinaryClassificationMetrics(result.map(x =&gt; (x._3,x._1)).sortByKey(ascending = true),numBins = 2) println(s\"score-label AUC is = $&#123;metrics1.areaUnderROC&#125;\") // 错误率 val error = result.filter(x =&gt; x._1!=x._2).count().toDouble / result.count() println(s\"error is = $error\") // 准确率 val accuracy = result.filter(x =&gt; x._1==x._2).count().toDouble / result.count() println(s\"accuracy is = $accuracy\")&#125; 保存模型12345678910111213141516171819def saveModel(model: LogisticRegressionModel, model_path: String): Unit = &#123; // 保存模型文件 obj val out_obj = new ObjectOutputStream(new FileOutputStream(model_path+\"model.obj\")) out_obj.writeObject(model) // 保存模型信息 val model_info=new BufferedWriter(new FileWriter(model_path+\"model_info.txt\")) model_info.write(model.toString()) model_info.flush() model_info.close() // 保存模型权重 val model_weights=new BufferedWriter(new FileWriter(model_path+\"model_weights.txt\")) model_weights.write(model.weights.toString) model_weights.flush() model_weights.close() println(s\"模型信息写入文件完成，路径为：$model_path\")&#125; 加载模型123456789101112131415161718192021def loadModel(model_path: String): Option[LogisticRegressionModel] = &#123; try&#123; val in = new ObjectInputStream( new FileInputStream(model_path) ) val model = Option( in.readObject().asInstanceOf[LogisticRegressionModel] ) in.close() println(\"Model Load Success\") model &#125; catch &#123; case ex: ClassNotFoundException =&gt; &#123; println(ex.printStackTrace()) None &#125; case ex: IOException =&gt; &#123; println(ex.printStackTrace()) println(ex) None &#125; case _: Throwable =&gt; throw new Exception &#125;&#125; 使用加载的模型进行分值计算1234567891011// 加载obj文件进行预测val model_new = loadModel(s\"$model_path/model.obj\")// 使用加载的模型进行样例预测val result_new = test.map(line =&gt;&#123; val pre_label = model_new.get.predict(line.features) // blas.ddot(x.length, x,1,y,1) (向量x的长度，向量x，向量x的索引递增间隔，向量y，向量y的索引递增间隔) val pre_score = blas.ddot(model.numFeatures, line.features.toArray, 1, model.weights.toArray, 1) val score = Math.pow(1+Math.pow(Math.E, -2 * pre_score), -1) (line.label, pre_label,score)&#125; )result_new.take(2).foreach(println) ml中的二分类LRml包中的LR既可以用来做二分类，也可以用来做多分类。 二分类对应：Binomial logistic regression 多分类对应：multinomial logistic regression 其中二分类可以通过Binomial logistic regression 和 multinomial logistic regression实现。 基于Binomial logistic regression的LR实现：12345678910111213141516171819202122232425262728293031323334353637383940414243def BinaryModel(train: Dataset[Row], model_path: String, spark: SparkSession) = &#123; // 创建模型 val LRModel = new LogisticRegression() .setMaxIter(20) .setRegParam(0.3) .setElasticNetParam(0.8) // 训练评估模型 val model = LRModel.fit(train) evalute(model, train, spark)&#125;def evalute(model: LogisticRegressionModel, train: Dataset[Row], spark: SparkSession):Unit = &#123; // 打印模型参数 println(s\"模型参数信息如下：\\n $&#123;model.parent.explainParams()&#125; \\n\") println(s\"Coefficients（系数）: $&#123;model.coefficients&#125;\") println(s\"Intercept（截距）: $&#123;model.intercept&#125;\") // 查看训练集的预测结果 rawPrediction：row 计算的分值，probability：经过sigmoid转换后的概率 val result = model.evaluate(train) result.predictions.show(10) // 将 label，0 值概率，predict label提取出来 result.predictions.select(\"label\",\"probability\",\"prediction\").rdd .map(row =&gt; (row.getDouble(0),row.get(1).asInstanceOf[DenseVector].toArray(0),row.getDouble(2))) .take(10).foreach(println) // 模型评估 val trainSummary = model.summary val objectiveHistory = trainSummary.objectiveHistory println(\"objectiveHistoryLoss:\") objectiveHistory.foreach(loss =&gt; println(loss)) val binarySummary = trainSummary.asInstanceOf[BinaryLogisticRegressionSummary] val roc = binarySummary.roc roc.show() println(s\"areaUnderROC: $&#123;binarySummary.areaUnderROC&#125;\") // Set the model threshold to maximize F-Measure val fMeasure = binarySummary.fMeasureByThreshold fMeasure.show(10) val maxFMeasure = fMeasure.select(max(\"F-Measure\")).head().getDouble(0) import spark.implicits ._ val bestThreshold = fMeasure.where($\"F-Measure\"===maxFMeasure).select(\"threshold\").head().getDouble(0) model.setThreshold(bestThreshold) &#125; 基于Multimial logistic regression的LR实现：1234567891011121314def BinaryModelWithMulti(train: Dataset[Row], model_path: String, spark: SparkSession) = &#123; // 创建模型 val LRModel = new LogisticRegression() .setMaxIter(10) .setRegParam(0.3) .setElasticNetParam(0.8) .setFamily(\"multinomial\") // 训练模型 val model = LRModel.fit(train) // 打印模型参数 println(s\"模型参数信息如下：\\n $&#123;model.parent.explainParams()&#125; \\n\") println(s\"Coefficients（系数）: $&#123;model.coefficientMatrix&#125;\") println(s\"Intercept（截距）: $&#123;model.interceptVector&#125;\")&#125; ml中的多分类LR某条样本属于类别k的概率计算为： P(Y=k | X,\\beta_k,\\beta_{0k} ) = \\frac { e^{ \\beta _k \\cdot X + \\beta_{0k} }} { \\sum_{k^j=0}^{K-1} e^{ \\beta _{k^j} \\cdot X + \\beta_{0k^j}} }其中K表示类别，J表示特征个数 权重最小化使用的是最大似然函数，其更新公式如下： \\underset{ \\beta , \\beta_0 }{min} - [\\sum_{i=1}^{L}w_i \\cdot logP(Y=y_i|X_i) ] + \\lambda [ \\frac{1}{2}(1-\\alpha )||\\beta||_2^2 + \\alpha ||\\beta||_1]使用的数据集形式为：123456781 1:-0.222222 2:0.5 3:-0.762712 4:-0.8333331 1:-0.555556 2:0.25 3:-0.864407 4:-0.9166671 1:-0.722222 2:-0.166667 3:-0.864407 4:-0.8333331 1:-0.722222 2:0.166667 3:-0.694915 4:-0.9166670 1:0.166667 2:-0.416667 3:0.457627 4:0.51 1:-0.833333 3:-0.864407 4:-0.9166672 1:-1.32455e-07 2:-0.166667 3:0.220339 4:0.08333332 1:-1.32455e-07 2:-0.333333 3:0.0169491 4:-4.03573e-08 多分类LR模型实现为：1234567891011121314def MultiModel(file_multi: String, spark: SparkSession, model_path: String): Unit = &#123; val training = spark.read.format(\"libsvm\").load(file_multi) val lr = new LogisticRegression() .setMaxIter(10) .setRegParam(0.3) .setElasticNetParam(0.8) // Fit the model val lrModel = lr.fit(training) // Print the coefficients and intercept for multinomial logistic regression println(s\"Coefficients: \\n$&#123;lrModel.coefficientMatrix&#125;\") println(s\"Intercepts: $&#123;lrModel.interceptVector&#125;\")&#125; 参考资料https://spark.apache.org/docs/2.1.0/mllib-linear-methods.html#classification https://spark.apache.org/docs/2.1.0/ml-classification-regression.html#logistic-regression https://blog.csdn.net/pupilxmk/article/details/80735599 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"},{"name":"CTR","slug":"CTR","permalink":"http://thinkgamer.cn/tags/CTR/"}]},{"title":"常见的五种神经网络(1)-前馈神经网络","slug":"TensorFlow/前馈神经网络介绍和参数学习","date":"2019-04-23T08:36:43.000Z","updated":"2019-10-14T12:28:36.836Z","comments":true,"path":"2019/04/23/TensorFlow/前馈神经网络介绍和参数学习/","link":"","permalink":"http://thinkgamer.cn/2019/04/23/TensorFlow/前馈神经网络介绍和参数学习/","excerpt":"给定一组神经元，我们可以以神经元为节点来构建一个网络。不同的神经网络模型有着不同网络连接的拓扑结构。一种比较直接的拓扑结构是前馈网络。前馈神经网络（Feedforward Neural Network，FNN）是最早发明的简单人工神经网络。","text":"给定一组神经元，我们可以以神经元为节点来构建一个网络。不同的神经网络模型有着不同网络连接的拓扑结构。一种比较直接的拓扑结构是前馈网络。前馈神经网络（Feedforward Neural Network，FNN）是最早发明的简单人工神经网络。 介绍在前馈神经网络中，不同的神经元属于不同的层，每一层的神经元可以接受到前一层的神经元信号，并产生信号输出到下一层。第0层叫做输入层，最后一层叫做输出层，中间的叫做隐藏层，整个网络中无反馈，信号从输入层到输出层单向传播，可用一个有用无环图表示。 前馈神经网络也成为多层感知器（Mutlti-Layer Perceptron，MLP）。但是多层感知器的叫法并不准确，因为前馈神经网络其实是由多层Logistic回归模型（连续的非线性模型）组成，而不是有多层感知器模型（非连续的非线性模型）组成。 下图为简单的前馈神经网络图： 神经网络中涉及的多个概念： L：表示神经网络的层数 m^l：表示第 l 层神经元个数 f_l(.)：表示第 l 层神经元的激活函数 W^l：表示第 l-1 层到第 l 层的权重矩阵 b^l：表示第 l-1 层到第 l 层的偏置 z^l：表示第 l 层神经元的净输入（净活性值） a^l：表示第l层的神经元输出（活性值） 神经网络的信息传播公式如下（公式1-1） z^l = W^l \\cdot a^{l-1} + b^l \\\\ a^l = f_l(z^l)公式1-1也可以合并写为（公式1-2）： z^l = W^l \\cdot f_{l-1}(z^{l-1}) + b^l或者（公式1-3） a^l = f_l(W^l \\cdot a^{l-1} + b^l)这样神经网络可以通过逐层的信息传递，得到网络最后的输出a^L。整个网络可以看做一个符合函数 \\phi (x; W,b)将向量x作为第一层的输入a^0，将第 l 层的输入a^0，将第L层的输出a^L 作为整个函数的输出。 x = a^0 \\rightarrow z^1 \\rightarrow a^1 \\rightarrow z^2 .... \\rightarrow a^{L-1} \\rightarrow z^L \\rightarrow a^L = \\phi (x;W,b)其中W, b表示网络中所有层的连接权重和偏置。 参数学习如果采用交叉熵损失函数，对于样本(x，y)，其损失函数为（公式1-4）： L(y,\\hat{y}) = -y^T log (\\hat{y})其中 y 属于{0,1}^T为标签y对应的one-hot向量。 给定训练集D={(x^n,y^n)}, N &gt;= n &gt;=0，将每个样本x^n输入给前馈神经网络，得到网络输出为y^n，其在数据集D上的结构化风险函数为（公式1-5）： R(W,b)=\\frac{1}{N}\\sum_{n=1}^{N} L(y^n,\\hat{y}^n) + \\frac{1}{2}\\lambda \\left \\| W \\right \\|_F^2其中W和b分别表示网络中所有的权重矩阵和偏置向量， (||W||_F)^2是正则化项，用来防止过拟合，lambda是为正数的超参数，lambda越大，W越接近于0。这里的(||W||_F)^2一般使用Frobenius范数： \\left \\| W \\right \\|_F^2= \\sum_{l=1}^{L} \\sum_{i=1}^{m^l} \\sum_{j=1}^{m^{l-1}} (W_{ij}^l)^2有了学习准则和训练样本，网络参数可以通过梯度下降法来进行学习。在梯度下降方法的每次迭代过程中，第l层的参数 W^l 和 b^l 参数更新方式为（公式1-6）： W^l \\leftarrow W^l - \\alpha \\frac{\\partial R(W,b)}{\\partial W^l} =W^l - \\alpha ( \\frac{1}{N} \\sum_{n=1}^{N}(\\frac{\\partial L(y^n,\\hat{y}^n)}{\\partial W^l}) + \\lambda W^l ) \\\\ b^l \\leftarrow b^l - \\alpha \\frac{\\partial R(W,b)}{\\partial b^l} =b^l - \\alpha ( \\frac{1}{N} \\sum_{n=1}^{N}(\\frac{\\partial L(y^n,\\hat{y}^n)}{\\partial b^l}) )其中alpha为学习参数。 梯度下降法需要计算损失函数对参数的偏导数，如果通过链式法则逐一对每个参数进行求偏导效率比较低。在神经网络的训练中经常使用反向传播算法来高效的计算梯度。 反向传播算法基于误差的反向传播算法（backpropagation，BP）的前馈神经网络训练过程可以分为以下三步： 前馈计算每一层的净输入z^l 和激活值 a^l，直到最后一层 反向传播计算每一层的误差项 计算每一层参数的偏导数，并更新参数 其具体训练过程如下： 自动梯度计算神经网络中的参数主要是通过梯度下降来进行优化的。当确定了风险函数及网络结构后，我们就可以手动用链式法则来计算风险函数对每个参数的梯度，并用代码进行实现。 目前几乎所有的深度学习框架都包含了自动梯度计算的功能，在使用框架进行神经网络开发时，我们只需要考虑网络的结构并用代码实现，其梯度可以自动进行计算，无需人工干预，这样开发效率就大大提高了。 自动梯度计算方法分为以下三种： 数值微分数值微分（Numerical Differentiation）是用数值方法计算函数f(x)的导数。函数f(x)的点x的导数定义为： f'(x) = \\underset{\\Delta x \\rightarrow 0}{ lim } \\frac{ f(x + \\Delta x) -f(x) }{ \\Delta x }要计算f(x)在点x的导数，可以对x加上一个很少的非零扰动，然后通过上述定义来直接计算函数f(x)的梯度。数值微分方法非常容易实现，但找到一个合适扰动非常难，如果扰动过小会引起数值计算问题，比如舍入误差；如果扰动过大，会增加截断误差，使得导数计算不准确，因此数值微分的实用性比较差，在实际应用中，常用以下公式来计算梯度可以减少截断误差。 f'(x) = \\underset{\\Delta x \\rightarrow 0}{ lim } \\frac{ f(x + \\Delta x) -f(x -\\Delta x) }{2 \\Delta x } 舍入误差：是指数值计算中由于数字舍入造成的近似值和精确值之间的差异，比如用浮点数来表示实数。 截断误差：数学模型的理论解与数值计算问题的精确解之间的误差 符号微分符号微分（Symbolic Differentiation）是一种基于符号计算的自动求导方法。符号计算，也叫代数计算，是指用计算机来处理带有变量的数学表达式。 符号计算的输入和输出都是数学表达式的化简、因式分解、微分、积分、解代数方程、求解常微分方程等运算。 比如数学表达式的化简 输入：3x-x+2x+1 输出：4x+1 符号计算一般来讲是对输入的表达式，通过迭代或递归使用一些事先定义的规则进行转换。当转换结果不能再继续使用变换规则时，便停止计算。 自动微分自动微分（Automatic Differentiation，AD）是一种可以对一个（程序）函数进行计算导数的方法。符号微分的处理对象是数学表达式，而自动微分的处理对象是一个函数或一段程序。而自动微分可以直接在原始程序代码进行微分。自动微分的基本原理是所有的数值计算可以分解为一些基本操作，包含+,−,×, / 和一些初等函数exp, log, sin, cos 等。 自动微分也是利用链式法则来自动计算一个复合函数的梯度。我们以一个神经网络中常见的复合函数的例子来说明自动微分的过程。为了简单起见，令复合函数f(x;w, b) 为 f(x;w,b)=\\frac{1}{ exp(-(wx+b))+1 }其中x 为输入标量，w和b 分别为权重和偏置参数。 复合函数f(x;w,b) 可以拆解为： 继而就可以通过链式求导法则进行复合函数求导。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"神经网络中的激活函数介绍","slug":"TensorFlow/神经网络中的激活函数介绍","date":"2019-04-21T14:25:15.000Z","updated":"2019-11-14T02:26:37.481Z","comments":true,"path":"2019/04/21/TensorFlow/神经网络中的激活函数介绍/","link":"","permalink":"http://thinkgamer.cn/2019/04/21/TensorFlow/神经网络中的激活函数介绍/","excerpt":"人工神经元（Artifical Neuron）简称神经元（Neuron），是构成神经网络的基本单元，其主要是模拟生物神经元的结构和特性，接受一组输入信息并产出输出。","text":"人工神经元（Artifical Neuron）简称神经元（Neuron），是构成神经网络的基本单元，其主要是模拟生物神经元的结构和特性，接受一组输入信息并产出输出。 激活函数（Activation Function）是神经元中非常重要的一部分，为了增强网络的表示能力和学习能力，激活函数需要具备以下几点性质： 连续并可导的非线性函数，可导的激活函数可以直接利用数值优化的方法来学习网络参数。 激活函数及其导函数要尽可能的简单，有利于提高网络计算效率。 激活函数的导函数的值域要在一个合适的区间内，不能太大也不能太小，否则会影响训练的效率和温度性。 Sigmoid型激活函数S型曲线函数，常见的Sigmoid函数有Logistic函数和tanh函数。 知识点：对于函数f(x)，若x趋向于负无穷大，其导数f’(x)趋向于0，则称其为左饱和。若x趋向于正无穷大，其导数f’(x)趋向于0，则称其为右饱和。同时满足左右饱和时，称为两端饱和。 Logistic 函数 \\sigma (x) = \\frac{1} { 1+ exp(-x)} tanh函数 tanh(x) = \\frac{ exp(x)-exp(-x) }{ exp(x) + exp(-x) }tanh函数可以看作是放大并平移的Logistic函数，其值域是(-1，1)。 tanh(x) = 2 \\sigma(2x) - 1tanh函数的输出是零中心化的（Zero-Centered），而Logistic函数的输出值恒大于0。非零中心化的输出会使得最后一层的神经元的输入发生位置偏移（Bias Shift），并进一步使得梯度下降的收敛速度变慢。 修正线性单元Rectified Linear Unit（ReLU）也叫rectifier函数，是目前深层神经网络中经常使用的激活函数。ReLU实际上是一个斜坡函数，定义为： ReLU(x) = \\begin{cases} x & \\text{ if } x \\geq 0 \\\\ 0 & \\text{ if } x < 0 \\end{cases} = max(0,x) ReLU的优缺点： 优点 采用ReLU的神经元只需要进行加，乘，和，比较的操作，计算上更加高效。Sigmoid型激活函数会导致一个非稀疏的神经网络，而ReLU却具有很好的稀疏性，大约50%的神经元会处于激活状态。 在优化方面，由于Sigmoid型函数的两端饱和，ReLU函数为左饱和函数，且在x&gt;0时导数为1，在一定程度上缓解了神经网络的梯度消失问题，加速梯度下降的收敛速度。 缺点 ReLU的输出是非零中心化的，给后一层的神经网络引入偏置偏移，会影响梯度下降的效率。此外ReLU神经元在训练时比较容易死亡。在训练时，如果参数在一次不恰当的更新后，第一个隐藏层中的某个ReLU神经元在所有的训练数据上都不能被激活，那么这个神经元自身参数的梯度永远都会是0，在以后的训练过程中永远不能被激活。这种现象称为死亡ReLU问题（Dying ReLU Problem），并且也有kennel会发生在其他隐藏层。 在实际使用中，为了避免上述情况，有集中ReLU的变种也会被广泛使用。 带泄漏的ReLU带泄漏的ReLU在输入x&lt;0时，保持一个很小的梯度 lambda。这样当神经元非激活时也能又一个非零的梯度可以更新参数，避免永远不能被激活。带泄漏的ReLU的定义如下： LeakyReLU(x) = \\begin{cases} x & \\text{ if } x > 0 \\\\ \\gamma x & \\text{ if } x \\leq 0 \\end{cases} = max(0,x) + \\gamma min(0,x)其中 gamma是一个很小的常数，比如0.01。当gamma &lt; 1时，带泄漏的ReLU也可以写为： LeakyReLU(x) = max(x, \\gamma x)相当于是一个比较简单的maxout单元。 带参数的ReLU带参数的ReLU引入一个可学习的参数，不同神经元可以有不同的参数，对于第i个神经元，其PReLU的定义为： PReLU(x) = \\begin{cases} x & \\text{ if } x > 0 \\\\ \\gamma _ix & \\text{ if } x \\leq 0 \\end{cases} = max(0,x) + \\gamma_imin(0,x)其中γi为x≤0时函数的斜率。因此，PReLU是非饱和函数。如果γi =0，那 么 PReLU 就退化为 ReLU。如果 γi 为一个很小的常数，则 PReLU 可以看作带 泄露的 ReLU。PReLU 可以允许不同神经元具有不同的参数，也可以一组神经 元共享一个参数。 ELU指数线性单元（Exponential Linear Unit）是一个近似的零中心化的非线性函数，其定义为： ELU(x) = \\begin{cases} x & \\text{ if } x > 0 \\\\ \\gamma (exp(x)-1) & \\text{ if } x \\leq 0 \\end{cases} = max(0,x) + min(0,\\gamma(exp(x)-1))其中 γ ≥ 0是一个超参数，决定x ≤ 0时的饱和曲线，并调整输出均值在0附近。 Softplus函数Softplus函数可以看作是rectifier函数的平滑版本，其定义为： Softplus(x) = log(1 + exp(x))Softplus函数及其导数刚好是Logistic函数。Softplus函数虽然也具有单侧抑制，宽兴奋边界的特征，却没有稀疏激活性。 下图为几种激活函数的示例： Swish函数Swish函数是一种自门控（self-Gated）激活函数，其定义为： swish(x) = x \\sigma (\\beta x)其中 sigma(.)为logistic函数，beta为可学习的参数或一个固定超参数。 sigma(.) 属于 (0,1)可以看做是一种软性的门控机构。当sigma(beta x)接近于1时，门处于“开”状态，激活函数的输出近似于x本身；当sigma(beta x)接近于0时，门的状态为“关”，激活函数的输出近似于0。 下图为Swish函数的示例： 当 beta=0时，Swish函数变成线性函数 x/2。 当 beta=1时，Swish 函数在 x&gt;0时近似线性，在x &lt; 0时近似饱和，同时具有一定的非单调性。当beta趋向于正无穷大时， sigma(beta x)趋向于离散的0-1函数，Switch函数近似为ReLU函数。 因此Swish函数可以看作时线性函数和ReLU函数之间的非线性插值函数，其程度由参数beta控制。 Maxout单元Maxout单元也是一种分段线性函数。Sigmoid型函数， ReLU等激活函数的输入是神经元的净输入z，是一个标量。而maxout单元的输入是上一层神经元的全部原始输入，是一个向量x=[x1;x2;…;x_d]。 每个maxout单元有K个权重向量w_k 属于 R^d 和偏置 b_k（1 &lt;= k &lt;= K）。对于输入x，可以得到K个净输入z_k，1 &lt;= k &lt;=K。 z_k = w^T_kx + b_k其中 w_k = [w_{k,1},w_{k,2},...,w_{k,d}]^T为第k个权重向量。Maxout单元的非线性函数定义为： maxout(x) = \\underset{k\\in [1,K]}{max} (z_k)Maxout单元不单是净输入到输出之间的非线性映射，而是整体学习输入到输出之间的非线性映射关系。Maxout激活函数可以看作任意凸函数的分段线性近似，并且在有限的点上是不可微的。 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://thinkgamer.cn/tags/TensorFlow/"},{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"线性模型篇之SVM数学公式推导","slug":"机器学习/线性模型篇之SVM数学公式推导","date":"2019-04-20T16:17:00.000Z","updated":"2019-10-14T06:42:35.688Z","comments":true,"path":"2019/04/21/机器学习/线性模型篇之SVM数学公式推导/","link":"","permalink":"http://thinkgamer.cn/2019/04/21/机器学习/线性模型篇之SVM数学公式推导/","excerpt":"支持向量机（Support Vector Machine，SVM）是一个经典两类分类算法，其找到的分割超平面具有更好的鲁棒性，因此广泛使用在很多任务上，并表现出了很强优势。","text":"支持向量机（Support Vector Machine，SVM）是一个经典两类分类算法，其找到的分割超平面具有更好的鲁棒性，因此广泛使用在很多任务上，并表现出了很强优势。 介绍给定一个两分类数据集D={(x^n, y^n)}，n属于N，其中y_n 属于{+1,-1}，如果两类样本是线性可分的，即存在一个超平面（公式-1） w^Tx + b =0将两类样本分开，那么对于每个样本都有 y^n(w^Tx^n + b) > 0数据集D中的每个样本x^n 到分隔超平面的距离为： \\gamma ^n = \\frac{\\left \\| w^Tx^n +b \\right \\|}{ \\left \\| w \\right \\|} = \\frac{y^n(w^Tx^n + b)}{ \\left \\| w \\right \\| }我们定义整个数据集D中所有样本到分隔超平面的最短距离为间隔（Margin）（公式-2） \\gamma = \\underset{n}{min} \\gamma ^ n如果间隔 gamma越大，其分隔超平面对两个数据集的划分越稳定，不容易受噪声等因素影响，支持向量机的目的是找到一个超平面(w^ , b^ )使得gamma最大，即（公式-3） \\underset{w,b}{max} \\qquad \\gamma \\\\ s.t. \\qquad \\frac{y^n (w^Tx^n + b)}{\\left \\| w \\right \\|} \\geq \\gamma,\\forall_n令 \\left \\| w \\right \\| . \\gamma =1则（公式-3）等价于（公式-4） \\underset{w,b}{max} \\qquad \\frac{1}{ \\left \\| w \\right \\| ^2} \\\\ s.t. \\qquad y^n(w^Tx^n + b) \\geq 1, \\forall_n数据集中所有满足 y^n (w^T x^n +b) =1 的样本点，都称为支持向量（support vertor） 对于一个线性可分数据集，其分隔的超平面有多个，但是间隔最大的超平面是唯一的。下图给定了支持最大间隔分隔超平面的示例，其红色样本点为支持向量。 ![支持向量机示例](https://img-blog.csdnimg.cn/20190417110614374.png) 参数学习凸函数 &amp; 凹函数关于凹凸函数的定义和性质可以参考下图： ![image](https://img-blog.csdnimg.cn/20190420165249483.jpg) 为了找到最大间隔分割超平面，将公式-4改写为凸优化问题（公式-5）： \\underset{w,b}{min} \\qquad \\frac{1}{ 2} {\\left \\| w \\right \\| ^2} \\\\ s.t. \\qquad 1-y^n(w^Tx^n + b) \\leq 0, \\forall n使用拉格朗日乘数法，公式-5的拉格朗日函数为（公式-6）： \\Lambda (w,b,\\lambda )=\\frac{1}{2} \\left \\| w^2 \\right \\| + \\sum_{n-1}^{N} \\lambda _n( 1-y^n(w^Tx^n + b) )其中 \\lambda _1 \\geq 0,...,\\lambda _N \\geq 0为拉格朗日乘数。计算公式-6关于w和b的导数，并令其等于0得到（公式-7） w = \\sum_{n=1}^{ N }\\lambda _n y^nx^n和（公式-8） 0 = \\sum_{n=1}^{N} \\lambda _n y^n将公式-7代入公式-6，并利用公式-8，得到拉格朗日对偶函数（公式-9）： \\Gamma(\\lambda) = -\\frac{1}{2} \\sum_{n=1}^{N}\\sum_{m=1}^{N} \\lambda_n \\lambda_m y^m y^n (x^m)^Tx^n + \\sum_{n=1}^{N}\\lambda_n支持向量机的主优化问题为凸优化问题，满足强对偶性，即主优化问题可以通过最大化对偶函数 max_{\\lambda \\geq 0} \\Gamma(\\lambda)对偶函数 Gamma(lambda)是一个凹函数，因此最大化对偶数是一个凸优化问题，可以通过多种凸优化方法进行求解，得到拉格朗日乘数的最优值 lambda^* 。但由于其约束条件的数量为训练样本数量，一般的优化方法代价比较高，因此在实践中通常采样比较高效的优化方法，比如SMO(Sequential Minimal Optimization)算法等。 根据KKT条件中的互补松弛条件，最优解满足(公式-10) \\lambda_n ^*(1-y^n(w^{*T}x^n+b^*))=0如果样本x^n 不在约束边界上，(lambda_n)^，其约束失效；如果样本x^n在约束边界上，(lambda_n)^ &gt;=0。这些在约束边界上的样本点称为支持向量（support vector），即离决策平面距离最近的点。 再计算出 lambda^后，根据公式-7计算出最优权重w^，最优偏置b^*可以通过任选一个支持向量(x,y)计算得到（公式-11） b^* = \\tilde{y} - w^{*T}\\tilde{x}最优参数的支持向量机的决策函数为（公式-12） f(x)=sgn(w^{*T}x+b^*)=sgn(\\sum_{n=1}^{N} \\lambda_n^* y^n(x^n)^Tx + b^* )支持向量机的决策函数只依赖 lambda_n^*&gt;0的样本点，即支持向量。 支持向量机的目标函数可以通过SMO等优化方法得到全局最优解，因此比其他分类器的学习效率更高。此外，支持向量机的决策函数只依赖与支持向量。与训练样本总数无关，分类速度比较快。 核函数支持向量机还有一个重要的优点是可以使用核函数(kernal)隐式的将样本从原始特征空间映射到更高维的空间，并解决原始特征空间中的线性不可分问题。比如在一个变换后的特征空间中，支持向量机的决策函数为（公式-13） f(x)=sgn(w^{*T} \\phi(x)+b^*)=sgn(\\sum_{n=1}^{N} \\lambda_n^* y^n K(x^n,x) + b^* )其中 K(x,z)=\\phi(x)^T \\phi(z)为核函数，通常不需要显式的给出φ(x)的具体形式，可以通过核技巧(kernel trick)来构造。比如以x,z属于R^2为例，我们可以构造一个核函数（公式-14） K(x,z)=(1+x^Tz)^2=\\phi(x)^T\\phi(z)来隐式的计算x,z在特征空间φ中的内积，其中: \\phi(x)=[1,\\sqrt{2}x_1,\\sqrt{2}x_2,\\sqrt{2}x_1x_2,x_1^2,x_2^2]^T软间隔在支持向量机的优化问题中，约束条件比较严格。如果训练集中的样本在特征空间中不是线性可分的，就无法找到最优解。为了能够容忍部分不满足约束的样本，我们可以引入松弛变量，将优化问题变为（公式-15）： \\underset{w,b}{min} \\qquad \\frac{1}{ 2} {\\left \\| w \\right \\| ^2} + C \\sum_{n=1}^{N}\\xi _n \\\\ s.t. \\qquad 1-y^n(w^Tx^n + b) -\\xi _n \\leq 0, \\forall n \\\\ \\xi _n \\geq 0, \\forall n其中参数C&gt;0用来控制间隔和松弛变量惩罚的平衡，引入松弛变量的间隔称为软间隔（soft margin）。公式-15也可以表示为经验风险+正则化项的形式（公式-16）。 \\underset{w,b}{min} \\qquad \\sum_{n=1}^{N}max(0,1-y^n(w^Tx^n + b)) + \\frac{1}{C}.\\frac{1}{2}\\left \\| w \\right \\|^2其中 max(0,1-y^n(w^Tx^n + b))称为hinge损失函数，1/C可以看作是正则化系数。软间隔支持向量机的参数学习和原始支持向量机类似，其最终决策函数也只和支持向量有关，即满足 1-y^n(w^Tx^n + b) - \\xi_n = 0的样本。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"},{"name":"SVM","slug":"SVM","permalink":"http://thinkgamer.cn/tags/SVM/"}]},{"title":"线性模型之PLA数学公式推导","slug":"机器学习/线性模型之PLA数学公式推导","date":"2019-04-16T11:13:32.000Z","updated":"2019-10-14T06:42:35.688Z","comments":true,"path":"2019/04/16/机器学习/线性模型之PLA数学公式推导/","link":"","permalink":"http://thinkgamer.cn/2019/04/16/机器学习/线性模型之PLA数学公式推导/","excerpt":"本文主要介绍线性模型之PLA数学公式推导。","text":"本文主要介绍线性模型之PLA数学公式推导。 介绍感知机（Perceptron）是一种广泛使用的线性分类器，相当于最简单的人工神经网络，只有一个神经元。其全称是PLA（Perceptron Linear Algorithm），线性感知机算法。 感知机是对生物神经元的简单数学模型，有与生物神经元相对应的部件，比如权重（突触）、偏置（阈值）及激活函数（细胞体），输出值为 +1 或者 -1。 \\hat{y} = sgn(w^Tx)对于二分类问题，可以使用感知机算法来解决。PLA的原理是逐点解决，首先在超平面上随意取一条分类面，统计分类错误的点，然后随机对某个错误点修正，即变换直线的位置，使该错误点被修正，接着再随机选取另外一个错误点进行修正，分类面不断变化，直到所有点都分类正确了，就得到了最佳分类面。 利用二维平面进行解释，第一种情况是错误的将正样本（y=1）分类为负样本（y=-1）。此时wx&lt;0，即w与x的夹角大于90度，分类线L的两侧。修正的方法是让夹角变小，修正w值，使二者位于直线同侧。 w:=w+x=w+yx修正过程如下： 第二种情况就是错误的将负样本（y=-1）分类为正样本（y=1）。此时，wx&gt;0，即w与x的夹角小于90度，分类线L的同一侧。修正的方法是让夹角变大，修正w值，使二者位于分类线同侧。 w:=w-x=w+yx修正过程如下： 经过上边两种情况分析，PLA每次更新参数w的表达式是一致的，掌握了每次w的优化表达式，那么PLA就能不断地将所有错误的分类样本纠正并分类正确。 参数学习给定N个训练集样本{(x^n, y^n)},n&lt;=N，其中y^n 属于{+1,-1}，感知机试图学习到参数w*，使得对于每个样本(x^n,y^n)有： y^n w^{*T}x^n>0,\\forall n\\in [1,N]感知机算法是一种错误驱动的在线学习算法，先初始化一个权重向量w&lt;-0（通常是全零向量），然后每次分错一个样本（x,y）时，就用这个样本来更新权重。 w \\leftarrow w + yx具体的感知机算法伪代码如下（==算法-1==）： 根据感知器的学习策略，可以反推出感知器的损失函数为： L (w;x,y)=max(0, -yw^Tx)采用随机梯度的下降，其每次更新的梯度为： \\frac{\\partial L (w;x,y) }{ \\partial w}=\\begin{cases} 0 & \\text{ if } y^Tx>0 \\\\ -yx & \\text{ if } y^Tx","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"},{"name":"PLA","slug":"PLA","permalink":"http://thinkgamer.cn/tags/PLA/"}]},{"title":"线性模型篇之softmax数学公式推导","slug":"机器学习/线性模型篇之softmax数学公式推导","date":"2019-04-06T23:24:46.000Z","updated":"2019-10-14T06:42:35.689Z","comments":true,"path":"2019/04/07/机器学习/线性模型篇之softmax数学公式推导/","link":"","permalink":"http://thinkgamer.cn/2019/04/07/机器学习/线性模型篇之softmax数学公式推导/","excerpt":"Softmax回归也称多项（multinomial）或者多类（multi-class）的Logistic回归，是Logistic回归在多类分类问题上的推广。和逻辑回归一样属于线性模型。","text":"Softmax回归也称多项（multinomial）或者多类（multi-class）的Logistic回归，是Logistic回归在多类分类问题上的推广。和逻辑回归一样属于线性模型。 SoftMax回归简介对于多类问题，类别标签 y \\in {1,2,3,...,C}可以用C个取值，给定一个样本x，softmax回归预测的是属于类别c的概率为(公式-1)： p(y=c|x)=softmax(w_c^Tx)=\\frac{exp(w_c^Tx)}{\\sum_{c=1}^{C}exp(w_c^Tx)}其中w_c是第c类的权重向量。 softmax回归的决策函数可以表示为(公式-2)： \\hat{y}= \\underset{c=1}{ \\overset{C}{arg max} } \\ p(y=c|x) =\\underset{c=1}{ \\overset{C}{arg max} } \\ w_c^T x softMax与Logistic回归的关系： 当类别个C=2时，softMax回归的决策函数为(公式-3)： \\hat{y} = \\underset{y\\in {0,1}}{ arg max } \\ w_y^Tx=I(w_1^Tx - w_0^Tx >0 )=I((w_1 - w_0)^Tx >0 )其中I(.)是指示函数，对比二分类决策函数(公式-4) g(f(x,w))=sgn(f(x,w))=\\begin{cases} & +1 \\text{ if } f(x,w)>0 \\\\ & -1 \\text{ if } f(x,w)","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"SoftMax","slug":"SoftMax","permalink":"http://thinkgamer.cn/tags/SoftMax/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"}]},{"title":"线性模型篇之Logistic Regression数学公式推导","slug":"机器学习/线性模型篇之Logistic Regression数学公式推导","date":"2019-04-02T14:31:51.000Z","updated":"2019-10-14T06:42:35.688Z","comments":true,"path":"2019/04/02/机器学习/线性模型篇之Logistic Regression数学公式推导/","link":"","permalink":"http://thinkgamer.cn/2019/04/02/机器学习/线性模型篇之Logistic Regression数学公式推导/","excerpt":"本文主要介绍 线性模型篇之Logistic Regression数学公式推导。","text":"本文主要介绍 线性模型篇之Logistic Regression数学公式推导。 两分类与多分类 两类分类（Binary Classification） 类别标签y只有两种取值，通常设为{0，1} 线性判别函数，即形如 y = w^T*x + b 分割超平面（hyper plane）,由满足f(w,x)=0的点组成 决策边界（Decision boundary）、决策平面（Decision surface）：即分分割超平面，决策边界将特征空间一分为二，划分成两个区域，每个区域对应一个类别。 有向距离（signed distance） 多样分类（Multi-class Classification） 分类的类别个数大于2，多分类一般需要多个线性判别函数，但设计这些判别函数有很多方式。eg： 一对其余：属于和不属于 一对一 argmax（改进的一对其余）：属于每个类别的概率，找概率最大值 参考：多分类实现方式介绍和在Spark上实现多分类逻辑回归 Logistic回归LR回归Logistic回归（Logistic Regression，LR）是一种常见的处理二分类的线性回归模型。 为了解决连续的线性回归函数不适合做分类的问题，引入函数g：R^d -&gt; (0,1)来预测类别标签的后验概率p(y=1 | x) 其中g(.)通常称为激活函数（activation function），其作用是把线性函数的值域从实数区间“挤压”到了（0，1）之间，可以用概率表示。在统计文献中，g(.)的逆函数g(.)^-1也称为联系函数（Link Function） 在逻辑回归中使用Logistic作为激活函数，标签y=1的后验概率为(公式-1)： p(y=1 | x) = \\sigma (w^T x) p(y=1 | x)= \\frac{1}{1+exp(-w^T x)}标签 y=0的后验概率为(公式-2)： p(y=0 | x) =1-p(y=0 | x) p(y=0 | x)= \\frac{exp(-w^T x)}{1+exp(-w^T x)}将公式-1进行等价变换，可得(公式-3)： w^T x = log \\frac{p(y=1 | x)}{1-p(y=1 | x)} w^T x = log \\frac { p(y=1 | x)}{p(y=0|x)}其中 \\frac { p(y=1 | x)}{p(y=0|x)}为样本x正反例后验概率的比例，称为几率（odds），几率的对数称为对数几率（log odds或者logit），公式-3中第一个表达式，左边是线性函数，logistic回归可以看做是预测值为“标签的对数几率”的线性回归模型，因为Logistic回归也称为对数几率回归（Logit Regression）。 附公式-1到公式-3的推导： p(y=1 | x)= \\frac{1}{1+exp(-w^T x)} => exp(-w^Tx) = \\frac{1-p(y=1 | x)}{p(y=1 | x)} => - w^T x = log \\frac{1- p(y=1 | x)}{p(y=1 | x)} => w^T x = log (\\frac{1- p(y=1 | x)}{p(y=1 | x)})^{-1} => w^T x = log \\frac{p(y=1 | x)}{1-p(y=1 | x)} => w^T x = log \\frac{p(y=1 | x)}{p(y=0 | x)}参数学习LR回归采用交叉熵作为损失函数，并使用梯度下降法对参数进行优化。给定N个训练样本{x_i,y_i}，i&lt;=N，使用LR对每个样本进行预测，并用输出x_i的标签为1的后验概率，记为y’_i(x) (公式-4) y'_i(x) = \\sigma(w^Tx_i),i\\in N由于y_i属于{0，1}，样本{x_i,y_i}的真实概率可以表示为(公式-5)： p_r(y_i =1 | x_i) = y_i p_r(y_i =0 | x_i) = 1- y_i使用交叉熵损失函数，其风险函数为(公式-6)： R(w)= - \\frac{1}{N}\\sum_{n=1}^{N} (p_r(y_i =1 | x_i) log(y_i') + p_r(y_i =0 | x_i) log(1-y_i') ) = - \\frac{1}{N}\\sum_{n=1}^{N} ( y_i log(y_i') + (1-y_i') log(1-y_i') )风险函数R(w)关于参数w的导数为(公式-7)： \\frac{ \\partial R(w)}{ \\partial w} = - \\frac{1}{N}\\sum_{n=1}^{N}( y_i \\frac{y_i'(1-y_i')}{y_i'}x_i -(1-y_i)\\frac{y_i'(1-y_i')}{1-y_i'}x_i ) = - \\frac{1}{N}\\sum_{n=1}^{N}( y_i(1-y_i')x_i -(1-y_i)y_i'x_i) = - \\frac{1}{N}\\sum_{n=1}^{N}x_i(y_i-y_i')采用梯度下降算法，Logistic的回归训练过程为：初始化w_0 为0，然后通过下式来更新迭代参数(公式-8)。 w_{t+1} \\leftarrow w_t + \\alpha \\frac{1}{N}\\sum_{n=1}^{N} x_i(y_i-y_{w_t}')其中a是学习率，y_{wt}’是当参数为w_t 时，Logistic回归的输出。 从公式-6可知，风险函数R(w)是关于参数w的连续可导的凸函数，因此除了梯度下降算法外，Logistic还可以使用高阶的优化算法，比如牛顿法来进行优化。 说明: 两个未知数相乘求导： (ab)' = a'b + ab' sigmoid函数求导后为： \\sigma ' = \\sigma (1-\\sigma )x 参考 https://zhuanlan.zhihu.com/p/44591359 https://blog.csdn.net/wgdzz/article/details/48816307 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"http://thinkgamer.cn/tags/逻辑回归/"}]},{"title":"机器学习算法分类","slug":"机器学习/机器学习算法分类","date":"2019-03-26T09:43:37.000Z","updated":"2019-10-14T06:42:35.687Z","comments":true,"path":"2019/03/26/机器学习/机器学习算法分类/","link":"","permalink":"http://thinkgamer.cn/2019/03/26/机器学习/机器学习算法分类/","excerpt":"机器学习算法可以按照不同的标准进行分类。比如按函数f(X)的不同，机器学习算法可以分为线性模型和非线性模型；按照学习准则的不同，机器学习算法也可以分为统计方法和非统计方法。 但一般而言，会按照训练样本提供的信息以及反馈方式不同，将机器学习算法分为以下几类，下面将一一细说。","text":"机器学习算法可以按照不同的标准进行分类。比如按函数f(X)的不同，机器学习算法可以分为线性模型和非线性模型；按照学习准则的不同，机器学习算法也可以分为统计方法和非统计方法。 但一般而言，会按照训练样本提供的信息以及反馈方式不同，将机器学习算法分为以下几类，下面将一一细说。 监督学习 无监督学习 强化学习 监督学习如果机器学习的目标是通过建模样本的特征x和标签y之间的关系： y=f(x,\\theta )或 p(y|x,\\theta)并且训练集中的每个样本都有标签，那么这类学习称之为监督学习（Supervised Learning）。根据标签类型的不同，监督学习又可以分为回归和分类两种。 回归（Regression）回归问题中的标签y是连续值（实数或者连续整数） y=f(x,\\theta )的输出也是连续值。 分类（Classification）分类问题中的标签y是离散的类别，在分类问题中，学习到的模型也成为分类器（Classifier）。分类问题根据其类别的数量又可以分为二分类（Binary Clssification）和多分类（Mutil-class Classification）。 机构化学习（Structured Learning）结构化学习的输出对象是结构化的对象，比如序列、树、图等，由于结构化学习的输出空间比较大，因此我们一般定义一个联合特征空间，将x,y映射为该空间中的联合特征向量（x,y）,预测模型可以写为： \\hat{y}=\\underset{y \\in Gen(x)}{arg max f(\\phi (x,y),\\theta )}其中gen(x)表示x所有可能的输出目标集合。计算arg max的过程也称为解码（decoding）过程，一般通过动态规划的方法来计算。 无监督学习无监督学习（Unsupervised Learning）是指从不包含目标标签的训练样本中自动学习到一些有价值的信息。典型的无监督学习问题有聚类、密度估计、特征学习、降维等。 强化学习强化学习（Reinforcement Learning）是一类通过交互来学习的机器学习算法。在强化学习中，智能体根据环境的状态作出一个动作，并得到即时或延时的奖励。智能体在和环境的交互中不断学习并调整策略，以取得最大化的期望总回报。 下表给出了三种机器学习类型 监督学习需要每个样本都有标签，而无监督学习则不需要标签。一般而言，监督学习通常大量的有标签数据集，这些数据集是一般都需要由人工进行标注，成本很高。因此，也出现了很多弱监督学习（Weak Supervised Learning）和半监督学习（Semi-Supervised Learning）的方法，希望从大规模的无标注数据中充分挖掘有用的信息，降低对标注样本数量的要求。强化学习和监督学习的不同在于强化学习不需要显式地以“输入/输出对”的方式给出训练样本，是一种在线的学习机制。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"}]},{"title":"从线性回归看偏差-方差分解（Bias-Variance Decomposition）","slug":"机器学习/从线性回归看偏差-方差分解（Bias-Variance Decomposition）","date":"2019-03-25T15:18:55.000Z","updated":"2019-10-14T06:42:35.683Z","comments":true,"path":"2019/03/25/机器学习/从线性回归看偏差-方差分解（Bias-Variance Decomposition）/","link":"","permalink":"http://thinkgamer.cn/2019/03/25/机器学习/从线性回归看偏差-方差分解（Bias-Variance Decomposition）/","excerpt":"本文主要介绍从线性回归看偏差-方差分解（Bias-Variance Decomposition）","text":"本文主要介绍从线性回归看偏差-方差分解（Bias-Variance Decomposition） 概述对于数字序列1，3，5，7，？，正常情况下大家脑海里蹦出的是9，但是217314也是其一个解9对应的数学公式为 f(x)=2x-1217314对应的数学公式为 f(x)=\\frac{18111}{2} x^{4}-90555x^{3}+\\frac{633885}{2}x^{2}-452773x+217331Python 实现为：12345678910111213&gt;&gt;&gt; def f(x):... return 18111/2 * pow(x,4) -90555 * pow(x,3) + 633885/2 * pow(x,2) -452773 * x +217331... &gt;&gt;&gt; f(1)1.0&gt;&gt;&gt; f(2)3.0&gt;&gt;&gt; f(3)5.0&gt;&gt;&gt; f(4)7.0&gt;&gt;&gt; f(5)217341.0 当机器学习模型进行预测的时候，通常都需要把握一个非常微妙的平衡，一方面我们希望模型能够匹配更多的训练数据，相应的增加其复杂度，否则会丢失相关特征的趋势（即模型过拟合）；但是另一方面，我们又不想让模型过分的匹配训练数据，相应的舍弃部分复杂的，因为这样存在过度解析所有异常值和伪规律的风险，导致模型的泛化能力差（即模型欠拟合）。因此在模型的拟合能力和复杂度之前取得一个比较好的权衡，对于一个模型来讲十分重要。而偏差-方差分解（Bias-Variance Decomposition）就是用来指导和分析这种情况的工具。 偏差和方差定义 偏差（Bias）：即预测数据偏离真实数据的情况。 方差（Variance）：描述的是随机变量的离散程度，即随机变量在其期望值附近的波动程度。 偏差-方差推导过程以回归问题为例，假设样本的真实分布为p_r(x,y)，并采用平方损失函数，模型f(x)的期望错误为(公式2.1)： R(f) = E_{(x,y)\\sim p_r{(x,y)}} \\left [ (y-f(x))^2 \\right ]那么最优模型为(公式2.2)： f^*(x) = E_{y\\sim p_r{(y|x)}} \\left [ y \\right ]其中p_r(y|x)为真实的样本分布，f^*(x)为使用平方损失作为优化目标的最优模型，其损失为(公式2.3)： \\varepsilon = E_{(x,y)\\sim p_r{(x,y)}} \\left [ (y-f^*(x))^2 \\right ]损失 \\varepsilon通常是由于样本分布及其噪声引起的，无法通过优化模型来减少。期望错误可以分解为(公式2.4)： R(f) = E_{(x,y)\\sim p_r{(x,y)}} \\left [ (y- f^*(x) + f^*(x) -f(x))^2 \\right ] = E_{x\\sim p_r{(x)}}\\left [ (f(x) - f^*(x))^2 \\right ] + \\varepsilon公式2.4中的第一项是机器学习可以优化的真实目标，是当前模型和最优模型之间的差距。 在实际训练一个模型f(x)时，训练集D是从真实分布p_r(x,y)上独立同分布的采样出来的有限样本集合。不同的训练集会得到不同的模型。令f_D(x)表示在训练集D上学习到的模型，一个机器学习算法（包括模型和优化算法）的能力可以通过模型在不同训练集上的平均性能来体现。 对于单个样本x，不同训练集D得到的模型f_D(x)和最优模型f^*(x)的上的期望差距为（公式2.5）： E_D[( f_D(x)-f^*(x) )^2] =E_D\\left [ ( f_D(x) - E_D[f_D(x)] +E_D[f_D(x)] -f^*(x) )^2 \\right ] =( E_D[f_D(x)] -f^*(x) )^2 ) + E_D[(f_D(x) - E_D[f_D(x)] )^2]公式2.5最后一行中的第一项为偏差(bias)，是指一个模型在不同训练集上的平均性能和与最优模型的差异，偏差可以用来衡量一个模型的拟合能力；第二项是方差（variance），是指一个模型在不同训练集上的差异，可以用来衡量一个模型是否容易过拟合。 集合公式2.4和公式2.5，期望错误可以分解为(公式2.6)： R(f)= (bias)^2 + variance + \\varepsilon其中 (bias)^2 = E_X[E_D[f_D(x)] -f^*(x) )^2 ] variance = E_X [ E_D[(f_D(x) - E_D[f_D(x)] )^2] ]最小化期望错误等价于最小化偏差和方差之和。 偏差和方差分析上图为机器学习中偏差和方差的四种不同情况。每个图的中心点为最优模型f*(x)，蓝点为不同训练集D 上得到的模型f_D(x)。 (a)给出了一种理想情况，方差和偏差都比较小 (b)为高偏差低方差的情况，表示模型的泛化能力很好，但拟合能力不足 (c)为低偏差高方差的情况，表示模型的拟合能力很好，但泛化能力比较差。当训练数据比较少时会导致过拟合 (d)为高偏差高方差的情况，是一种最差的情况 方差一般会随着训练样本的增加而减少。当样本比较多时，方差比较少，我们可以选择能力强的模型来减少偏差。然而在很多机器学习任务上，训练集上往往都比较有限，最优的偏差和最优的方差就无法兼顾。 随着模型复杂度的增加，模型的拟合能力变强，偏差减少而方差增大，从而导致过拟合。以结构错误最小化为例，我们可以调整正则化系数λ来控制模型的复杂度。当λ变大时，模型复杂度会降低，可以有效地减少方差，避免过拟合，但偏差会上升。当λ过大时，总的期望错误反而会上升。因此，正则化系数λ需要在偏差和方差之间取得比较好的平衡。下图给出了机器学习模型的期望错误、偏差和方差随复杂度的变化情况。最优的模型并不一定是偏差曲线和方差曲线的交点。 偏差和方差分解给机器学习模型提供了一种分析途径，但在实际操作中难以直接衡量。一般来说，当一个模型在训练集上的错误率比较高时，说明模型的拟合能力不够，偏差比较高。这种情况可以增加数据特征、提高模型复杂度，减少正则化系数等操作来改进模型。当模型在训练集上的错误率比较低，但验证集上的错误率比较高时，说明模型过拟合，方差比较高。这种情况可以通过降低模型复杂度，加大正则化系数，引入先验等方法来缓解。此外，还有一种有效的降低方差的方法为集成模型，即通过多个高方差模型的平均来降低方差。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"},{"name":"方差","slug":"方差","permalink":"http://thinkgamer.cn/tags/方差/"},{"name":"偏差","slug":"偏差","permalink":"http://thinkgamer.cn/tags/偏差/"}]},{"title":"基于神经网络实现Mnist数据集的多分类","slug":"TensorFlow/基于神经网络实现Mnist数据集的多分类","date":"2019-03-09T13:19:08.000Z","updated":"2019-10-14T06:42:35.678Z","comments":true,"path":"2019/03/09/TensorFlow/基于神经网络实现Mnist数据集的多分类/","link":"","permalink":"http://thinkgamer.cn/2019/03/09/TensorFlow/基于神经网络实现Mnist数据集的多分类/","excerpt":"在之前的文章中介绍了基于Logistic Regression实现Mnist数据集的多分类，本篇文章主要介绍基于TensorFlow实现Mnist数据集的多分类。","text":"在之前的文章中介绍了基于Logistic Regression实现Mnist数据集的多分类，本篇文章主要介绍基于TensorFlow实现Mnist数据集的多分类。 一个典型的神经网络训练图如下所示： 只不过在Mnist数据集是十分类的，起输出由y1和y2换成y1，….，y10。本文实现的神经网络如下所示： 这是使用的是两层的神经网络，第一层神经元个数是256，第二层为128，最终输出的是10个类别。对应的神经网络结果如下图所示： 接着我们创建一个MutilClass类，并初始化相关参数用来实现基于神经网络的多分类函数。 1234567891011121314151617181920212223242526272829import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data class MutilClass: def __init__(self): # 加载数据集 self.Mnsit = input_data.read_data_sets(\"./data/\", one_hot=True) # 设置神经网络层参数 self.n_hidden_1 = 256 self.n_hidden_2 = 128 self.n_input = 784 self.n_classes = 10 self.x = tf.placeholder(dtype=float, shape=[None, self.n_input], name=\"x\") self.y = tf.placeholder(dtype=float, shape=[None, self.n_classes], name=\"y\") # random_normal 高斯分布初始化权重 self.weights = &#123; \"w1\": tf.Variable(tf.random_normal([self.n_input, self.n_hidden_1],stddev = 0.1)), \"w2\": tf.Variable(tf.random_normal([self.n_hidden_1, self.n_hidden_2], stddev = 0.1)), \"out\": tf.Variable(tf.random_normal([self.n_hidden_2, self.n_classes], stddev = 0.1)) &#125; self.bias = &#123; \"b1\": tf.Variable(tf.random_normal([ self.n_hidden_1 ])), \"b2\": tf.Variable(tf.random_normal([ self.n_hidden_2 ])), \"out\": tf.Variable(tf.random_normal([ self.n_classes ])) &#125; print(\"参数初始化完成！\") 神经网络首次循环，是根据初始化的参数和偏置，向前传播，经过两层隐层，最终的到一个对应各个类别的概率，然后再根据反向传播，最小化损失函数求解参数，所以这里创建一个前向传播和反向传播的函数，如下所示：1234567891011121314151617# 定义一个MLP，前向感知器def _multilayer_perceptron(self,_X, _weights, _bias): layer_1 = tf.nn.sigmoid(tf.add ( tf.matmul(_X, _weights[\"w1\"]), _bias[\"b1\"] ) ) layer_2 = tf.nn.sigmoid(tf.add ( tf.matmul(layer_1, _weights[\"w2\"]), _bias[\"b2\"] ) ) return (tf.matmul( layer_2 ,_weights[\"out\"] ) + _bias[\"out\"]) # 定义反向传播def _back_propagation(self): pred = self._multilayer_perceptron(self.x, self.weights, self.bias) # logits 未归一化的概率 cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=pred, labels=self.y) ) optimizer = tf.train.GradientDescentOptimizer( learning_rate= 0.001).minimize(cost) corr = tf.equal(tf.argmax(pred, 1), tf.argmax(self.y, 1) ) accr =tf.reduce_mean(tf.cast(corr, dtype=float)) init = tf.global_variables_initializer() return init, optimizer,cost, accr 接着就是训练网络了，指定的迭代次数为：100，batch_size：100，其对应的函数未： 12345678910111213141516171819202122232425262728# 训练模型def _train_model(self, _init, _optimizer, _cost, _accr): epochs = 100 batch_size = 100 display_steps = 1 sess = tf.Session() sess.run(_init) for epoch in range(epochs): avg_cost = 0 total_batch = int (self.Mnsit.train.num_examples / batch_size) for i in range(total_batch): batch_xs, batch_ys = self.Mnsit.train.next_batch(batch_size) feeds = &#123;self.x: batch_xs, self.y: batch_ys&#125; sess.run(_optimizer, feed_dict=feeds) avg_cost += sess.run(_cost, feed_dict=feeds) avg_cost = avg_cost / total_batch if (epoch +1) % display_steps ==0: print(\"Epoch: &#123;&#125; / &#123;&#125;, cost: &#123;&#125;\".format(epoch, epochs, avg_cost)) feeds = &#123;self.x: batch_xs, self.y: batch_ys&#125; train_acc = sess.run(_accr, feed_dict=feeds) print(\"Train Accuracy: &#123;&#125;\".format(train_acc)) feeds = &#123;self.x : self.Mnsit.test.images, self.y: self.Mnsit.test.labels&#125; test_acc = sess.run(_accr, feed_dict= feeds) print(\"Test Accuracy: &#123;&#125;\".format(test_acc)) print(\"-\" * 50) 创建主函数，进行迭代训练1234if __name__ == \"__main__\": network = MutilClass() init, optimizer, cost, accr = network._back_propagation() network._train_model(init, optimizer,cost, accr) 最后的迭代结果为：123456789101112131415161718192021222324Epoch: 0 / 100, cost: 2.4407591546665537Train Accuracy: 0.12999999523162842Test Accuracy: 0.12960000336170197--------------------------------------------------Epoch: 1 / 100, cost: 2.290777679356662Train Accuracy: 0.12999999523162842Test Accuracy: 0.1469999998807907--------------------------------------------------Epoch: 2 / 100, cost: 2.2774649468335237Train Accuracy: 0.17000000178813934Test Accuracy: 0.21799999475479126-------------------------------------------------- ....... --------------------------------------------------Epoch: 98 / 100, cost: 0.7186844098567963Train Accuracy: 0.8299999833106995Test Accuracy: 0.8371999859809875--------------------------------------------------Epoch: 99 / 100, cost: 0.7124480505423112Train Accuracy: 0.8100000023841858Test Accuracy: 0.8377000093460083-------------------------------------------------- 从结果中可以看出，cost是一直在减少，训练集和测试集评估模型的准确率也在一直提高。当然我们也可以通过调节epoch，batch_size来重新训练模型。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://thinkgamer.cn/tags/TensorFlow/"},{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"【技术分享】机器学习在微博信息流推荐中的应用实践","slug":"Share/【技术分享】机器学习在微博信息流推荐中的应用实践","date":"2019-03-05T00:03:35.000Z","updated":"2019-10-14T06:42:35.672Z","comments":true,"path":"2019/03/05/Share/【技术分享】机器学习在微博信息流推荐中的应用实践/","link":"","permalink":"http://thinkgamer.cn/2019/03/05/Share/【技术分享】机器学习在微博信息流推荐中的应用实践/","excerpt":"本文分为四部分介绍机器学习在微博信息流中的应用实践，分别为：微博信息流推荐场景介绍，内容理解与用户画像，大规模推荐系统实践和总结展望。","text":"本文分为四部分介绍机器学习在微博信息流中的应用实践，分别为：微博信息流推荐场景介绍，内容理解与用户画像，大规模推荐系统实践和总结展望。 微博信息流推荐场景介绍 微博的feed流内容形态各异，有视频，图片，文字，长文，问答等，其用户量也很大，2018年Q2统计DAU（日活）为1.9亿，MAU（月活）为4.3亿，这么庞大的用户量，如何做好首页feed流的个性化推荐就显得格外重要。 内容理解与用户画像 由于个性化推荐是给用户推荐其感兴趣的内容，所以对于微博的内容理解和用户画像部分就显得格外重要。内容理解即通过文本内容理解和视觉理解技术，对微博内容进行细粒度表征，即形成每篇微博内容的表征向量。 用户画像即基于用户的发博内容，行为数据，自填信息等进行深度挖掘，精准分析刻画用户，从而在进行微博内容推送时能够实现其个性化。 大规模推荐系统实践 目前推荐架构的实现思路都是先从海量原始数据中，依据用户画像，召回用户偏好的数据，在利用排序算法对其进行排序，最终选择top K返回给用户。微博推荐亦是如此。其整体的流程图如下所示： 物料召回：即从候选物料集合中粗筛物料，作为进行模型的待排序物料。 算法排序则是结合相关特征对物料召回的内容进行预估排序，其特征主要分为：用户特征，内容特征，环境特征，组合特征和上下文特征等。 总结与展望 总结 业务和数据决定了模型算法的应用场景 模型算法殊途同归 工程能力和算法架构是基本保障 展望 采用多模型融合，能更好的对非结构化内容进行表征 更多的融合网络结构适用于CTR预估场景 完整内容请阅读原文：https://blog.csdn.net/Gamer_gyt/article/details/88164127 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"http://thinkgamer.cn/tags/技术分享/"}]},{"title":"TensorFlow实现Mnist数据集的多分类逻辑回归模型","slug":"TensorFlow/TensorFlow实现Mnist数据集的多分类逻辑回归模型","date":"2019-02-27T05:15:55.000Z","updated":"2019-10-14T06:42:35.677Z","comments":true,"path":"2019/02/27/TensorFlow/TensorFlow实现Mnist数据集的多分类逻辑回归模型/","link":"","permalink":"http://thinkgamer.cn/2019/02/27/TensorFlow/TensorFlow实现Mnist数据集的多分类逻辑回归模型/","excerpt":"多分类逻辑回归基于逻辑回归（Logistic Regression，LR）和softMax实现，其在多分类分类任务中应用广泛，本篇文章基于tf实现多分类逻辑回归，使用的数据集为Mnist。","text":"多分类逻辑回归基于逻辑回归（Logistic Regression，LR）和softMax实现，其在多分类分类任务中应用广泛，本篇文章基于tf实现多分类逻辑回归，使用的数据集为Mnist。 多分类逻辑回归的基础概要和在Spark上的实现可参考： 多分类逻辑回归（Multinomial Logistic Regression） 多分类实现方式介绍和在Spark上实现多分类逻辑回归（Multinomial Logistic Regression） 本篇文章涉及到的tf相关接口函数及释义如下： tf.nn.softmaxSoftmax 在机器学习和深度学习中有着非常广泛的应用。尤其在处理多分类（C &gt; 2）问题，分类器最后的输出单元需要Softmax 函数进行数值处理。关于Softmax 函数的定义如下所示： … 完整内容请阅读原文：https://blog.csdn.net/Gamer_gyt/article/details/87970776 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://thinkgamer.cn/tags/TensorFlow/"}]},{"title":"深度学习中的epochs、batch_size、iterations详解","slug":"TensorFlow/深度学习中的epochs、batch_size、iterations详解","date":"2019-02-25T16:32:29.000Z","updated":"2019-10-14T06:42:35.679Z","comments":true,"path":"2019/02/26/TensorFlow/深度学习中的epochs、batch_size、iterations详解/","link":"","permalink":"http://thinkgamer.cn/2019/02/26/TensorFlow/深度学习中的epochs、batch_size、iterations详解/","excerpt":"深度学习中涉及到很多参数，如果对于一些参数不了解，那么去看任何一个框架都会有难度，在TensorFlow中有一些模型训练的基本参数，这些参数是训练模型的前提，也在一定程度上影响着模型的最终效果。下面主要介绍几个参数。","text":"深度学习中涉及到很多参数，如果对于一些参数不了解，那么去看任何一个框架都会有难度，在TensorFlow中有一些模型训练的基本参数，这些参数是训练模型的前提，也在一定程度上影响着模型的最终效果。下面主要介绍几个参数。 batch_size iterations epochs batch_size深度学习的优化算法，其实就是梯度下降，在之前的文章中我们也介绍过梯度下降，这里就不详细说明。梯度下降分为三种： 批量梯度下降算法（BGD，Batch gradient descent algorithm） 随机梯度下降算法（SGD，Stochastic gradient descent algorithm） 小批量梯度下降算法（MBGD，Mini-batch gradient descent algorithm） 批量梯度下降算法，每一次计算都需要遍历全部数据集，更新梯度，计算开销大，花费时间长，不支持在线学习。 随机梯度下降算法，每次随机选取一条数据，求梯度更新参数，这种方法计算速度快，但是收敛性能不太好，可能在最优点附近晃来晃去，hit不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，mini-batch gradient decent，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 tf框架中的batch_size指的就是更新梯度中使用的样本数。当然这里如果把batch_size设置为数据集的长度，就成了批量梯度下降算法，batch_size设置为1就是随机梯度下降算法。 iterations迭代次数，每次迭代更新一次网络结构的参数。 迭代是重复反馈的动作，神经网络中我们希望通过迭代进行多次的训练以到达所需的目标或结果。 每一次迭代得到的结果都会被作为下一次迭代的初始值。 一个迭代 = 一个（batch_size）数据正向通过（forward）+ 一个（batch_size）数据反向（backward） 前向传播：构建由（x1,x2,x3）得到Y（hwb(x)）的表达式 反向传播：基于给定的损失函数，求解参数的过程 epochsepochs被定义为前向和反向传播中所有批次的单次训练迭代。这意味着1个周期是整个输入数据的单次前向和反向传递。 简单说，epochs指的就是训练过程中数据将被“轮”多少次 例如在某次模型训练过程中，总的样本数是10000，batch_size=100，epochs=10，其对应的伪代码如下：123456789data = batch_size = 100for i in range(epochs): for j in range(int(data_length / batch_size - 1)): x_data = data[begin:end, ] y_data = data[begin:end, ] mode.train(x_data, y_data) begin += batch_size end += batch_size 其中iterations = data_length / batch_size 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://thinkgamer.cn/tags/TensorFlow/"},{"name":"神经网络","slug":"神经网络","permalink":"http://thinkgamer.cn/tags/神经网络/"}]},{"title":"Spark排序算法系列之（MLLib、ML）GBTs使用方式介绍","slug":"RecSys/Spark排序算法/Spark排序算法系列之（MLLib、ML）GBTs使用方式介绍","date":"2019-01-29T13:16:35.000Z","updated":"2019-10-14T06:42:35.664Z","comments":true,"path":"2019/01/29/RecSys/Spark排序算法/Spark排序算法系列之（MLLib、ML）GBTs使用方式介绍/","link":"","permalink":"http://thinkgamer.cn/2019/01/29/RecSys/Spark排序算法/Spark排序算法系列之（MLLib、ML）GBTs使用方式介绍/","excerpt":"【Spark排序算法系列】主要介绍的是目前推荐系统或者广告点击方面用的比较广的几种算法，和他们在Spark中的应用实现，本篇文章主要介绍GBDT算法.","text":"【Spark排序算法系列】主要介绍的是目前推荐系统或者广告点击方面用的比较广的几种算法，和他们在Spark中的应用实现，本篇文章主要介绍GBDT算法. 前言本系列还包括（持续更新）： Spark排序算法系列之LR（逻辑回归） Spark排序算法系列之模型融合（GBDT+LR） Spark排序算法系列之XGBoost Spark排序算法系列之FTRL（Follow-the-regularized-Leader） Spark排序算法系列之FM与FFM 在本篇文章中你可以学到： Spark MLLib包中的GBDT使用方式 模型的通过保存、加载、预测 PipeLine ML包中的GBDT 概述LR因为其容易并行最早应用到推荐排序中的，但学习能力有限，需要大量的特征工程来增加模型的学习能力。但大量的特征工程耗时耗力，且不一定带来效果的提升，因此在如何能有效的发现特征组合，来缩短LR特征实验周期的背景下，GBDT被应用了起来。GBDT模型全称是Gradient Boosting Decision Tree，梯度提升决策树。是属于Boosing算法中的一种，关于Boosting的介绍可以参考文章集成学习（Ensemble Learning) 关于GBDT算法理解可参考： Spark排序算法系列之GBTs基础——梯度上升和梯度下降 梯度提升决策树GBDT（Gradient Boosting Decision Tree） 其实相信很多人对Spark 机器学习包（ml和mllib）中的GBDT傻傻分不清楚，这里我们先来捋一捋。Spark中的GBDT较GBTs——梯度提升树，因为其是基于决策树（Decision Tree，DT）实现的，所以叫GBDT。Spark 中的GBDT算法存在于ml包和mllib包中，mllib是基于RDD的，ml包则是针对DataFrame的，ml包中的GBDT分为分类和回归，在实际使用过程中，需要根据具体情况进行衡量和选择。由于在实际生产环境中使用基于RDD的较多，所以下面将着重介绍下MLLib包中的GBTs，ML包中的将进行简单说明。 完整内容请阅读原文：https://blog.csdn.net/Gamer_gyt/article/details/86695837 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"},{"name":"CTR","slug":"CTR","permalink":"http://thinkgamer.cn/tags/CTR/"}]},{"title":"【资源分享】从数理统计到DL、RL，还不快来！","slug":"Share/【资源分享】从数理统计到DL、RL，还不快来","date":"2019-01-27T19:16:19.000Z","updated":"2019-10-14T06:42:35.673Z","comments":true,"path":"2019/01/28/Share/【资源分享】从数理统计到DL、RL，还不快来/","link":"","permalink":"http://thinkgamer.cn/2019/01/28/Share/【资源分享】从数理统计到DL、RL，还不快来/","excerpt":"之前在自己的年度总结里写到：19年的目标就是技术沉淀与突破。技术突破不仅包含现有技术的总结和反思，更是对未知技术的探索和求知，希望19年能够更上一层楼。","text":"之前在自己的年度总结里写到：19年的目标就是技术沉淀与突破。技术突破不仅包含现有技术的总结和反思，更是对未知技术的探索和求知，希望19年能够更上一层楼。 这个repo是我一直维护和整理的一个技术资料分享的repo，是我包括群友一块整理的一个免费技术资料分享的库，不仅包含了机器学习，数据挖掘，深度学习，还包含了大数据，数理统计，强化学习等，希望在技术这条路上你能跑的更快。 repo：https://github.com/Thinkgamer/books 先来张图片镇楼！！！ Why建立该Repo的目的有两个： 本人在各个平台共享书籍，进行一个统一管理 分享给各个搞技术的朋友，知识无私藏之说 What该Repo会涉及包含以下类别书籍： 机器学习 数据挖掘 深度学习 NLP 云计算 统计学概率论 收藏的论文 杂乱无章 List注明：排名无先后顺序 机器学习 scikit-learn 中英文 机器学习-周志华 机器学习实战 机器学习导论 集体智慧编程中文版 [英文版]叶斯思维：统计建模的Python学习法 数据挖掘 python数据分析与挖掘实战 利用python进行数据分析 面向程序员的数据挖掘指南 数据挖掘：概念与技术（中文第三版） 数据挖掘应用20个案例分析 数据挖掘与数据化运营实战_思路_方法_技巧与应用_完整版 深度学习 神经网络与机器学习（加）Simon Haykin TensorFlow实战-黄文坚 深度学习 中文版 神经网络与深度学习 NLP 模式识别与机器学习 中文版 NLP汉语自然语言处理原理与实践 PYTHON自然语言处理中文版 推荐系统 推荐系统实践 learning-to-rank.pdf Recommender Systems Handbook.pdf Context-Aware-Recommender-Systems-chapter-7.pdf 云计算 《快学Scala》 Learning PySpark.pdf SparkMLlib机器学习 Spark快速大数据分析 数据算法 Hadoop Spark大数据处理技巧 统计学与概率论 《概率论与数理统计》浙大版（第四版）教材 《概率论与数理统计习题全解指南》.浙大版（第四版） 数理统计与数据分析原书第3版 应用商务统计分析 王汉生(2008).pdf 收藏的论文 平滑系数自适应的二次指数平滑模型及其应用 The Structure of Collaborative Tagging Systems FM FFM DeepFFM Focal Loss for Dense Object Detection Attentive Group Recommendation.pdf Real-time Personalization using Embeddings for Search.pdf 杂乱无章 阿里技术之瞳-p260 数据敏感性测试 正则表达式经典实例.（美）高瓦特斯，（美）利维森 阿里广告中的机器学习平台.pdf 广告数据上的大规模机器学习.pdf 绿盟大数据安全分析平台 产品白皮书.pdf Xdef2013-基于机器学习和NetFPGA的智能高速入侵防御系统.ppt 04-程佳-推荐广告机器学习实践 A Gentle Introduction to Gradient Boosting.pdf GBDT算法原理与系统设计简介.pdf [微博] 机器学习在微博信息流推荐应用实践.pdf [知乎] 首页信息流系统的框架及机器学习技术在推荐策略中的应用.pdf 强化学习 强化学习在阿里的技术演进与业务创新.pdf 技术集锦 AAAI2018.pdf 数字经济下的算法力量.pdf 2018美团点评算法系列.pdf Learning To Rank在个性化电商搜索中的应用 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"资源分享","slug":"资源分享","permalink":"http://thinkgamer.cn/tags/资源分享/"}]},{"title":"多分类实现方式介绍和在Spark上实现多分类逻辑回归","slug":"机器学习/多分类实现方式介绍和在Spark上实现多分类逻辑回归","date":"2019-01-12T14:06:02.000Z","updated":"2019-10-14T06:42:35.685Z","comments":true,"path":"2019/01/12/机器学习/多分类实现方式介绍和在Spark上实现多分类逻辑回归/","link":"","permalink":"http://thinkgamer.cn/2019/01/12/机器学习/多分类实现方式介绍和在Spark上实现多分类逻辑回归/","excerpt":"本文主要介绍多分类实现方式介绍和在Spark上实现多分类逻辑回归。","text":"本文主要介绍多分类实现方式介绍和在Spark上实现多分类逻辑回归。 背景在之前的文章中介绍了多分类逻辑回归算法的数据原理，参考文章链接 CSDN文章链接：https://blog.csdn.net/Gamer_gyt/article/details/85209496该篇文章介绍一下Spark中多分类算法，主要包括的技术点如下 多分类实现方式 一对一 （One V One） 一对其余（One V Remaining） 多对多 （More V More） Spark中的多分类实现多分类实现方式一对一假设某个分类中有N个类别，将这N个类别两两配对（继而转化为二分类问题），这样可以得到 N（N-1）/ 2个二分类器，这样训练模型时需要训练 N（N-1）/ 2个模型，预测时将样本输送到这些模型中，最终统计出现次数较多的类别结果作为最终类别。 假设现在有三个类别：类别A，类别B，类别C，类别D。一对一实现多分类如下图所示： 完整内容请阅读原文：https://blog.csdn.net/Gamer_gyt/article/details/86378882 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"},{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"多分类","slug":"多分类","permalink":"http://thinkgamer.cn/tags/多分类/"}]},{"title":"Hive Join 分析和优化","slug":"Spark/Hive Join 分析和优化","date":"2019-01-03T05:34:48.000Z","updated":"2019-10-14T06:42:35.674Z","comments":true,"path":"2019/01/03/Spark/Hive Join 分析和优化/","link":"","permalink":"http://thinkgamer.cn/2019/01/03/Spark/Hive Join 分析和优化/","excerpt":"Sku对应品牌进行关联，大表对应非大表（这里的非大表并不能用小表来定义）","text":"Sku对应品牌进行关联，大表对应非大表（这里的非大表并不能用小表来定义） 问题分析进行表左关联时，最后一个reduce任务卡到99%，运行时间很长，发生了严重的数据倾斜。 什么是数据倾斜？数据倾斜主要表现在，map /reduce程序执行时，reduce节点大部分执行完毕，但是有一个或者几个reduce节点运行很慢，导致整个程序的处理时间很长，这是因为某一个key的条数比其他key多很多（有时是百倍或者千倍之多），这条key所在的reduce节点所处理的数据量比其他节点就大很多，从而导致某几个节点迟迟运行不完。 完整内容请阅读原文：https://blog.csdn.net/Gamer_gyt/article/details/85690885 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"},{"name":"Hive","slug":"Hive","permalink":"http://thinkgamer.cn/tags/Hive/"}]},{"title":"TensorFlow 特征工程:feature_column","slug":"TensorFlow/TensorFlow 特征工程: feature_column","date":"2019-01-03T05:18:16.000Z","updated":"2019-11-14T02:15:42.336Z","comments":true,"path":"2019/01/03/TensorFlow/TensorFlow 特征工程: feature_column/","link":"","permalink":"http://thinkgamer.cn/2019/01/03/TensorFlow/TensorFlow 特征工程: feature_column/","excerpt":"在使用很多模型的时候，都需要对输入的数据进行必要的特征工程处理。最典型的就是:one-hot处理，还有hash分桶等处理。为了方便处理这些特征，tensorflow提供了一些列的特征工程方法来方便使用.","text":"在使用很多模型的时候，都需要对输入的数据进行必要的特征工程处理。最典型的就是:one-hot处理，还有hash分桶等处理。为了方便处理这些特征，tensorflow提供了一些列的特征工程方法来方便使用. 公共的import12345678910import tensorflow as tffrom tensorflow.python.estimator.inputs import numpy_ioimport numpy as npimport collectionsfrom tensorflow.python.framework import errorsfrom tensorflow.python.platform import testfrom tensorflow.python.training import coordinatorfrom tensorflow import feature_columnfrom tensorflow.python.feature_column.feature_column import _LazyBuilder numeric_column1234567numeric_column( key, shape=(1,), default_value=None, dtype=tf.float32, normalizer_fn=None) key：特征的名字。也就是对应的列名称 shape：该key所对应的特征的shape. 默认是1，但是比如one-hot类型的，shape就不是1，而是实际的维度。总之，这里是key所对应的维度，不一定是1 default_value：如果不存在使用的默认值 normalizer_fn：对该特征下的所有数据进行转换。如果需要进行normalize，那么就是使用normalize的函数.这里不仅仅局限于normalize，也可以是任何的转换方法，比如取对数，取指数，这仅仅是一种变换方法 完整内容请阅读：https://blog.csdn.net/Gamer_gyt/article/details/85689840 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://thinkgamer.cn/tags/TensorFlow/"},{"name":"特征工程","slug":"特征工程","permalink":"http://thinkgamer.cn/tags/特征工程/"}]},{"title":"集成学习（Ensemble Learning)","slug":"机器学习/集成学习（Ensemble Learning)","date":"2019-01-03T05:14:38.000Z","updated":"2019-10-14T06:42:35.689Z","comments":true,"path":"2019/01/03/机器学习/集成学习（Ensemble Learning)/","link":"","permalink":"http://thinkgamer.cn/2019/01/03/机器学习/集成学习（Ensemble Learning)/","excerpt":"在机器学习的有监督学习算法中，我们的目标是学习出一个稳定的且在各个方面表现都较好的模型，但实际情况往往不这么理想，有时我们只能得到多个有偏好的模型（弱监督模型，在某些方面表现的比较好）。集成学习就是组合这里的多个弱监督模型以期得到一个更好更全面的强监督模型，集成学习潜在的思想是即便某一个弱分类器得到了错误的预测，其他的弱分类器也可以将错误纠正回来。","text":"在机器学习的有监督学习算法中，我们的目标是学习出一个稳定的且在各个方面表现都较好的模型，但实际情况往往不这么理想，有时我们只能得到多个有偏好的模型（弱监督模型，在某些方面表现的比较好）。集成学习就是组合这里的多个弱监督模型以期得到一个更好更全面的强监督模型，集成学习潜在的思想是即便某一个弱分类器得到了错误的预测，其他的弱分类器也可以将错误纠正回来。 集成学习在各个规模的数据集上都有很好的策略。 数据集大：划分成多个小数据集，学习多个模型进行组合 数据集小：利用Bootstrap方法进行抽样，得到多个数据集，分别训练多个模型再进行组合 这篇博客介绍一下集成学习的几类：Bagging，Boosting以及Stacking。 BaggingBagging是bootstrap aggregating的简写。先说一下bootstrap，bootstrap也称为自助法，它是一种有放回的抽样方法，目的为了得到统计量的分布以及置信区间。具体步骤如下 采用重抽样方法（有放回抽样）从原始样本中抽取一定数量的样本 根据抽出的样本计算想要得到的统计量T 重复上述N次（一般大于1000），得到N个统计量T 根据这N个统计量，即可计算出统计量的置信区间 在Bagging方法中，利用bootstrap方法从整体数据集中采取有放回抽样得到N个数据集，在每个数据集上学习出一个模型，最后的预测结果利用N个模型的输出得到，具体地：分类问题采用N个模型预测投票的方式，回归问题采用N个模型预测平均的方式。 例如随机森林（Random Forest）就属于Bagging。随机森林简单地来说就是用随机的方式建立一个森林，森林由很多的决策树组成，随机森林的每一棵决策树之间是没有关联的。 在我们学习每一棵决策树的时候就需要用到Bootstrap方法。在随机森林中，有两个随机采样的过程：对输入数据的行（数据的数量）与列（数据的特征）都进行采样。对于行采样，采用有放回的方式，若有N个数据，则采样出N个数据（可能有重复），这样在训练的时候每一棵树都不是全部的样本，相对而言不容易出现overfitting；接着进行列采样从M个feature中选择出m个（m&lt;&lt;M）。最近进行决策树的学习。 预测的时候，随机森林中的每一棵树的都对输入进行预测，最后进行投票，哪个类别多，输入样本就属于哪个类别。这就相当于前面说的，每一个分类器（每一棵树）都比较弱，但组合到一起（投票）就比较强了。 Boosting提升方法（Boosting）是一种可以用来减小监督学习中偏差的机器学习算法。主要也是学习一系列弱分类器，并将其组合为一个强分类器。Boosting中有代表性的是AdaBoost（Adaptive boosting）算法：刚开始训练时对每一个训练例赋相等的权重，然后用该算法对训练集训练t轮，每次训练后，对训练失败的训练例赋以较大的权重，也就是让学习算法在每次学习以后更注意学错的样本，从而得到多个预测函数。具体可以参考《统计学习方法》。 StackingStacking方法是指训练一个模型用于组合其他各个模型。首先我们先训练多个不同的模型，然后把之前训练的各个模型的输出为输入来训练一个模型，以得到一个最终的输出。理论上，Stacking可以表示上面提到的两种Ensemble方法，只要我们采用合适的模型组合策略即可。但在实际中，我们通常使用logistic回归作为组合策略。 如下图，先在整个训练数据集上通过bootstrap抽样得到各个训练集合，得到一系列分类模型，称之为Tier 1分类器（可以采用交叉验证的方式学习），然后将输出用于训练Tier 2 分类器。 完整内容请阅读： https://blog.csdn.net/Gamer_gyt/article/details/85689424 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"集成学习","slug":"集成学习","permalink":"http://thinkgamer.cn/tags/集成学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"}]},{"title":"基于TF-IDF算法的短标题关键词提取","slug":"NLP/基于TF-IDF算法的短标题关键词提取","date":"2019-01-02T19:27:48.000Z","updated":"2019-10-14T06:42:35.661Z","comments":true,"path":"2019/01/03/NLP/基于TF-IDF算法的短标题关键词提取/","link":"","permalink":"http://thinkgamer.cn/2019/01/03/NLP/基于TF-IDF算法的短标题关键词提取/","excerpt":"TF-IDF（Term Frequency–InverseDocument Frequency）是一种用于资讯检索与文本挖掘的常用加权技术。TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。","text":"TF-IDF（Term Frequency–InverseDocument Frequency）是一种用于资讯检索与文本挖掘的常用加权技术。TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。 完整内容请阅读：https://blog.csdn.net/Gamer_gyt/article/details/85690389 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://thinkgamer.cn/tags/NLP/"},{"name":"TF_IDF","slug":"TF-IDF","permalink":"http://thinkgamer.cn/tags/TF-IDF/"}]},{"title":"【内附PDF资料】Python实现下载图片并生产PDF文件","slug":"Python/【内附PDF资料】Python实现下载图片并生产PDF文件","date":"2019-01-02T12:28:22.000Z","updated":"2019-10-14T06:42:35.663Z","comments":true,"path":"2019/01/02/Python/【内附PDF资料】Python实现下载图片并生产PDF文件/","link":"","permalink":"http://thinkgamer.cn/2019/01/02/Python/【内附PDF资料】Python实现下载图片并生产PDF文件/","excerpt":"背景：2018AICon大会中的一些PPT，官方没有提供完整的PDF文件，而是一张张图片，不方便下载和后续阅读，这里使用Python爬取相关演讲的图片，并生产PDF文件","text":"背景：2018AICon大会中的一些PPT，官方没有提供完整的PDF文件，而是一张张图片，不方便下载和后续阅读，这里使用Python爬取相关演讲的图片，并生产PDF文件 下载函数创建下载图片函数，使用的是Python的urllib库，代码如下 123456789101112# 下载图片def save_img(img_url,file_path=\"./img/\"): if not os.path.exists(file_path): print(\"保存图片的文件不存在，创建该目录\") os.mkdir(file_path) # 图片后缀 file_suffix = os.path.splitext(img_url)[1] file_name = str ( int(img_url.split(\"-\")[1].split(\".\")[0]) ) # 拼接图片名（包含路径） filename = '&#123;&#125;&#123;&#125;&#123;&#125;'.format(file_path,file_name,file_suffix) # urllib urllib.request.urlretrieve(img_url, filename=filename) 生成PDF函数创建图片生成PDF文件的函数，使用的是Python的reportlab库，代码如下12345678910111213141516# 生成pdfdef convert_img_to_pdf(img_path,pdf_path): pages = 0 (w, h) = landscape(portrait(A4)) can = canvas.Canvas(pdf_path, pagesize=landscape(portrait(A4))) # 获取img_path下文件，并进行排序 files = os.listdir(img_path) files.sort(key=lambda x: int(x[:-4])) # 遍历每个文件 for f_name in files: # 拼装成完整的file路径 file_path = img_path + os.sep + str(f_name) can.drawImage(file_path, 0, 0, w, h) can.showPage() pages = pages + 1 can.save() 需要注意的是，pagesize不能直接指定值portrait(A4)，因为一张图片会完整的嵌套在一页A4纸张上，极其不美观，这里需要将A4的大小进行转置，pagesize=landscape(portrait(A4)) 定义要生成的PDF相关信息123456789101112131415161718192021222324252627282930313233_list = ( &#123; \"pdf_name\": \"FFM及DeepFFM模型在推荐系统的探索及实践.pdf\", \"img_path\": \"./img_1/\", \"page\": 52, \"id\": \"3670025915\" &#125;,&#123; \"pdf_name\": \"知乎推荐系统的实践及重构之路.pdf\", \"img_path\": \"./img_2/\", \"page\": 38, \"id\": \"4291192513\" &#125;,&#123; \"pdf_name\": \"深度树匹配——下一代推荐技术的探索和实践.pdf\", \"img_path\": \"./img_3/\", \"page\": 33, \"id\": \"3621355867\" &#125;,&#123; \"pdf_name\": \"基于知识的搜索推荐技术及应用.pdf\", \"img_path\": \"./img_4/\", \"page\": 31, \"id\": \"436657700\" &#125;,&#123; \"pdf_name\": \"瓜子二手车个性化推荐的挑战与应对.pdf\", \"img_path\": \"./img_5/\", \"page\": 40, \"id\": \"1433077746\" &#125;,&#123; \"pdf_name\": \"机器学习在苏宁搜索平台中的实践.pdf\", \"img_path\": \"./img_6/\", \"page\": 55, \"id\": \"1155556309\" &#125;) 生成PDF遍历要生成PDF的每个信息123456789101112131415for one in _list: print(one) for i in range(1,one[\"page\"]+1): img_path = one[\"img_path\"] pdf_path = one[\"pdf_name\"] if i &lt; 10: img_url = \"https://static001.geekbang.org/con/37/pdf/\" + one[\"id\"] + \"/image/page-00\" + str(i) + \".jpg\" else: img_url = \"https://static001.geekbang.org/con/37/pdf/\" + one[\"id\"] + \"/image/page-0\" + str(i) + \".jpg\" print(img_url) # 下载图片 save_img(img_url,img_path) # 合成pdf convert_img_to_pdf(img_path, pdf_path) print(\"Image转PDF完成！\") PDF文件资料获取方式：百度网盘 链接：https://pan.baidu.com/s/1MC_bH2x5jjsP1LvBB5cZCA 提取码：58zq 原文链接：https://blog.csdn.net/Gamer_gyt/article/details/85637436 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkgamer.cn/tags/Python/"},{"name":"资源分享","slug":"资源分享","permalink":"http://thinkgamer.cn/tags/资源分享/"}]},{"title":"趁“未老”，再认真一次，我觉得你能更好！","slug":"随手记/趁“未老”，再认真一次，我觉得你能更好！","date":"2018-12-28T20:22:41.000Z","updated":"2019-10-14T06:42:35.693Z","comments":true,"path":"2018/12/29/随手记/趁“未老”，再认真一次，我觉得你能更好！/","link":"","permalink":"http://thinkgamer.cn/2018/12/29/随手记/趁“未老”，再认真一次，我觉得你能更好！/","excerpt":"每一年的年尾，我都会问自己：这一年，我收获了什么？ 你呢？","text":"每一年的年尾，我都会问自己：这一年，我收获了什么？ 你呢？ 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/85333470博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer公众号：搜索与推荐Wiki个人网站：http://thinkgamer.github.io Chapter 1这一年，我收获了很多东西，也学会和体验到了很多，用户八个字来概括就是：不忘粗心，方得始终。 小白 4月29号那天，我发了个朋友圈，说买了个小白，不说钱、不说事，只说这是我人生路上的另外一个小伙伴。如今7个月过去了，小白也从最开始跑到了现在的8000公里，虽然在北京受到限号等政策的影响，但他还是发挥了很大的价值。 露营 不得不说这是我2018年玩过最刺激的游戏，找一个风和日丽的日子，背上行囊，前往露营圣地，18年总共出去了两次，一次是北京第一高峰——灵山，一次是北京第二高峰——海坨山。2019会进行更多的露营活动，玩的就是心跳 海坨山 穿过云烟雾绕的盘山路，看到了那一片世外与桃园。对于海坨山向往已久，终于拉上小伙伴开始了人生第一次露营，只能说真刺激，中午到达时下雨，上山时下雨，晚上下雨，第二天早上下雨，第一次露营简直就是与山上挨冻淋雨的，好歹看到的风景不错，经历的事情比较有趣，记录的情节比较美好，这一切便是值得的。 灵山 去灵山时记忆比较深刻的是，负重20kg，爬了4个小时，在接近山顶的地方安营扎寨，然后，然后那天晚上又遇到了大雨，当时心中简直是一万只草泥马在驷马奔腾，不过有趣的是第一次在室外煮了个面，然后又在雨中担惊受怕的睡了一晚。第二天早上，雨过天晴，看到的云，听到的风，让人觉得这所经历的一切都是值得的。 济州岛 人生的第一次出国，选的是韩国的济州岛，选择这个地方的原因主要是不需要办签证，方便，离北京近，飞机三个小时就到了，而且最重要的是这里是纯天然的自然风景，比较符合我欣赏风景的调调。 第一次出国整体非常顺利，无论是Airbnb订房，到达之后的房东的款待，还是在那的沟通交流，都让人非常的惊喜和愉快。济州岛的生活状态很缓慢，让人非常舒服，最重要的还是自然景色不错，文化生活体验不错，心情不错。 在济州岛最让我惊讶的一件事情是：在发展如此迅速的时代，海女真的存在，他们潜入海底，带回一些水产品，然后出售给海岛上的饭店，赚取生活的费用。由于长期潜水，他们的脸部已经发生了变形，出于尊重，我没有拍照。而且韩国载册的海女记录人数是在不断减少的，韩国济州岛的海女文化被列入联合国教科文组织人类非物质文化遗产名录。同时海女在二战期间，爆发了抗日独立运动，对反法西斯战争有着不同寻常的意义。 真的是每一种文化都值得被尊敬。 618 在京东经历了第一个618大促，当时是出于好奇参加的，可能是职业的特殊性，我们算法这边感觉没那么忙，不过数据端和服务端倒是一直绷着神经。 同样是618，第一次近距离的接触了一些明星，有胡夏，金志文，张信哲，苏运莹，第一次离明星们那么近，多多少少还是很激动的。 拄拐 这一年，也第一次用了双拐，因为打篮球把右脚崴着了，拄着拐杖上了两周班，说实话很尴尬呀 Chapter 2最近刚好组内进行2018的总结汇报，就顺道把自己18年的工作和技术成长都总结了下。 2018年，自己在技术上也成长了很多，不管是对于推荐算法的理解掌握，还是架构的迁移理解，都学会了很多东西，在整个过程中对于自己的工程开发能力也有了一定的提高，算法的应用和业务理解都有很深刻的认知。整个过程中还是非常感谢组长娜姐对我的帮助和指导，从娜姐和其他人的身上真的学到了很多东西，算法理论的扎实，流程的规范和优秀的问题解决能力。 2018年也对自己过往知识进行了总结，整个文档和章节会在后续给出，想进行阅读的朋友可以持续关注本公众号。 Chapter 32019是一个新的开始，希望自己能够重新的去沉淀一下技术，同时走更多的路，看更多的风景，阅更丰富的人生。 露营持续进行 自驾，探索户外 相关论文阅读，要求至少一月一篇 深度在线排序研究和实践 实时在线学习研究和实践 深度架构探索和应用 认真学习，总结文章，用心经营微信公众号 2019，加油，相信你可以在匆匆的人流中，驻足欣赏那交错斑影。 Chapter 4人生没有一帆风顺的，也没有顺心顺意的，那些无谓的事，无谓的人，你又何必care呢，做好自己，不值得交的人不必凡事耿耿于心，不必要嫉妒的事，不必事事亲为，做好自己，就好了。 认真对待生活中的每一件小事，任何一件小事，只要你坚持下去，这便是很值得人尊敬和钦佩了。 19年，一起加油！ 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/tags/随手记/"}]},{"title":"多分类逻辑回归（Multinomial Logistic Regression）","slug":"机器学习/多分类逻辑回归（Multinomial Logistic Regression）","date":"2018-12-21T07:53:10.000Z","updated":"2019-10-14T06:42:35.686Z","comments":true,"path":"2018/12/21/机器学习/多分类逻辑回归（Multinomial Logistic Regression）/","link":"","permalink":"http://thinkgamer.cn/2018/12/21/机器学习/多分类逻辑回归（Multinomial Logistic Regression）/","excerpt":"分类从结果的数量上可以简单的划分为： 二分类（Binary Classification） 多分类（Multinomial Classification）。","text":"分类从结果的数量上可以简单的划分为： 二分类（Binary Classification） 多分类（Multinomial Classification）。 前言其中二分类是最常见且使用最多的分类场景，解决二分类的算法有很多，比如： 基本的KNN、贝叶斯、SVM Online Ranking中用来做二分类的包括FM、FFM、GBDT、LR、XGBoost等 多分类中比如： 改进版的KNN、改进版的贝叶斯、改进版的SVM等 多类别的逻辑回归啰嗦了这么多，其实就是为了说这个多分类的逻辑回归。 简介在统计学里，多类别逻辑回归是一个将逻辑回归一般化成多类别问题得到的分类方法。用更加专业的话来说，它就是一个用来预测一个具有类别分布的因变量不同可能结果的概率的模型。 另外，多类别逻辑回归也有很多其它的名字，包括polytomous LR，multiclass LR，softmax regression，multinomial logit，maximum entropy classifier，conditional maximum entropy model。 在多类别逻辑回归中，因变量是根据一系列自变量（就是我们所说的特征、观测变量）来预测得到的。具体来说，就是通过将自变量和相应参数进行线性组合之后，使用某种概率模型来计算预测因变量中得到某个结果的概率，而自变量对应的参数是通过训练数据计算得到的，有时我们将这些参数成为回归系数。 模型分析原文：https://blog.csdn.net/Gamer_gyt/article/details/85209496 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"http://thinkgamer.cn/tags/逻辑回归/"},{"name":"多分类","slug":"多分类","permalink":"http://thinkgamer.cn/tags/多分类/"}]},{"title":"【论文】基于三部图网络结构的知识推荐算法","slug":"论文/【论文】基于三部图网络结构的知识推荐算法","date":"2018-07-13T08:45:14.000Z","updated":"2019-11-14T02:26:37.482Z","comments":true,"path":"2018/07/13/论文/【论文】基于三部图网络结构的知识推荐算法/","link":"","permalink":"http://thinkgamer.cn/2018/07/13/论文/【论文】基于三部图网络结构的知识推荐算法/","excerpt":"该论文是北京一高校学生的论文，其主要是基于用户-物品-标签这样的三部图网络展开描述的。下面主要介绍一些其中提出的可用的点，其余的详细介绍可参考原文章。","text":"该论文是北京一高校学生的论文，其主要是基于用户-物品-标签这样的三部图网络展开描述的。下面主要介绍一些其中提出的可用的点，其余的详细介绍可参考原文章。 背景推荐算法是个性化推荐的核心，现有的推荐算法（除了点击率预估之外的）包括： 基于内容的推荐算法 基于项目的协同过滤算法 基于用户的协同过滤算法 基于模型的协同过滤算法 基于社会网络分析方法的算法 基于网络结构的推荐算法 基于网络结构的推荐算法大部分是基于二部图来对用户进行个性化推荐，这种推荐算法不能有效地解决用户冷启动和冷门物品推荐的问题，本文针对现有算法的不足，提出了一种加权的三部图网络结构的知识推荐算法，在三部图网络模型的基础上设计了新的推荐算法。 三部图网络结构算法项目-用户-标签的三部图可以表示为：{U,I,T}，其中U表示用户集合，I表示物品结合，T表示标签集合。在此三部图结构中，不仅用户与项目以及 用户与标签之间存在联系，项目与项目、用户与用户以及标签 与标签之间也存在联系。 如图 1所示，使用三部图对项目—用户—标签的三元组进行相关模型建立，对三部图模型进行用户—项目、用户—标签 和项目—标签的二部图的扩散。最终的推荐算法是建立在用户—项目、用户—标签和项目—标签二部图网络结构的基础上。 项目的度和权重对推荐算法的影响 1. 项目的评分相似性及改进基于用户-项目网络结构的推荐系统把用户和项目仅仅看成抽象的节点，所有算法利用的信息都隐藏在用户和项目的关系之中。用户-物品的二部图提出了一种资源分配的算法。假设 j 选择过的所有产品都具有某种向 i推荐其他产品的能力，这个 抽象的能力看做是相关产品上的某种可分的资源，表示产品 j 愿意分配给产品 i的资源配额(产品的相似性)。 sim(i,j) = \\frac{1}{ k_j } \\sum_{l=1}^{m}\\frac{ a_{il} b_{jl} }{k_l}其中： k_j 表示物品j的度（即被多少用户产生过行为） k_l 表示用户l的度（即用户u对多少个物品产生过行为） a_il 表示用户 l 是否对物品i产生过行为，产生过行为为1，没有产生过行为为0 传统的二部网络图结构只注意到了用户是否对物品产生过行为，忽略了用户对物品的评分，容易造成信息的损失。本文中保留了用户对物品的评分信息，对用户到物品的边增加一个权重w，w的大小根据用户对物品的评分确定。 假设用户对物品的评分最多为5分，则w=score/5，所以w的范围是[0,1]，score表示用户对物品的评分。则改进后的物品相似度计算公式为： sim'{(i,j)} = \\frac{1}{ d(I_j) } \\sum_{a=1}^{m}\\frac{ w_{ia} w_{ja} }{d(u_a)}其中： d(I_j) = \\sum_{k=1}^{l} w_{kj}表示项目I_j的所有权重之和，即对物品j有行为的用户到物品j的权重之和。 d(u_a) = \\sum_{k=1}^{m} w_{ak}表示用户u_a的所有权重之和，即用户u对其用行为物品的用户到物品的权重之和。 2.项目的属性相似性在现实的生产系统中，当用户进入一个系统时，可能从未对系统内的任何一个物品产生过行为，也可能只对很少的物品产生了行为。这时候系统无法根据其历史信息获取相关兴趣。 这个时候可以对物品进行属性描述和标签描述，利用项目的属性相似性和利用标签相似性向用户提供更好的推荐服务。 假设用户对物品的属性矩阵如下： 上表中1 表示物品拥有该属性，0表示物品不拥有该属性。假设物品i和j所拥有的属性分别表示为Qi 和 Qj，则项目i和j的属性相似度计算公式如下： sim_{at}(i,j) = \\frac{ |Q_i \\bigcap Q_j | }{|Q_i \\bigcup Q_j |}其中： Q_i 交 Q_j 表示物品i和物品j的属性交集 Q_i 并 Q_j 表示物品i和物品j的属性并集 sim_a'(i,j) = \\sum_{k=1}^{ m } sim_{ak}(i,j)从上式中可以看出，当某一个项目属性相似性与所有项目的属性相似度之和 sim_a′(i，j)非常大时，表明该项目在整个系统中是非常活跃的，易被首先向其他用户和项目推荐。因此该项目可视做在整个推荐系统中的初始推荐资源，由此可解决用户冷启动问题。 关于标签相似性，可以阅读原论文，这里不展开介绍。 3. 项目的相似性和评分从上边的1 和 2中的描述可以看出，项目的相似性衡量可以从两方面入手 项目 i与 j的评分相似性。评分越相似，说明用户对这两个项目的喜好越相似。而且如果同时对它们评分的用户个 数越多，说明它们的相似性越高。 项目 i与 j的属性相似性。如果项目 i与 j的属性属于 相同的类别，那么它们的相似性就越高。 所以本文里采用的是项目的评分相似性和属性相似性组合的方法来计算项目的相似性。项目相似性的计算公式为： \\bar S(i,j) = sim'(i,j) + sim_a'(i,j)如果两个用户同时对一个热门物品产生了行为，并不能说明这两个用户的兴趣相同；相反如果这两个用户同时选择了一个冷门物品，则这两个用户拥有相似的独特兴趣。算法中应该考虑项目的度（即热门程度），增强小度项目的推荐能力，降低大度项目的推荐能力，提高推荐的多样性。 引入调节函数f(φ)对物品的相似度进行调节，计算相似度时考虑物品的度和物品的权重之和的比值φ，其中φ的定义为： \\varphi =\\frac{k(I_j)}{ d(I_j )}其中： k(I_j) 表示项目I_j的度 d(I_j) 表示物品I_j的所有权重之和 当所有用户对I_j没有行为时，φ取得最大值 1/w ，当所有用户都对I_j有行为且认为很重要时，φ取得最小值 1。即φ越小，用户选择该物品的概率越大，φ越大，用户不选择该物品的概率越大，算法中应该降低这种物品的推荐能力。f(φ)的表达式为： f(\\varphi) =\\varepsilon + \\delta ln(\\varphi +e)经过多次实验总结，当 δ=0.5时，可以减少 f(φ)对项目相似度的影响，效果最佳。则计算项目相似度的最终公式为： \\bar S(i,j) = sim'(i,j) + sim_a'(i,j) = \\frac{1}{ d(I_j) } \\sum_{a=1}^{m}\\frac{ w_{ia} w_{ja} }{d^{f(\\varphi )}(u_a)} + \\sum_{k=1}^{ m } sim_{ak}(i,j)其中： φ的取值为（1，1/w） ε 为 一 个 可 调 参 数 ，用 于 调 节 标 签度对推荐结果的影响，ε&gt;0表示大度标签的推荐能力被压制， ε&lt;0表示大度标签的推荐能力得到提高 计算目标用户ui对未评分项目的评分 r_iα的公式为： r_{ia} = \\frac{ \\sum_{j=1,j \\neq i}^{n} \\bar S(i,j) * w_{ja} } {\\sum_{j=1,j \\neq i}^{n} \\bar S(i,j) }标签的度和权值对推荐算法的影响 参考原论文，这里不过多介绍，论文标题为：《基于三部图网络结构的知识推荐算法 》 实验结论 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"论文","slug":"论文","permalink":"http://thinkgamer.cn/tags/论文/"},{"name":"三部图","slug":"三部图","permalink":"http://thinkgamer.cn/tags/三部图/"}]},{"title":"点击率预估中的FM算法和FFM算法","slug":"RecSys/推荐算法/点击率预估中的FM&FFM算法","date":"2018-07-13T08:45:14.000Z","updated":"2019-10-14T06:42:35.666Z","comments":true,"path":"2018/07/13/RecSys/推荐算法/点击率预估中的FM&FFM算法/","link":"","permalink":"http://thinkgamer.cn/2018/07/13/RecSys/推荐算法/点击率预估中的FM&FFM算法/","excerpt":"特征决定了所有算法效果的上限，而不同的算法只是离这个上限的距离不同而已","text":"特征决定了所有算法效果的上限，而不同的算法只是离这个上限的距离不同而已 CTR方法概览 广义线性模型+人工特征组合（LR+FeatureEngineering） 非线性模型（GBDT，FM，FFM，DNN，MLR） 广义线性模型+非线性模型组合特征（模型融合，常见的是LR+GBDT） 其中 2（非线性模型）又可以分为： ○ 矩阵分解类 （FM，FFM） ○ 回归类 （GBDT，MLR） ○ 神经网络类 （DNN） FM算法背景FM算法（Factorization Machine）一般翻译为“因子分解机”，2010年，它由当时还在日本大阪大学的Steffen Rendle提出。此算法的主要作用是可以把所有特征进行高阶组合，减少人工参与特征组合的工作，工程师可以将精力集中在模型参数调优。FM只需要线性时间复杂度，可以应用于大规模机器学习。经过部分数据集试验，此算法在稀疏数据集合上的效果要明显好于SVM。 要解决的问题假设一个广告分类问题，根据用户和广告位相关的特征，预测用户是否点击了广告。 Clicked? Country Day Ad_type 1 USA 26/11/15 Movie 0 China 1/7/14 Game 1 China 19/2/15 Game “Clicked?”是label，Country、Day、Ad_type是特征。由于三种特征都是categorical类型的，需要经过独热编码（One-Hot Encoding）转换成数值型特征。 Clicked? Country=USA Country=China Day=26/11/15 Day=1/7/14 Day=19/2/15 Ad_type=Movie Ad_type=Game 1 1 0 1 0 0 1 0 0 0 1 0 1 0 0 1 1 0 1 0 0 1 0 1 经过one-hot编码之后，特征变得稀疏，上边实例中每个样本有7维的特征，但平均仅有3维为非0值，在电商场景中预测sku是否被点击的过程中，特征往往要比上例中多的多，可见数据稀疏性是工业环境中不可避免的问题。另外一个问题就是特征在经过one-hot编码之后，维度会变得非常大，比如说三级品类有3k个，那么sku的所属三级品类特征经过编码之后就会变成3k维，特征空间就会剧增。 依旧分析上边的例子，特征在经过关联之后，与label之间的相关性就会增加。例如“USA”与“Thanksgiving”、“China”与“Chinese New Year”这样的关联特征，对用户的点击有着正向的影响。换句话说，来自“China”的用户很可能会在“Chinese New Year”有大量的浏览、购买行为，而在“Thanksgiving”却不会有特别的消费行为。这种关联特征与label的正向相关性在实际问题中是普遍存在的，如“化妆品”类商品与“女”性，“球类运动配件”的商品与“男”性，“电影票”的商品与“电影”品类偏好等。因此，引入两个特征的组合是非常有意义的。 综上，FM所解决的问题是1)：特征稀疏2)：特征组合 模型形式对于特征集合x=（x1,x2,x3,x4,….,xn）和标签y，希望得到x和y的对应关系，最简单的是建立线性回归模型， 但是，一般线性模型无法学习到高阶组合特征，所以会将特征进行高阶组合，这里以二阶为例(理论上，FM可以组合任意高阶，但是由于计算复杂度，实际中常用二阶，后面也主要介绍二阶组合的内容)。模型形式为， 其中n代表样本的特征数量，x_i是第i个特征，w_0，w_i，w_ij是模型参数从公式(2)中可以看出，组合特征参数一共有n(n-1)/2个，任意两个参数之间都是独立的，在数据特别稀疏的情况下，二次项参数的训练是十分困难的，原因为每个wij的训练都需要大量的非零x_i，x_j样本，由于样本稀疏，满足条件的样本很少，就会导致参数w_ij不准确，最终将影响模型的性能。如何解决二次项参数的训练？可以利用矩阵分解的思路。在model-based的协同过滤中，一个rating矩阵可以分解为user矩阵和item矩阵，每个user和item都可以采用一个隐向量表示。比如在下图中的例子中，我们把每个user表示成一个二维向量，同时把每个item表示成一个二维向量，两个向量的点积就是矩阵中user对item的打分。 所有的二次项参数 w_ij 可以组成一个对称矩阵W，那么这个矩阵可以分解为W=V^T * V，V的第j列便是第j维特征的隐向量，换句话说就是每个参数w_ij=，这里的v_i和v_j是分别是第i，j个特征的隐向量，这就是FM的核心思想，因此FM的模型方程为（二阶形式） 其中，V_i是第i维特征的隐向量，&lt;,&gt;表示两个向量内积，隐向量的长度k（k&lt;&lt;n），包含k个描述特征的因子，这样二次项的参数便从n^2 减少到了nk，远少于多项式模型的参数数量。另外，参数因子化使得 x_h，x_i的参数和 x_i，x_j 的参数不再是相互独立的，因此我们可以在样本稀疏的情况下相对合理地估计FM的二次项参数。具体来说，x_h，x_i 和 x_i，x_j 的系数分别为 ⟨v_h,v_i⟩ 和 ⟨v_i,v_j⟩，它们之间有共同项 vi。也就是说，所有包含“xi的非零组合特征”（存在某个 j≠i，使得 x_i x_j≠0）的样本都可以用来学习隐向量 v_i，这很大程度上避免了数据稀疏性造成的影响。而在多项式模型中，w_hi 和 w_ij 是相互独立的。显而易见，公式(3)是一个通用的拟合方程，可以采用不同的损失函数用于解决回归、二元分类等问题，比如可以采用MSE（Mean Square Error）损失函数来求解回归问题，也可以采用Hinge/Cross-Entropy损失（铰链损失，互熵损失）来求解分类问题。当然，在进行二元分类时，FM的输出需要经过sigmoid变换，这与Logistic回归是一样的。直观上看，FM的复杂度是 O(kn^2)。但是，通过公式(3)的等式，FM的二次项可以化简，其复杂度可以优化到 O(kn)。由此可见，FM可以在线性时间对新样本作出预测。 从(3)—&gt;(4)推导如下： 解读第（1）步到第（2）步，这里用A表示系数矩阵V的上三角元素，B表示对角线上的交叉项系数。由于系数矩阵V是一个对称阵，所以下三角与上三角相等，有下式成立： 如果用随机梯度下降（Stochastic Gradient Descent）法学习模型参数。那么，模型各个参数的梯度如下： 其中，v_j,f 是隐向量 v_j 的第 f 个元素。由于 ∑nj=1vj,fxj 只与 f 有关，而与 i 无关，在每次迭代过程中，只需计算一次所有 f 的 ∑nj=1vj,fxj，就能够方便地得到所有 v_i,f 的梯度。显然，计算所有 f 的 ∑nj=1vj,fxj 的复杂度是 O(kn)；已知 ∑nj=1vj,fxj 时，计算每个参数梯度的复杂度是 O(1)；得到梯度后，更新每个参数的复杂度是 O(1)；模型参数一共有 nk+n+1 个。因此，FM参数训练的复杂度也是 O(kn)。综上可知，FM可以在线性时间训练和预测，是一种非常高效的模型。 FM总结FM降低了交叉项参数学习不充分的影响one-hot编码后的样本数据非常稀疏，组合特征更是如此。为了解决交叉项参数学习不充分、导致模型有偏或不稳定的问题。借鉴矩阵分解的思路：每一维特征用k维的隐向量表示，交叉项的参数w_ij用对应特征隐向量的内积表示，即⟨v_i,v_j⟩（也可以理解为平滑技术）。这样参数学习由之前学习交叉项参数w_ij的过程，转变为学习n个单特征对应k维隐向量的过程。很明显，单特征参数（k维隐向量v_i）的学习要比交叉项参数w_ij学习得更充分。示例说明：假如有10w条训练样本，其中出现女性特征的样本数为3w，出现男性特征的样本数为7w，出现汽车特征的样本数为2000，出现化妆品的样本数为1000。特征共现的样本数如下： 共现交叉特征 样本数 注 &lt;女性，汽车&gt; 500 同时出现&lt;女性，汽车&gt;的样本数 &lt;女性，化妆品&gt; 1000 同时出现&lt;女性，化妆品&gt;的样本数 &lt;男性，汽车&gt; 1500 同时出现&lt;男性，汽车&gt;的样本数 &lt;男性，化妆品&gt; 0 样本中无此特征组合项 &lt;女性，汽车&gt;的含义是女性看汽车广告。可以看到，单特征对应的样本数远大于组合特征对应的样本数。训练时，单特征参数相比交叉项特征参数会学习地更充分。因此，可以说FM降低了因数据稀疏，导致交叉项参数学习不充分的影响 FM提升了模型预估能力依然看上面的示例，样本中没有&lt;男性，化妆品&gt;交叉特征，即没有男性看化妆品广告的数据。如果用多项式模型来建模，对应的交叉项参数W_男性,化妆品是学不出来的，因为数据中没有对应的共现交叉特征。那么多项式模型就不能对出现的男性看化妆品广告场景给出准确地预估。FM模型是否能得到交叉项参数W_男性,化妆品呢？答案是肯定的。由于FM模型是把交叉项参数用对应的特征隐向量内积表示，这里表示为W_男性,化妆品=⟨v_男性,v_化妆品⟩。用男性特征隐向量v_男性和v_化妆品特征隐向量v化妆品的内积表示交叉项参数 W_男性,化妆品。由于FM学习的参数就是单特征的隐向量，那么男性看化妆品广告的预估结果可以用⟨v_男性,v_化妆品⟩得到。这样，即便训练集中没有出现男性看化妆品广告的样本，FM模型仍然可以用来预估，提升了预估能力。 FM提升了参数学习效率这个显而易见，参数个数由(n^2+n+1)变为(nk+n+1)个，模型训练复杂度也由O(mn^2)变为O(mnk)。m为训练样本数。对于训练样本和特征数而言，都是线性复杂度。此外，就FM模型本身而言，它是在多项式模型基础上对参数的计算做了调整，因此也有人把FM模型称为多项式的广义线性模型，也是恰如其分的。从交互项的角度看，FM仅仅是一个可以表示特征之间交互关系的函数表法式，可以推广到更高阶形式，即将多个互异特征分量之间的关联信息考虑进来。例如在广告业务场景中，如果考虑User-Ad-Context三个维度特征之间的关系，在FM模型中对应的degree为3。 总结FM最大特点和优势：FM模型对稀疏数据有更好的学习能力，通过交互项可以学习特征之间的关联关系，并且保证了学习效率和预估能力 FFM算法背景FFM（Field-aware Factorization Machine）最初的概念来自Yu-Chin Juan（阮毓钦，毕业于中国台湾大学，现在美国Criteo工作）与其比赛队员，是他们借鉴了来自Michael Jahrer的论文中的field概念提出了FM的升级版模型。 模型形式通过引入field的概念，FFM把相同性质的特征，归结于同一个field。还是以FM中的广告分类为例，“Day=26/11/15”、“Day=1/7/14”、“Day=19/2/15”这三个特征都是代表日期的，可以放到同一个field中。同理，三级品类有3k个，那么sku的所属三级品类特征经过编码之后就会变成3k维，那么这3k维可以放到一个field中，简单来说，同一个categorical特征经过One-Hot编码生成的数值特征都可以放到同一个field。在FFM中，每一维特征x_i，针对其他特征的每一种field f_j，都会学习到一个隐向量V_i,f_ j。因此，隐向量不仅与特征有关，还与filed有关。也就是说，“Day=26/11/15”这个特征与“Country”特征和“Ad_type”特征进行关联的时候使用不同的隐向量，这与“Country”和“Ad_type”的内在差异相符，也是FFM中“field-aware”的由来。假设样本的 n 个特征属于 f 个field，那么FFM的二次项有 nf个隐向量。而在FM模型中，每一维特征的隐向量只有一个。FM可以看作FFM的特例，是把所有特征都归属到一个field时的FFM模型。根据FFM的field敏感特性，可以导出其模型方程。 其中，f_ j 是第 j 个特征所属的field。如果隐向量的长度为 k，那么FFM的二次参数有 f * kn 个，远多于FM模型的 kn 个。此外，由于隐向量与field相关，FFM二次项并不能化简，其预测复杂度是 O(kn^2)。下面以一个例子简单说明FFM的特征组合方式。输入记录如下User Movie Genre PriceYuChin 3Idiots Comedy, Drama $9.99这条记录可以编码成5个特征，其中“Genre=Comedy”和“Genre=Drama”属于同一个field，“Price”是数值型，不用One-Hot编码转换。为了方便说明FFM的样本格式，我们将所有的特征和对应的field映射成整数编号。 Field name Field index Feature name Feature index User 1 User=YuChin 1 Movie 2 Movie=3Idiots 2 Genre 3 Genre=Comedy 3 Price 4 Genre=Drama 4 Price 5 那么，FFM的组合特征有10项，如下图所示。 其中，红色是field编号，蓝色是特征编号，绿色是此样本的特征取值。二次项的系数是通过与特征field相关的隐向量点积得到的，二次项共有 n(n−1)/2 个。 应用场景在DSP的场景中，FFM主要用来预估站内的CTR和CVR，即一个用户对一个商品的潜在点击率和点击后的转化率。CTR和CVR预估模型都是在线下训练，然后用于线上预测。两个模型采用的特征大同小异，主要有三类： ● -用户相关的特征用户相关的特征包括年龄、性别、职业、兴趣、品类偏好、浏览/购买品类等基本信息，以及用户近期点击量、购买量、消费额等统计信息。 ● 商品相关的特征商品相关的特征包括所属品类、销量、价格、评分、历史CTR/CVR等信息。 ● 用户-商品匹配特征用户-商品匹配特征主要有浏览/购买品类匹配、浏览/购买商家匹配、兴趣偏好匹配等几个维度。为了使用FFM方法，所有的特征必须转换成“field_id:feat_id:value”格式，field_id代表特征所属field的编号，feat_id是特征编号，value是特征的值。数值型的特征比较容易处理，只需分配单独的field编号，如用户评论得分、商品的历史CTR/CVR等。categorical特征需要经过One-Hot编码成数值型，编码产生的所有特征同属于一个field，而特征的值只能是0或1，如用户的性别、年龄段，商品的品类id等。除此之外，还有第三类特征，如用户浏览/购买品类，有多个品类id且用一个数值衡量用户浏览或购买每个品类商品的数量。这类特征按照categorical特征处理，不同的只是特征的值不是0或1，而是代表用户浏览或购买数量的数值。按前述方法得到field_id之后，再对转换后特征顺序编号，得到feat_id，特征的值也可以按照之前的方法获得。CTR、CVR预估样本的类别是按不同方式获取的。CTR预估的正样本是站内点击的用户-商品记录，负样本是展现但未点击的记录；CVR预估的正样本是站内支付（发生转化）的用户-商品记录，负样本是点击但未支付的记录。构建出样本数据后，采用FFM训练预估模型，并测试模型的性能。 #(field) #(feature) AUC Logloss 站内CTR 39 2456 0.77 0.38 站内CVR 67 2441 0.92 0.13 由于模型是按天训练的，每天的性能指标可能会有些波动，但变化幅度不是很大。这个表的结果说明，站内CTR/CVR预估模型是非常有效的。在训练FFM的过程中，有许多小细节值得特别关注。第一，样本归一化。FFM默认是进行样本数据的归一化，即 pa.norm 为真；若此参数设置为假，很容易造成数据inf溢出，进而引起梯度计算的nan错误。因此，样本层面的数据是推荐进行归一化的。第二，特征归一化。CTR/CVR模型采用了多种类型的源特征，包括数值型和categorical类型等。但是，categorical类编码后的特征取值只有0或1，较大的数值型特征会造成样本归一化后categorical类生成特征的值非常小，没有区分性。例如，一条用户-商品记录，用户为“男”性，商品的销量是5000个（假设其它特征的值为零），那么归一化后特征“sex=male”（性别为男）的值略小于0.0002，而“volume”（销量）的值近似为1。特征“sex=male”在这个样本中的作用几乎可以忽略不计，这是相当不合理的。因此，将源数值型特征的值归一化到 [0,1] 是非常必要的。第三，省略零值特征。从FFM模型的表达式(8)可以看出，零值特征对模型完全没有贡献。包含零值特征的一次项和组合项均为零，对于训练模型参数或者目标值预估是没有作用的。因此，可以省去零值特征，提高FFM模型训练和预测的速度，这也是稀疏样本采用FFM的显著优势。 参考资料 http://bourneli.github.io/ml/fm/2017/07/02/fm-remove-combine-features-by-yourself.html https://tech.meituan.com/deep_understanding_of_ffm_principles_and_practices.html http://www.52caml.com/head_first_ml/ml-chapter9-factorization-family/ https://cloud.tencent.com/developer/article/1104673?fromSource=waitui 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"http://thinkgamer.cn/tags/推荐算法/"},{"name":"FM","slug":"FM","permalink":"http://thinkgamer.cn/tags/FM/"},{"name":"FFM","slug":"FFM","permalink":"http://thinkgamer.cn/tags/FFM/"}]},{"title":"回归分析之逻辑回归-Logistic Regression","slug":"机器学习/回归分析之逻辑回归-Logistics Regression","date":"2018-04-28T15:44:15.000Z","updated":"2019-10-14T06:42:35.685Z","comments":true,"path":"2018/04/28/机器学习/回归分析之逻辑回归-Logistics Regression/","link":"","permalink":"http://thinkgamer.cn/2018/04/28/机器学习/回归分析之逻辑回归-Logistics Regression/","excerpt":"逻辑回归与线性回归本质上是一样的，都是通过误差函数求解得到最优的系数，在形式上只不过是在线性回归上套了一个逻辑函数。线性回归的相关知识可以参考上边的给出链接文章，与线性回归相比，逻辑回归（Logistic Regression）更适用于因变量为二分变量的模型，Logistic 回归系数可用于估计模型中每个自变量的几率比。","text":"逻辑回归与线性回归本质上是一样的，都是通过误差函数求解得到最优的系数，在形式上只不过是在线性回归上套了一个逻辑函数。线性回归的相关知识可以参考上边的给出链接文章，与线性回归相比，逻辑回归（Logistic Regression）更适用于因变量为二分变量的模型，Logistic 回归系数可用于估计模型中每个自变量的几率比。 回归分析之理论篇回归分析之线性回归（N元线性回归）回归分析之Sklearn实现电力预测 Sigmoid函数数学表达式和图形这里选用Sigmoid函数（海维赛德阶跃函数）作为LR的模型函数，是因为在二分类情况下输出为0和1，其函数的数学表达式为： f(x)=\\frac{1}{1+e^{-x}}其图形为： 12345678910111213import mathimport matplotlib.pyplot as pltdef sigmoid(x): return 1 / (1 + math.exp(-x))# python2 中range生成的是一个数组，py3中生成的是一个迭代器，可以使用list进行转换X = list(range(-9,10))Y = list(map(sigmoid,X))#画图plt.plot(X,Y)plt.show() ![sigmoid](http://img.blog.csdn.net/20171219192329328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FtZXJfZ3l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 从上图可以看到sigmoid函数是一个s形的曲线，它的取值在[0, 1]之间，在远离0的地方函数的值会很快接近0/1。 LR为什么要使用Sigmoid首先Sigmoid函数满足LR模型的需要，在自变量小于0时，因变量小于0.5，自变量大于0时，因变量大于0.5。以下一段引用 Logistic Regression 模型简介 的介绍对逻辑回归是一种概率模型做了阐述。 逻辑回归是一种判别模型，表现为直接对条件概率P(y|x)建模，而不关心背后的数据分布P(x,y)。而高斯贝叶斯模型（Gaussian Naive Bayes）是一种生成模型，先对数据的联合分布建模，再通过贝叶斯公式来计算样本属于各个类别的后验概率，即： p(y|x) = \\frac{P(x|y)P(y)}{\\sum{P(x|y)P(y)}}通常假设P(x|y)是高斯分布，P(y)是多项式分布，相应的参数都可以通过最大似然估计得到。如果我们考虑二分类问题，通过简单的变化可以得到： \\log\\frac{P(y=1|x)}{P(y=0|x)} = \\log\\frac{P(x|y=1)}{P(x|y=0)} + \\log\\frac{P(y=1)}{P(y=0)} \\ = -\\frac{(x-\\mu_1)^2}{2\\sigma_1^2} + \\frac{(x-\\mu_0)^2}{2\\sigma_0^2}\\ + \\theta_0如果 σ1=σ0，二次项会抵消，我们得到一个简单的线性关系： \\log\\frac{P(y=1|x)}{P(y=0|x)} = \\theta^T x由上式进一步可以得到： P(y=1|x) = \\frac{e^{\\theta^T x}}{1+e^{\\theta^T x}} = \\frac{1}{1+e^{-\\theta^T x}}可以看到，这个概率和逻辑回归中的形式是一样的。这种情况下GNB 和 LR 会学习到同一个模型。实际上，在更一般的假设（P(x|y)的分布属于指数分布族）下，我们都可以得到类似的结论。 至于逻辑回归为什么采用Sigmoid函数作为激活函数，因为LR是在伯努利分布和广义线性模型的假设下推导而来的，伯努利分布是属于指数分布簇的。 具体的推导可以参考 机器学习算法之：指数族分布与广义线性模型 的介绍 Logistic Regression 分类器即决策函数。一个机器学习的模型，实际上是把决策函数限定在某一组条件下，这组限定条件就决定了模型的假设空间。当然，我们还希望这组限定条件简单而合理。而逻辑回归模型所做的假设是： P(y=1|x;\\theta) = g(\\theta^T x) = \\frac{1}{1 + e ^ {-\\theta^T * x}}这里的 g(h)是上边提到的 sigmoid 函数$\\theta$ 表示的是一组参数，$\\theta^T $表示参数的转置矩阵，$\\theta^T x$其实表示的就是$\\theta_{0}x_{0} + \\theta_{1}x_{1} + \\theta_{2} x_{2}….$，相应的决策函数为： y^* = 1, \\, \\textrm{if} \\, P(y=1|x) > 0.5选择0.5作为阈值是一个一般的做法，实际应用时特定的情况可以选择不同阈值，如果对正例的判别准确性要求高，可以选择阈值大一些，对正例的召回要求高，则可以选择阈值小一些。 参数求解确定好决策函数之后就是求解参数了。 模型的数学形式确定后，剩下就是如何去求解模型中的参数。统计学中常用的一种方法是最大似然估计，即找到一组参数，使得在这组参数下，我们的数据的似然度（概率）越大。在逻辑回归模型中，似然度可表示为： L(\\theta) = P(D|\\theta) = \\prod P(y|x;\\theta) = \\prod g(\\theta^T x) ^ y (1-g(\\theta^T x))^{1-y}取对数可以得到对数似然度： l(\\theta) = \\sum {y\\log{g(\\theta^T x)} + (1-y)\\log{(1-g(\\theta^T x))}}另一方面，在机器学习领域，我们更经常遇到的是损失函数的概念，其衡量的是模型预测错误的程度。常用的损失函数有0-1损失，log损失，hinge损失等。其中log损失在单个数据点上的定义为 -y\\log{p(y|x)}-(1-y)\\log{1-p(y|x)}如果取整个数据集上的平均log损失，我们可以得到 J(\\theta) = -\\frac{1}{N} l(\\theta)即在逻辑回归模型中，我们最大化似然函数和最小化log损失函数实际上是等价的。对于该优化问题，存在多种求解方法，这里以梯度下降的为例说明。梯度下降(Gradient Descent)又叫作最速梯度下降，是一种迭代求解的方法，通过在每一步选取使目标函数变化最快的一个方向调整参数的值来逼近最优值。基本步骤如下： 选择下降方向（梯度方向，$\\nabla {J(\\theta)}$） 选择步长，更新参数 $\\theta^i = \\theta^{i-1} - \\alpha^i \\nabla {J(\\theta^{i-1})}$ 重复以上两步直到满足终止条件 其中损失函数的梯度计算方法为： \\frac{\\partial{J}}{\\partial{\\theta}} = -\\frac{1}{n}\\sum_i (y_i - y_i^*)x_i + \\lambda \\theta沿梯度负方向选择一个较小的步长可以保证损失函数是减小的，另一方面，逻辑回归的损失函数是凸函数（加入正则项后是严格凸函数），可以保证我们找到的局部最优值同时是全局最优。此外，常用的凸优化的方法都可以用于求解该问题。例如共轭梯度下降，牛顿法，LBFGS等。 分类边界知道如何求解参数后，我们来看一下模型得到的最后结果是什么样的。很容易可以从sigmoid函数看出，当$\\theta^T x &gt; 0$ 时，y=1，否则 y=0。$\\theta^T x = 0$ 是模型隐含的分类平面（在高维空间中，我们说是超平面）。所以说逻辑回归本质上是一个线性模型，但是，这不意味着只有线性可分的数据能通过LR求解，实际上，我们可以通过特征变换的方式把低维空间转换到高维空间，而在低维空间不可分的数据，到高维空间中线性可分的几率会高一些。下面两个图的对比说明了线性分类曲线和非线性分类曲线（通过特征映射）。左图是一个线性可分的数据集，右图在原始空间中线性不可分，但是在特征转换 $[x_1, x_2] =&gt; [x_1, x_2, x_1^2, x_2^2, x_1x_2]$ 后的空间是线性可分的，对应的原始空间中分类边界为一条类椭圆曲线。 总结逻辑回归的数学模型和求解都相对比较简洁，实现相对简单。通过对特征做离散化和其他映射，逻辑回归也可以处理非线性问题，是一个非常强大的分类器。因此在实际应用中，当我们能够拿到许多低层次的特征时，可以考虑使用逻辑回归来解决我们的问题。 资料参考http://blog.csdn.net/han_xiaoyang/article/details/49123419 https://www.cnblogs.com/sxron/p/5489214.html https://tech.meituan.com/intro_to_logistic_regression.html 打开微信扫一扫，加入数据与算法交流大群 打开微信扫一扫，关注公众号【搜索与推荐Wiki】 转载请注明出处：http://blog.csdn.net/gamer_gyt博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"http://thinkgamer.cn/tags/逻辑回归/"}]},{"title":"TensorFlow的MNIST学习","slug":"TensorFlow/TensorFlow的MNIST学习","date":"2018-04-22T07:21:28.000Z","updated":"2019-10-14T06:42:35.678Z","comments":true,"path":"2018/04/22/TensorFlow/TensorFlow的MNIST学习/","link":"","permalink":"http://thinkgamer.cn/2018/04/22/TensorFlow/TensorFlow的MNIST学习/","excerpt":"MNIST是在机器学习领域中的一个经典问题。该问题解决的是把28x28像素的灰度手写数字图片识别为相应的数字，其中数字的范围从0到9.","text":"MNIST是在机器学习领域中的一个经典问题。该问题解决的是把28x28像素的灰度手写数字图片识别为相应的数字，其中数字的范围从0到9. 数据集 目的 data_sets.train 55000 组 图片和标签, 用于训练。 data_sets.validation 5000 组 图片和标签, 用于迭代验证训练的准确性。 data_sets.test 10000 组 图片和标签, 用于最终测试训练的准确性。 数据集简介MNIST数据集加载有两种办法，第一是直接从网上下载，第二是下载到本地进行load（跟第一种类似，只不过是事先下载好，从本地进行加载）。从网上下载到本地方式如下： 123456# 加载mnist数据集from tensorflow.examples.tutorials.mnist import input_dataprint(\"load finish\")mnist = input_data.read_data_sets(\"MNIST_data/\",one_hot=True)print(type(mnist)) 输出为：123456load finishExtracting MNIST_data/train-images-idx3-ubyte.gzExtracting MNIST_data/train-labels-idx1-ubyte.gzExtracting MNIST_data/t10k-images-idx3-ubyte.gzExtracting MNIST_data/t10k-labels-idx1-ubyte.gz&lt;class 'tensorflow.contrib.learn.python.learn.datasets.base.Datasets'&gt; 123456789101112print(\"MNIST 训练集数据条数：\" ,mnist.train.num_examples)print(\"MNIST 测试集数据条数：\" ,mnist.test.num_examples)train_img = mnist.train.imagestrain_label = mnist.train.labelsprint(\"训练集类型：\",type(train_img))print(\"训练集维度：\",train_img.shape)test_img = mnist.test.imagestest_label = mnist.test.labelsprint(\"测试集类型：\",type(test_img))print(\"测试集维度：\",test_img.shape) 输出为：123456MNIST 训练集数据条数： 55000MNIST 测试集数据条数： 10000训练集类型： &lt;class 'numpy.ndarray'&gt;训练集维度： (55000, 784)测试集类型： &lt;class 'numpy.ndarray'&gt;测试集维度： (10000, 784) 打开当前运行代码的目录，我们会发现一个MNIST_data的文件夹，里边包含的文件如下：文件 | 内容—|—train-images-idx3-ubyte.gz | 训练集图片 - 55000 张 训练图片, 5000 张 验证图片train-labels-idx1-ubyte.gz | 训练集图片对应的数字标签t10k-images-idx3-ubyte.gz | 测试集图片 - 10000 张 图片t10k-labels-idx1-ubyte.gz | 测试集图片对应的数字标签 使用next_batch函数加载指定条数的数据集12345# 关于next_batch函数batchSize = 100batch_x,batch_y = mnist.train.next_batch(batch_size=batchSize)print(batch_x.shape)print(batch_y.shape) 输出为：12(100, 784)(100, 10) 打开微信扫一扫，加入数据与算法交流大群","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://thinkgamer.cn/tags/TensorFlow/"}]},{"title":"TensorFlow实现线性回归","slug":"TensorFlow/TensorFlow实现线性回归","date":"2018-04-22T06:27:28.000Z","updated":"2019-10-14T06:42:35.677Z","comments":true,"path":"2018/04/22/TensorFlow/TensorFlow实现线性回归/","link":"","permalink":"http://thinkgamer.cn/2018/04/22/TensorFlow/TensorFlow实现线性回归/","excerpt":"TensorFlow写简单的代码是大财小用，需要很繁琐的代码方能实现简单的功能，但对于复杂的机器学习算法和深度神经网络却是十分的简单，下边看一个tf实现线性回归的Demo","text":"TensorFlow写简单的代码是大财小用，需要很繁琐的代码方能实现简单的功能，但对于复杂的机器学习算法和深度神经网络却是十分的简单，下边看一个tf实现线性回归的Demo 首先引入tf包的相关的package，并初始化100个点。这里我们假定线性回归中的w为0.1 b为0.3，并设置一个随机数保证在y=0.1X + 0.3 上下浮动。12345678910111213141516171819202122232425# coding: utf-8'''create by: Thinkgamercreate time: 2018/04/22desc: 使用tensorflow创建线性回归模型'''import numpy as npimport tensorflow as tfimport matplotlib.pyplot as plt# 随机生成100个点num_points = 100vectors_set = list()for i in range(num_points): x1 = np.random.normal(0.00,00.55) y1 = x1* 0.1 + 0.3 + np.random.normal(0.0,0.03) vectors_set.append([x1,y1])# 生成一些样本x_data = [v[0] for v in vectors_set]y_data = [v[1] for v in vectors_set]# print(x_data)# print(y_data)plt.scatter(x_data,y_data,c='r')plt.show() 生成的图如下所示： 用刚才生成的数据进行线性回归拟合 1234567891011121314151617181920212223242526272829303132# 构造线性回归模型# 生成一维的W矩阵，取值是[-1,1]之间的随机数W = tf.Variable(tf.random_uniform([1],-1,1),name='W')# 生成一维的b矩阵，初始值为0b = tf.Variable(tf.zeros([1]),name='b')# 经过计算得出预估值yy=W*x_data + b# 定义损失函数，以预估值y和y_data之间的均方误差作为损失loss = tf.reduce_mean(tf.square(y - y_data),name='loss')# 采用地图下降算法来优化参数optimizer = tf.train.GradientDescentOptimizer(0.5)# 训练过程就是最小化误差train = optimizer.minimize(loss,name='train')sess = tf.Session()init = tf.global_variables_initializer()sess.run(init)# 初始化W 和 bprint(\"初始化值： W = \",sess.run(W), \"b= \",sess.run(b))for step in range(20): sess.run(train) # 打印出每次训练后的w和b print(\"第 %s 步： W = \" % step,sess.run(W), \"b= \",sess.run(b)) # 展示plt.scatter(x_data,y_data,c='r')plt.plot(x_data,sess.run(W)*x_data+sess.run(b),c='b')plt.show() 对应的输出结果为：123456789101112131415161718192021初始化值： W = [-0.300848] b= [0.]第 0 步： W = [-0.17744449] b= [0.3065566]第 1 步： W = [-0.09421768] b= [0.30550653]第 2 步： W = [-0.03631891] b= [0.3047983]第 3 步： W = [0.0039596] b= [0.3043056]第 4 步： W = [0.0319802] b= [0.3039629]第 5 步： W = [0.05147332] b= [0.30372444]第 6 步： W = [0.06503413] b= [0.30355856]第 7 步： W = [0.07446799] b= [0.30344316]第 8 步： W = [0.08103085] b= [0.30336288]第 9 步： W = [0.08559645] b= [0.30330706]第 10 步： W = [0.0887726] b= [0.3032682]第 11 步： W = [0.09098216] b= [0.30324116]第 12 步： W = [0.09251929] b= [0.30322236]第 13 步： W = [0.09358863] b= [0.30320928]第 14 步： W = [0.09433253] b= [0.3032002]第 15 步： W = [0.09485004] b= [0.30319384]第 16 步： W = [0.09521006] b= [0.30318946]第 17 步： W = [0.09546052] b= [0.3031864]第 18 步： W = [0.09563475] b= [0.30318424]第 19 步： W = [0.09575596] b= [0.30318278] 生成的图如下： 打开微信扫一扫，加入数据与算法交流大群","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://thinkgamer.cn/tags/TensorFlow/"}]},{"title":"TensorFlow安装、变量学习和常用操作","slug":"TensorFlow/TensorFlow安装、变量学习和常用操作","date":"2018-04-16T16:55:28.000Z","updated":"2019-10-14T06:42:35.677Z","comments":true,"path":"2018/04/17/TensorFlow/TensorFlow安装、变量学习和常用操作/","link":"","permalink":"http://thinkgamer.cn/2018/04/17/TensorFlow/TensorFlow安装、变量学习和常用操作/","excerpt":"本文主要介绍TensorFlow的安装 ，变量学习和一些常用操作。","text":"本文主要介绍TensorFlow的安装 ，变量学习和一些常用操作。 安装、入门环境说明： deepin 15.4 python 3.5.4 tensorflow 1.7.0 安装：1pip3 install https://pypi.python.org/packages/dd/ed/9e6c6c16ff50be054277438669542555a166ed9f95a0dcaacff24fd3153a/tensorflow-1.7.0rc1-cp35-cp35m-manylinux1_x86_64.whl#md5=ec44ad9b0d040caef8ca0fac5b822b0d 测试：12345678&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant(\"hello , Thinkgamer\")&gt;&gt;&gt; with tf.Session() as sess:... print(sess.run(hello))... sess.close()... 2018-03-28 00:50:16.728894: I tensorflow/core/platform/cpu_feature_guard.cc:140] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMAb'hello , Thinkgamer' 使用 TensorFlow, 你必须明白 TensorFlow: 使用图 (graph) 来表示计算任务. 在被称之为 会话 (Session) 的上下文 (context) 中执行图. 使用 tensor 表示数据. 通过 变量 (Variable) 维护状态. 使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据. session和InteractiveSession的区别： session：启动图的操作，有run()、close()InteractiveSession：默认会话123456789101112131415&gt;&gt;&gt; sess = tf.InteractiveSession()&gt;&gt;&gt; a = tf.constant(5.0)&gt;&gt;&gt; b = tf.constant(6.0)&gt;&gt;&gt; c = a * b&gt;&gt;&gt; print(c.eval())30.0&gt;&gt;&gt; sess.close()&gt;&gt;&gt;&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; a = tf.constant(5.0)&gt;&gt;&gt; b = tf.constant(6.0)&gt;&gt;&gt; c = a * b&gt;&gt;&gt; sess.run(c)30.0&gt;&gt;&gt; sess.close() Tensorflow之变量tensor的理解tensor即张量，tf中所有的数据通过数据流进行传输，可以声明任何一个张量，只有当一个张量进行run的时候，这个张量所涉及的tensor便会触发，这一点和spark的DAG很是相似，在同一条链上的某个节点进行触发操作时，该节点之前的所有节点便会参与计算。 在tensorflow中，张量的维数被描述为“阶”，张量是以list的形式存储的。list有几重中括号，对应的张量就是几阶。如t=[ [1,2,3],[4,5,6],[7,8,9] ]，t就是一个二阶张量。 我们可以认为，一阶张量，如[1,2,3]，相当于一个向量，二阶张量，如[ [1,2,3],[4,5,6],[7,8,9] ]，相当于一个矩阵。 对于t=[ [1,2,3],[4,5,6],[7,8,9] ]来说，它的shape==&gt;[3,3]，shape可以理解成：当脱去最外层的一对中括号后，里面有3个小list，然后每个小list里又有3个元素，所以该张量的shape==&gt;[3,3]。 举几个例子，如[ [1,2,3],[4,5,6] ] 的shape=[2,3](因为当脱去最外层的一对中括号后，里面有2个小list，然后每个小list里又有3个元素，所以该张量的shape==&gt;[2,3]。） 又如：12345678910111213141516171819202122[ [ [ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] ] , [ [ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] ] , [ [ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] ] , [ [ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] ] ] 的shape==&gt;[4,3,2,1] (因为当脱去最外层的一对中括号后，里面有4个第二大的list，每个第二大的list里又有3个第三大的list，每个第三大的list里有2个第四大的list，每个第四大的list里有1个元素，所以该张量的shape==&gt;[4,3,2,1]。 1234567891011121314151617181920212223#coding: utf-8'''create by: thinkgamercreate time: 2018/04/16description: 关于tensorflow变量的学习'''import tensorflow as tfa = tf.Variable([ [1,2,3],[4,5,6],[7,8,9] ])b = tf.Variable([ [1,2,3],[4,5,6] ])c = tf.Variable([[ [ [ 2 ], [ 2 ] ] ,[ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] ] , [ [ [ 2 ], [ 2 ] ] ,[ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] ] , [ [ [ 2 ], [ 2 ] ] ,[ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] ] , [ [ [ 2 ], [ 2 ] ] ,[ [ 2 ], [ 2 ] ] , [ [ 2 ], [ 2 ] ] ] ])init_op = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init_op)print(\"a shape: \",a.eval)print(\"b shape: \",b.eval)print(\"c shape: \",c.eval) 打印出的结果如下：123a shape: &lt;bound method Variable.eval of &lt;tf.Variable 'Variable_19:0' shape=(3, 3) dtype=int32_ref&gt;&gt;b shape: &lt;bound method Variable.eval of &lt;tf.Variable 'Variable_20:0' shape=(2, 3) dtype=int32_ref&gt;&gt;c shape: &lt;bound method Variable.eval of &lt;tf.Variable 'Variable_21:0' shape=(4, 3, 2, 1) dtype=int32_ref&gt;&gt; tf实现乘法123456789# tf 实现矩阵乘法val1 = tf.Variable([[1,2]])val2 = tf.Variable([[1],[2]])result1 = tf.matmul(val1,val2)init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) print(sess.run(result1)) sess.close() tf的常用操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# tf的常用操作，建议变量以float32为主,CPU,GPU均支持，否则容易出现一些错误,float32需要从tf中引入from tensorflow import float32# 创建一个shape=（3,4）的tensort1 = tf.zeros([3,4],float32)# 创建一个shape类似于tensor的tensor，值分为全为0或1tensor = tf.Variable([ [1,2,3],[4,5,6],[7,8,9] ])t2 = tf.zeros_like(tensor)t3 = tf.ones_like(tensor)# 创建tensorflow支持的常量t4 = tf.constant([1,2,3,4])# 创建常量，指定值全为-1t5 = tf.constant(-1.0,shape=[2,3])# 创建数组t6 = tf.linspace(1.0,6.0,3,name=\"linspace\")# start=1, limit=9, delta=3t7 = tf.range(1,9,3)init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) print(\"t1: \",sess.run(t1)) print(\"\\ntermsor: \",sess.run(tensor)) print(\"\\nt2: \",sess.run(t2)) print(\"\\nt3: \",sess.run(t3)) print(\"\\nt4: \",sess.run(t4)) print(\"\\nt5: \",sess.run(t5)) print(\"\\nt6: \",sess.run(t6)) print(\"\\nt7: \",sess.run(t7))sess.close()#-----------------------------------------# tf创建符合指定正态分布的tensort8 = tf.random_normal([2,3],mean=-1 ,stddev=4)# tf shufflet9 = tf.constant([[1,2],[3,4],[5,6]])t10 = tf.random_shuffle(t9)sess = tf.Session()print(\"\\nt8:\",sess.run(t8))print(\"\\nt9:\",sess.run(t9))print(\"\\nt10\",sess.run(t10)) 打印出的值为：123456789101112131415161718192021222324252627282930313233343536t1: [[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]termsor: [[1 2 3] [4 5 6] [7 8 9]]t2: [[0 0 0] [0 0 0] [0 0 0]]t3: [[1 1 1] [1 1 1] [1 1 1]]t4: [1 2 3 4]t5: [[-1. -1. -1.] [-1. -1. -1.]]t6: [1. 3.5 6. ]t7: [1 4 7]t8: [[ 0.8365586 5.152416 -3.9977255] [ -1.7592524 -12.675492 -5.949805 ]]t9: [[1 2] [3 4] [5 6]]t10: [[3 4] [5 6] [1 2]]In [ ]: tf实现i++1234567891011# tf 实现i++state= tf.Variable(1)new_value = tf.add(state,tf.Variable(1))update = tf.assign(state,new_value)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print(sess.run(state)) for _ in range(3): sess.run(update) print(sess.run(state)) 打印结果为：12341234 numpy转tensor123456# numpy 转化为 tensorimport numpy as npnp1 = np.zeros((3,3))ta = tf.convert_to_tensor(np1)with tf.Session() as tf: print(sess.run(ta)) 测试遇到的问题1：tensorFlow与python版本不适应现象：NameError: name ‘XXX’ is not defined原因是：当前tensorflow版本与python版本不适应。解决办法：重新安装tf12345pip3 install --upgrade tensorflow------------Collecting tensorflow Downloading tensorflow-1.6.0-cp35-cp35m-manylinux1_x86_64.whl (45.8MB) 2：变量未初始化1FailedPreconditionError (see above for traceback): Attempting to use uninitialized value Variable_58 解决办法：将变量进行初始化12init = tf.global_variables_initializer()tf.Session().run(init) 打开微信扫一扫，加入数据与算法交流大群","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://thinkgamer.cn/tags/TensorFlow/"}]},{"title":"机器学习中的AUC理解","slug":"机器学习/机器学习中的AUC理解","date":"2018-04-14T19:23:16.000Z","updated":"2019-10-14T06:42:35.686Z","comments":true,"path":"2018/04/15/机器学习/机器学习中的AUC理解/","link":"","permalink":"http://thinkgamer.cn/2018/04/15/机器学习/机器学习中的AUC理解/","excerpt":"最近在做GBDT模型，里边用到胡模型评价方法就是AUC，刚好趁此机会，好好学习一下。","text":"最近在做GBDT模型，里边用到胡模型评价方法就是AUC，刚好趁此机会，好好学习一下。 混淆矩阵(Confusion matrix)混淆矩阵是理解大多数评价指标的基础，毫无疑问也是理解AUC的基础。丰富的资料介绍着混淆矩阵的概念，下边用一个实例讲解什么是混淆矩阵 如有100个样本数据，这些数据分成2类，每类50个。分类结束后得到的混淆矩阵为： 说明：40个为0类别的，预测正确，60个事实是0类别的给预测为1类别的40个为1类别的，预测正确，60个事实是1类别的给预测为0类别的 其对应的混淆矩阵如下： 混淆矩阵包含四部分的信息： True negative(TN)，称为真阴率，表明实际是负样本预测成负样本的样本数 False positive(FP)，称为假阳率，表明实际是负样本预测成正样本的样本数 False negative(FN)，称为假阴率，表明实际是正样本预测成负样本的样本数 True positive(TP)，称为真阳率，表明实际是正样本预测成正样本的样本数 从上边的图可以分析出，对角线带True的为判断对了，斜对角线带False的为判断错了。 像常见的准确率，精准率，召回率，F1-score，AUC都是建立在混淆矩阵上的。 准确率（Accuracy）：判断正确的占总的数目的比例【（TN+TP）/100=(40+40)/100=0.8】精准率（precision）：判断正确的正类占进行判断的数目的比例（针对判别结果而言的，表示预测为正的数据中有多少是真的正确）【TP/(TP+FP) = 40/(40+60 )=0.4】召回率（recall）: 判断正确正类占应该应该判断正确的正类的比例（针对原样本而言，表示样本中的正例有多少被判断正确了）【TP/(TP+FN)=40/(40+60)=0.4】F1-Measure：精确值和召回率的调和均值【2RR/(P+R)=20.40.4/(0.4+0.4)=1】 AUC &amp; ROCAUC是一个模型评价指标，只能用于二分类模型的评价，对于二分类模型，还有损失函数（logloss），正确率（accuracy），准确率（precision），但相比之下AUC和logloss要比accuracy和precision用的多，原因是因为很多的机器学习模型计算结果都是概率的形式，那么对于概率而言，我们就需要去设定一个阈值来判定分类，那么这个阈值的设定就会对我们的正确率和准确率造成一定成都的影响。 AUC(Area under Curve)，表面上意思是曲线下边的面积，这么这条曲线是什么？——ROC曲线（receiver operating characteristic curve，接收者操作特征曲线）。 接下来分析下面这张图（图片来自百度百科）： X轴是假阳率：FP/(FP+TN)Y轴是真阳性：TP(TP+FN)ROC曲线给出的是当阈值(分类器必须提供每个样例被判为阳性或者阴性的可信程度值)变化时假阳率和真阳率的变化情况，左下角的点所对应的是将所有样例判为反例的情况，而右上角的点对应的则是将所有样例判断为正例的情况。ROC曲线不但可以用于比较分类器，还可以基于成本效益分析来做出决策。在理想情况下，最佳的分类器应该尽可能地处于左上角，这就意味着分类器在假阳率很低的同时获得了很高的真阳率。 AUC计算以下部分引用 ROC曲线与AUC计算 中的举例 假设有6次展示记录，有两次被点击了，得到一个展示序列（1:1,2:0,3:1,4:0,5:0,6:0），前面的表示序号，后面的表示点击（1）或没有点击（0）。然后在这6次展示的时候都通过model算出了点击的概率序列。 下面看三种情况。 一、如果概率的序列是（1:0.9,2:0.7,3:0.8,4:0.6,5:0.5,6:0.4）。与原来的序列一起，得到序列（从概率从高到低排）1 0.91 0.80 0.70 0.60 0.50 0.4绘制的步骤是：1）把概率序列从高到低排序，得到顺序（1:0.9,3:0.8,2:0.7,4:0.6,5:0.5,6:0.4）；2）从概率最大开始取一个点作为正类，取到点1，计算得到TPR=0.5，FPR=0.0；3）从概率最大开始，再取一个点作为正类，取到点3，计算得到TPR=1.0，FPR=0.0；4）再从最大开始取一个点作为正类，取到点2，计算得到TPR=1.0，FPR=0.25;5）以此类推，得到6对TPR和FPR。然后把这6对数据组成6个点(0,0.5),(0,1.0),(0.25,1),(0.5,1),(0.75,1),(1.0,1.0)。这6个点在二维坐标系中能绘出来。看看图中，那个就是ROC曲线。 二、如果概率的序列是（1:0.9,2:0.8,3:0.7,4:0.6,5:0.5,6:0.4）。与原来的序列一起，得到序列（从概率从高到低排）1 0.90 0.81 0.70 0.60 0.50 0.4绘制的步骤是：6）把概率序列从高到低排序，得到顺序（1:0.9,2:0.8,3:0.7,4:0.6,5:0.5,6:0.4）；7）从概率最大开始取一个点作为正类，取到点1，计算得到TPR=0.5，FPR=0.0；8）从概率最大开始，再取一个点作为正类，取到点2，计算得到TPR=0.5，FPR=0.25；9）再从最大开始取一个点作为正类，取到点3，计算得到TPR=1.0，FPR=0.25;10） 以此类推，得到6对TPR和FPR。然后把这6对数据组成6个点(0,0.5),(0.25,0.5),(0.25,1),(0.5,1),(0.75,1),(1.0,1.0)。这6个点在二维坐标系中能绘出来。看看图中，那个就是ROC曲线。 三、如果概率的序列是（1:0.4,2:0.6,3:0.5,4:0.7,5:0.8,6:0.9）。与原来的序列一起，得到序列（从概率从高到低排）0 0.90 0.80 0.70 0.61 0.51 0.4绘制的步骤是：11）把概率序列从高到低排序，得到顺序（1:0.4,2:0.6,3:0.5,4:0.7,5:0.8,6:0.9）；12）从概率最大开始取一个点作为正类，取到点6，计算得到TPR=0.0，FPR=0.25；13）从概率最大开始，再取一个点作为正类，取到点5，计算得到TPR=0.0，FPR=0.5；14）再从最大开始取一个点作为正类，取到点4，计算得到TPR=0.0，FPR=0.75;15）以此类推，得到6对TPR和FPR。然后把这6对数据组成6个点(0.25,0.0),(0.5,0.0),(0.75,0.0),(1.0,0.0),(1.0,0.5),(1.0,1.0)。这6个点在二维坐标系中能绘出来。看看图中，那个就是ROC曲线 意义：如上图的例子，总共6个点，2个正样本，4个负样本，取一个正样本和一个负样本的情况总共有8种。 上面的第一种情况，从上往下取，无论怎么取，正样本的概率总在负样本之上，所以分对的概率为1，AUC=1。再看那个ROC曲线，它的积分是什么？也是1，ROC曲线的积分与AUC相等。 上面第二种情况，如果取到了样本2和3，那就分错了，其他情况都分对了；所以分对的概率是0.875，AUC=0.875。再看那个ROC曲线，它的积分也是0.875，ROC曲线的积分与AUC相等。 上面的第三种情况，无论怎么取，都是分错的，所以分对的概率是0，AUC=0.0。再看ROC曲线，它的积分也是0.0，ROC曲线的积分与AUC相等。 很牛吧，其实AUC的意思是——Area Under roc Curve，就是ROC曲线的积分，也是ROC曲线下面的面积。 绘制ROC曲线的意义很明显，不断地把可能分错的情况扣除掉，从概率最高往下取的点，每有一个是负样本，就会导致分错排在它下面的所有正样本，所以要把它下面的正样本数扣除掉（1-TPR，剩下的正样本的比例）。总的ROC曲线绘制出来了，AUC就定了，分对的概率也能求出来了。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"AUC","slug":"AUC","permalink":"http://thinkgamer.cn/tags/AUC/"}]},{"title":"梯度提升决策树-GBDT（Gradient Boosting Decision Tree）","slug":"RecSys/推荐算法/梯度提升决策树-GBDT（Gradient Boosting Decision Tree）","date":"2018-04-12T15:44:15.000Z","updated":"2019-10-14T06:42:35.665Z","comments":true,"path":"2018/04/12/RecSys/推荐算法/梯度提升决策树-GBDT（Gradient Boosting Decision Tree）/","link":"","permalink":"http://thinkgamer.cn/2018/04/12/RecSys/推荐算法/梯度提升决策树-GBDT（Gradient Boosting Decision Tree）/","excerpt":"研究GBDT的背景是业务中使用到了该模型，用于做推荐场景，当然这里就引出了GBDT的一个应用场景-回归，他的另外一个应用场景便是分类，接下来我会从以下几个方面去学习和研究GBDT的相关知识，当然我也是学习者，只是把我理解到的整理出来。本文参考了网上各路大神的笔记，在此感谢！","text":"研究GBDT的背景是业务中使用到了该模型，用于做推荐场景，当然这里就引出了GBDT的一个应用场景-回归，他的另外一个应用场景便是分类，接下来我会从以下几个方面去学习和研究GBDT的相关知识，当然我也是学习者，只是把我理解到的整理出来。本文参考了网上各路大神的笔记，在此感谢！ Boosting&amp;Bagging集成学习方法不是单独的一个机器学习算法，而是通过构建多个机器学习算法来达到一个强学习器。集成学习可以用来进行分类，回归，特征选取和异常点检测等。随机森林算法就是一个典型的集成学习方法，简单的说就是由一个个弱分类器（决策树）来构建一个强分类器，从而达到比较好的分类效果。 那么如何得到单个的学习器，一般有两种方法： 同质（对于一个强学习器而言，所用的单个弱学习器都是一样的，比如说用的都是决策树，或者都是神经网络） 异质（相对于同质而言，对于一个强学习器而言，所用的单个弱学习器不全是一样的，比如说用的决策树和神经网络的组合） 相对异质而言，同质学习期用的最为广泛，我们平时所讨论的集成学习方法指的就是同质个体学习器，同质个体学习器按照个体学习器之间的依赖关系分为串行（有强依赖关系）和并行（不存在关系或者有很弱的依赖关系），而在串行关系中有代表性的就是boosting系列算法，并行关系中具有代表性的就是bagging和随机森林（random forest） Boosting流程图 Bagging流程图 上边简单的介绍了集成学习方法和boosting&amp;bagging的区别，那么对于单个学习器采用何种策略才能得到一个强学习器呢？ 平均法（加权（个体学习器性能相差较大），简单（性能相近）） 投票法（绝对多数（超过半数标记。否则拒绝预测），相对多数，加权投票） 学习法（通过另一个学习器来进行结合，Stacking算法） Stacking算法：基本思想：先从初始数据集训练出初级学习器，然后生成一个新数据集用于训练次级学习器。在这个新数据集中，初级学习器的输出被当作样例输入特征，而出事样本的标记仍被当作样例标记。注意点：若直接用初级学习器的训练集来产生次级训练集，则过拟合风险会比较大；一般会通过交叉验证等方式，用训练初级学习器未使用的样本来产生次级学习器的训练样本。 Gradient BoostingGradient Boosting是一种Boosting的方法，它主要的思想是，每一次建立模型是在之前建立模型损失函数的梯度下降方向。损失函数是评价模型性能（一般为拟合程度+正则项），认为损失函数越小，性能越好。而让损失函数持续下降，就能使得模型不断改性提升性能，其最好的方法就是使损失函数沿着梯度方向下降（讲道理梯度方向上下降最快）。 Gradient Boost是一个框架，里面可以套入很多不同的算法。 分类树&amp;回归树&amp;分类回归树分类树三种比较常见的分类决策树分支划分方式包括：ID3, C4.5, CART。 以C4.5分类树为例，C4.5分类树在每次分枝时，是穷举每一个feature的每一个阈值，找到使得按照feature&lt;=阈值，和feature&gt;阈值分成的两个分枝的熵最大的阈值(熵最大的概念可理解成尽可能每个分枝的男女比例都远离1:1)，按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。 总结：分类树使用信息增益或增益比率来划分节点；每个节点样本的类别情况投票决定测试样本的类别。 回归树 回归树总体流程也是类似，区别在于，回归树的每个节点（不一定是叶子节点）都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差即(每个人的年龄-预测年龄)^2 的总和 / N。也就是被预测出错的人数越多，错的越离谱，均方差就越大，通过最小化均方差能够找到最可靠的分枝依据。分枝直到每个叶子节点上人的年龄都唯一或者达到预设的终止条件(如叶子个数上限)，若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。 总结：回归树使用最大均方差划分节点；每个节点样本的均值作为测试样本的回归预测值。 分类回归树 Classification And Regression Trees，即既能做分类任务又能做回归任务，CART也是决策树的一种，是一种二分决策树，但是也可以用来做回归，CART同决策树类似，不同于 ID3 与 C4.5 ,分类树采用基尼指数来选择最优的切分特征，而且每次都是二分。至于怎么利用基尼系数进行最优的特征切分，大家可以参考这篇文章的详细介绍 决策树之 CART 损失函数机器学习中的损失函数有很多，常见的有 0-1损失函数（0-1 loss function） L(Y,f(X))=\\left\\{ \\begin{aligned}&1,\\quad Y\\ne f(X)\\\\& 0,\\quad Y=f(X) \\end{aligned} \\right. 该损失函数的意义就是，当预测错误时，损失函数值为1，预测正确时，损失函数值为0。该损失函数不考虑预测值和真实值的误差程度，也就是只要预测错误，预测错误差一点和差很多是一样的。 平方损失函数（quadratic loss function） L(Y,f(X))=(Y-f(X))^2 取预测差距的平方 绝对值损失函数（absolute loss function） L(Y,f(X))=|Y-f(X)| 取预测值与真实值的差值绝对值，差距不会被平方放大 对数损失函数（logarithmic loss function） L(Y,P(Y|X))=-logP(Y|X) 该损失函数用到了极大似然估计的思想。P(Y|X)通俗的解释就是：在当前模型的基础上，对于样本X，其预测值为Y，也就是预测正确的概率。由于概率之间的同时满足需要使用乘法，为了将其转化为加法，我们将其取对数。最后由于是损失函数，所以预测正确的概率越高，其损失值应该是越小，因此再加个负号取个反。 全局损失函数 上面的损失函数仅仅是对于一个样本来说的。而我们的优化目标函数应当是使全局损失函数最小。因此，全局损失函数往往是每个样本的损失函数之和，即： J(w,b)=\\frac{1}{m} \\sum_{i=1}^m L(Y,f(X))对于平方损失函数，为了求导方便，我们可以在前面乘上一个1/2，和平方项求导后的2抵消，即： J(w,b)=\\frac{1}{2m} \\sum_{i=1}^m L(Y,f(X)) 逻辑回归中的损失函数 在逻辑回归中，我们采用的是对数损失函数。由于逻辑回归是服从伯努利分布(0-1分布)的，并且逻辑回归返回的sigmoid值是处于(0,1)区间，不会取到0,1两个端点。因此我们能够将其损失函数写成以下形式： L(\\hat y,y)=-(y\\log{\\hat y}+(1-y)\\log(1-\\hat y)) GBDT思想 以下部分学习于 GBDT算法原理深入解析 ，原文作者讲的很好，照搬过来，毕竟笔者不是推导数学公式的料，哈哈 GBDT 可以看成是由K棵树组成的加法模型： \\hat{y}_i=\\sum_{k=1}^K f_k(x_i), f_k \\in F \\tag 0其中F为所有树组成的函数空间，以回归任务为例，回归树可以看作为一个把特征向量映射为某个score的函数。该模型的参数为：$\\Theta=\\{f_1,f_2, \\cdots, f_K \\}$。于一般的机器学习算法不同的是，加法模型不是学习d维空间中的权重，而是直接学习函数（决策树）集合 上述加法模型的目标函数定义为：$Obj=\\sum_{i=1}^n l(y_i, \\hat{y}_i) + \\sum_{k=1}^K \\Omega(f_k)$，其中$\\Omega$表示决策树的复杂度，那么该如何定义树的复杂度呢？比如，可以考虑树的节点数量、树的深度或者叶子节点所对应的分数的L2范数等等。 如何来学习加法模型呢？ 解这一优化问题，可以用前向分布算法（forward stagewise algorithm）。因为学习的是加法模型，如果能够从前往后，每一步只学习一个基函数及其系数（结构），逐步逼近优化目标函数，那么就可以简化复杂度。这一学习过程称之为Boosting。具体地，我们从一个常量预测开始，每次学习一个新的函数，过程如下： \\begin{split} \\hat{y}_i^0 &= 0 \\\\ \\hat{y}_i^1 &= f_1(x_i) = \\hat{y}_i^0 + f_1(x_i) \\\\ \\hat{y}_i^2 &= f_1(x_i) + f_2(x_i) = \\hat{y}_i^1 + f_2(x_i) \\\\ & \\cdots \\\\ \\hat{y}_i^t &= \\sum_{k=1}^t f_k(x_i) = \\hat{y}_i^{t-1} + f_t(x_i) \\\\ \\end{split}那么，在每一步如何决定哪一个函数$f$被加入呢？指导原则还是最小化目标函数。在第$t$步，模型对$x_i$的预测为：$\\hat{y}_i^t= \\hat{y}_i^{t-1} + f_t(x_i)$，其中$f_t(x_i)$为这一轮我们要学习的函数（决策树）。这个时候目标函数可以写为： \\begin{split} Obj^{(t)} &= \\sum_{i=1}^nl(y_i, \\hat{y}_i^t) + \\sum_{i=i}^t \\Omega(f_i) \\\\ &= \\sum_{i=1}^n l\\left(y_i, \\hat{y}_i^{t-1} + f_t(x_i) \\right) + \\Omega(f_t) + constant \\end{split}\\tag{1}举例说明，假设损失函数为平方损失（square loss），则目标函数为： \\begin{split} Obj^{(t)} &= \\sum_{i=1}^n \\left(y_i - (\\hat{y}_i^{t-1} + f_t(x_i)) \\right)^2 + \\Omega(f_t) + constant \\\\ &= \\sum_{i=1}^n \\left[2(\\hat{y}_i^{t-1} - y_i)f_t(x_i) + f_t(x_i)^2 \\right] + \\Omega(f_t) + constant \\end{split}\\tag{2}其中，$(\\hat{y}_i^{t-1} - y_i)$称之为残差（residual）。因此，使用平方损失函数时，GBDT算法的每一步在生成决策树时只需要拟合前面的模型的残差。 泰勒公式：设$n$是一个正整数，如果定义在一个包含$a$的区间上的函数$f$在点$a$处$n+1$次可导，那么对于这个区间上的任意$x$都有：$\\displaystyle f(x)=\\sum _{n=0}^{N}\\frac{f^{(n)}(a)}{n!}(x-a)^ n+R_ n(x)$，其中的多项式称为函数在$a$处的泰勒展开式，$R_ n(x)$是泰勒公式的余项且是$(x-a)^ n$的高阶无穷小。 根据泰勒公式把函数$f(x+\\Delta x)$在点$x$处二阶展开，可得到如下等式： f(x+\\Delta x) \\approx f(x) + f'(x)\\Delta x + \\frac12 f''(x)\\Delta x^2 \\tag 3由等式(1)可知，目标函数是关于变量$\\hat{y}_i^{t-1} + f_t(x_i)$的函数，若把变量$\\hat{y}_i^{t-1}$看成是等式(3)中的$x$，把变量$f_t(x_i)$看成是等式(3)中的$\\Delta x$，则等式(1)可转化为： Obj^{(t)} = \\sum_{i=1}^n \\left[ l(y_i, \\hat{y}_i^{t-1}) + g_if_t(x_i) + \\frac12h_if_t^2(x_i) \\right] + \\Omega(f_t) + constant \\tag 4其中$g_i$，定义为损失函数的一阶导数，即$g_i=\\partial_{\\hat{y}^{t-1}}l(y_i,\\hat{y}^{t-1})$；$h_i$定义为损失函数的二阶导数，即$h_i=\\partial_{\\hat{y}^{t-1}}^2l(y_i,\\hat{y}^{t-1})$。假设损失函数为平方损失函数，则$g_i=\\partial_{\\hat{y}^{t-1}}(\\hat{y}^{t-1} - y_i)^2 = 2(\\hat{y}^{t-1} - y_i)$，$h_i=\\partial_{\\hat{y}^{t-1}}^2(\\hat{y}^{t-1} - y_i)^2 = 2$，把$g_i$和$h_i$代入等式(4)即得等式(2)。由于函数中的常量在函数最小化的过程中不起作用，因此我们可以从等式(4)中移除掉常量项，得： Obj^{(t)} \\approx \\sum_{i=1}^n \\left[ g_if_t(x_i) + \\frac12h_if_t^2(x_i) \\right] + \\Omega(f_t) \\tag 5由于要学习的函数仅仅依赖于目标函数，从等式(5)可以看出只需为学习任务定义好损失函数，并为每个训练样本计算出损失函数的一阶导数和二阶导数，通过在训练样本集上最小化等式(5)即可求得每步要学习的函数$f(x)$，从而根据加法模型等式(0)可得最终要学习的模型。 GBDT在Scikit-learn中的调用关于GBDT在Scikit-learn中的实现原文在 点击查看GBDT在sklearn中导入的包不一样，分类是 from sklearn.ensemble import GradientBoostingClassifier，回归是 from sklearn.ensemble import GradientBoostingRegressor 参数说明GBDT的参数分为boosting类库参数和弱学习器参数，其中有GBDT的弱学习器为CART，所以弱学习器参数基本为决策树的参数，参考点击阅读 类库参数 loss：损失函数，对于分类模型，有对数似然损失函数”deviance”和指数损失函数”exponential”两者输入选择。默认是对数似然损失函数”deviance”。在原理篇中对这些分类损失函数有详细的介绍。一般来说，推荐使用默认的”deviance”。它对二元分离和多元分类各自都有比较好的优化。而指数损失函数等于把我们带到了Adaboost算法。 learning_rate：即每个弱学习器的权重缩减系数νν，也称作步长。 n_estimators：就是弱学习器的最大迭代次数，或者说最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，又容易过拟合，一般选择一个适中的数值。默认是100。在实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。 subsample：子采样，取值是[0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间，默认是1.0，即不使用子采样。 init：即我们的初始化的时候的弱学习器，如果不输入，则用训练集样本来做样本集的初始化分类回归预测。否则用init参数提供的学习器做初始化分类回归预测。一般用在我们对数据有先验知识，或者之前做过一些拟合的时候，如果没有的话就不用管这个参数了。 verbose：默认是0，代表启用详细输出，若为1，代表偶尔输出进度信息 warm_start：默认为false random_state：如果int，random_state随机数生成器使用的种子；如果randomstate实例，random_state是随机数发生器；如果没有，随机数生成器使用的np.random的randomstate实例。 presort：默认情况下会在密集的数据上使用，默认是在稀疏数据正常排序。设置对true的稀疏数据将会引起错误。 决策树参数 max_depth：决策树最大深度 criterion：衡量分裂指标的度量方法，支持的是均方误差 min_samples_split：内部节点再划分所需最小样本数。这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。 默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 min_samples_leaf：叶子节点最少样本数。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 min_weight_fraction_leaf：叶子节点最小的样本权重和。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。 max_features：划分时考虑的最大特征数。可以使用很多种类型的值，默认是”None”,意味着划分时考虑所有的特征数；如果是”log2”意味着划分时最多考虑log2Nlog2N个特征；如果是”sqrt”或者”auto”意味着划分时最多考虑N−−√N个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。其中N为样本总特征数。一般来说，如果样本特征数不多，比如小于50，我们用默认的”None”就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。 max_leaf_nodes：最大叶子节点数。通过限制最大叶子节点数，可以防止过拟合，默认是”None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。 min_impurity_split：节点划分最小不纯度。这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。一般不推荐改动默认值1e-7。 min_impurity_decrease：默认值为0。如果分裂 分类1234567891011&gt;&gt;&gt; from sklearn.datasets import make_hastie_10_2&gt;&gt;&gt; from sklearn.ensemble import GradientBoostingClassifier&gt;&gt;&gt; X, y = make_hastie_10_2(random_state=0)&gt;&gt;&gt; X_train, X_test = X[:2000], X[2000:]&gt;&gt;&gt; y_train, y_test = y[:2000], y[2000:]&gt;&gt;&gt; clf = GradientBoostingClassifier(n_estimators=100, learning_rate=1.0,... max_depth=1, random_state=0).fit(X_train, y_train)&gt;&gt;&gt; clf.score(X_test, y_test) 0.913... 回归123456789101112&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; from sklearn.metrics import mean_squared_error&gt;&gt;&gt; from sklearn.datasets import make_friedman1&gt;&gt;&gt; from sklearn.ensemble import GradientBoostingRegressor&gt;&gt;&gt; X, y = make_friedman1(n_samples=1200, random_state=0, noise=1.0)&gt;&gt;&gt; X_train, X_test = X[:200], X[200:]&gt;&gt;&gt; y_train, y_test = y[:200], y[200:]&gt;&gt;&gt; est = GradientBoostingRegressor(n_estimators=100, learning_rate=0.1,... max_depth=1, random_state=0, loss='ls').fit(X_train, y_train)&gt;&gt;&gt; mean_squared_error(y_test, est.predict(X_test)) 5.00... 模型评价123from sklearn import cross_validation, metricsmetrics.accuracy_score(y.values, y_pred) # 准确度metrics.roc_auc_score(y, y_predprob) # AUC大小 参考资料： 集成学习原理小结 Regression Tree 回归树 浅析机器学习中各种损失函数及其含义 打开微信扫一扫，加入数据与算法交流大群 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"http://thinkgamer.cn/tags/推荐算法/"},{"name":"GBDT","slug":"GBDT","permalink":"http://thinkgamer.cn/tags/GBDT/"}]},{"title":"商务合作介绍","slug":"随缘/商务合作介绍","date":"2018-04-03T12:21:24.000Z","updated":"2019-10-14T06:42:35.695Z","comments":true,"path":"2018/04/03/随缘/商务合作介绍/","link":"","permalink":"http://thinkgamer.cn/2018/04/03/随缘/商务合作介绍/","excerpt":"WelCome To “Thinkgamer 小站” 合作范围 Web全栈 数据服务 模型构建 :-: :-: :-: 论文算法实现 大数据服务 :-: :-: :-: 跟拍摄影 广告接入","text":"WelCome To “Thinkgamer 小站” 合作范围 Web全栈 数据服务 模型构建 :-: :-: :-: 论文算法实现 大数据服务 :-: :-: :-: 跟拍摄影 广告接入 全网唯一ID：Thinkgamer，左侧”关于我“关注微信公众号”搜索与推荐Wiki“，可在公众号添加我的微信，本人涉猎范围包括：推荐系统，Python，机器学习，Web开发，大数据云计算，ELK。 ▶ Web全栈 如果您在创业，苦于没有额外精力管理一个技术团队；如果您在工作，遇到了一些您解决不了的问题；如果您的网站苦于没有运维；如果您的数据需要备份；如果一切有关Web开发运维的问题。您都可以来找我，我虽不是最厉害的，但绝对会为您提供最优质的服务。 ▶ 数据服务 包含但不局限于以下数据相关的服务： 数据采集（一次性和程序开发） 数据清洗 数据可视化（不限于Web） 数据存储方案设计与实现 … … 本人曾多次向他人提供数据相关的技术服务，积累了一定的经验，相信能够为您提供全方位的数据服务。 ▶ 模型构建 根据对方提供的具体业务场景，进行相关模型选择与构建。当然，如果有荣幸参与您的场景选定和数据准备阶段，也是极好的。 ▶ 论文算法实现 如果您是一个马上要毕业的本科或者研究生，如果您苦于论文的立项与项目实现，如果您没有更好的主意，欢迎您来找我，加我的个人微信，为您的毕业保驾护航。 ▶ 大数据与分布式计算 提供大数据相关的服务，包含但不局限于： 大数据分析平台方案设计 大数据分析平台搭建 基于平台的数据分析Demo实现 海量数据的分布式计算处理 … … &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;欢迎来找我，24小时在线。 ▶ 广告接入 眼前的黑不是黑，Ta们说的白是什么白，也许一直是我们忘了搭一座桥，到对方的心里瞧一瞧。你的品牌，你的知名度为什么那么低，因为你没有使用我的广告接入，那么问题来了，包含但不局限于以下几种情况的，可以加我微信私聊了： 品牌宣传 广告位接入 公众号互相推广 个人网站/社区主页链接 … … ▶ 跟拍摄影 如果您在旅游途中缺少了一个摄影的小跟班；如果您苦于找不到好的角度拍照；如果您是一个人，苦于没有人照出你的美；如果您的照片需要美化与调整。那么请您来找我，保证为您提供最优质的技术与服务。 业务涉及： 跟拍摄影 照片美化与调整 PS技术服务 小本生意&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;诚信经验 大神勿扰&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自求多福","categories":[],"tags":[{"name":"商务合作","slug":"商务合作","permalink":"http://thinkgamer.cn/tags/商务合作/"}]},{"title":"Softmax-Regression","slug":"机器学习/Softmax-Regression","date":"2018-03-28T15:44:15.000Z","updated":"2019-10-14T06:42:35.682Z","comments":true,"path":"2018/03/28/机器学习/Softmax-Regression/","link":"","permalink":"http://thinkgamer.cn/2018/03/28/机器学习/Softmax-Regression/","excerpt":"在本节中，我们介绍Softmax回归模型","text":"在本节中，我们介绍Softmax回归模型 简介该模型是logistic回归模型在多分类问题上的推广，在多分类问题中，类标签 \\textstyle y 可以取两个以上的值。 Softmax回归模型对于诸如MNIST手写数字分类等问题是很有用的，该问题的目的是辨识10个不同的单个数字。Softmax回归是有监督的，不过后面也会介绍它与深度学习/无监督学习方法的结合。（译者注： MNIST 是一个手写数字识别库，由NYU 的Yann LeCun 等人维护。http://yann.lecun.com/exdb/mnist/ ） 回想一下在 logistic 回归中，我们的训练集由 \\textstyle m 个已标记的样本构成：$ \\{ (x^{(1)}, y^{(1)}), \\ldots, (x^{(m)}, y^{(m)}) \\} $ ，其中输入特征$ x^{(i)} \\in \\Re^{n+1} $（我们对符号的约定如下：特征向量$ \\textstyle x $ 的维度为 \\textstyle n+1，其中 \\textstyle x_0 = 1 对应截距项 。） 由于 logistic 回归是针对二分类问题的，因此类标记 $ y^{(i)} \\in \\{0,1\\}$。假设函数(hypothesis function) 如下： \\begin{align} h_\\theta(x) = \\frac{1}{1+\\exp(-\\theta^Tx)}, \\end{align}我们将训练模型参数$ \\textstyle \\theta $，使其能够最小化代价函数 ： \\begin{align} J(\\theta) = -\\frac{1}{m} \\left[ \\sum_{i=1}^m y^{(i)} \\log h_\\theta(x^{(i)}) + (1-y^{(i)}) \\log (1-h_\\theta(x^{(i)})) \\right] \\end{align}在 softmax回归中，我们解决的是多分类问题（相对于 logistic 回归解决的二分类问题），类标$ \\textstyle y $可以取$ \\textstyle k $ 个不同的值（而不是 2 个）。因此，对于训练集$ \\{ (x^{(1)}, y^{(1)}), \\ldots, (x^{(m)}, y^{(m)}) \\} $，我们有$ y^{(i)} \\in \\{1, 2, \\ldots, k\\} $。（注意此处的类别下标从 1 开始，而不是 0）。例如，在 MNIST 数字识别任务中，我们有$ \\textstyle k=10 $个不同的类别。 对于给定的测试输入$ \\textstyle x$，我们想用假设函数针对每一个类别j估算出概率值$ \\textstyle p(y=j | x)$。也就是说，我们想估计$ \\textstyle x $ 的每一种分类结果出现的概率。因此，我们的假设函数将要输出一个 $ \\textstyle k $维的向量（向量元素的和为1）来表示这$ \\textstyle k$ 个估计的概率值。 具体地说，我们的假设函数$ \\textstyle h_{\\theta}(x) $ 形式如下： \\begin{align} h_\\theta(x^{(i)}) = \\begin{bmatrix} p(y^{(i)} = 1 | x^{(i)}; \\theta) \\\\ p(y^{(i)} = 2 | x^{(i)}; \\theta) \\\\ \\vdots \\\\ p(y^{(i)} = k | x^{(i)}; \\theta) \\end{bmatrix} = \\frac{1}{ \\sum_{j=1}^{k}{e^{ \\theta_j^T x^{(i)} }} } \\begin{bmatrix} e^{ \\theta_1^T x^{(i)} } \\\\ e^{ \\theta_2^T x^{(i)} } \\\\ \\vdots \\\\ e^{ \\theta_k^T x^{(i)} } \\\\ \\end{bmatrix} \\end{align}其中$ \\theta_1, \\theta_2, \\ldots, \\theta_k \\in \\Re^{n+1}$ 是模型的参数。请注意$ \\frac{1}{ \\sum_{j=1}^{k}{e^{ \\theta_j^T x^{(i)} }} } $这一项对概率分布进行归一化，使得所有概率之和为 1 。 为了方便起见，我们同样使用符号$ \\textstyle \\theta$ 来表示全部的模型参数。在实现Softmax回归时，将$ \\textstyle \\theta$ 用一个$ \\textstyle k \\times(n+1) $的矩阵来表示会很方便，该矩阵是将 $ \\theta_1, \\theta_2, \\ldots, \\theta_k $ 按行罗列起来得到的，如下所示： \\theta = \\begin{bmatrix} \\mbox{---} \\theta_1^T \\mbox{---} \\\\ \\mbox{---} \\theta_2^T \\mbox{---} \\\\ \\vdots \\\\ \\mbox{---} \\theta_k^T \\mbox{---} \\\\ \\end{bmatrix}代价函数现在我们来介绍 softmax 回归算法的代价函数。在下面的公式中，$\\textstyle 1\\{\\cdot\\}$ 是示性函数，其取值规则为：$ \\textstyle 1\\{ 值为真的表达式 \\textstyle \\}=1 $ ，$ \\textstyle 1\\{ 值为假的表达式 \\textstyle \\}=0 $。举例来说，表达式$ \\textstyle 1\\{2+2=4\\} $的值为1 ，$ \\textstyle 1\\{1+1=5\\} $的值为 0。我们的代价函数为： \\begin{align} J(\\theta) = - \\frac{1}{m} \\left[ \\sum_{i=1}^{m} \\sum_{j=1}^{k} 1\\left\\{y^{(i)} = j\\right\\} \\log \\frac{e^{\\theta_j^T x^{(i)}}}{\\sum_{l=1}^k e^{ \\theta_l^T x^{(i)} }}\\right] \\end{align}值得注意的是，上述公式是logistic回归代价函数的推广。logistic回归代价函数可以改为： \\begin{align} J(\\theta) &= -\\frac{1}{m} \\left[ \\sum_{i=1}^m (1-y^{(i)}) \\log (1-h_\\theta(x^{(i)})) + y^{(i)} \\log h_\\theta(x^{(i)}) \\right] \\\\ &= - \\frac{1}{m} \\left[ \\sum_{i=1}^{m} \\sum_{j=0}^{1} 1\\left\\{y^{(i)} = j\\right\\} \\log p(y^{(i)} = j | x^{(i)} ; \\theta) \\right] \\end{align}可以看到，Softmax代价函数与logistic 代价函数在形式上非常类似，只是在Softmax损失函数中对类标记的 $\\textstyle k $个可能值进行了累加。注意在Softmax回归中将 \\textstyle x 分类为类别 $\\textstyle j $的概率为： p(y^{(i)} = j | x^{(i)} ; \\theta) = \\frac{e^{\\theta_j^T x^{(i)}}}{\\sum_{l=1}^k e^{ \\theta_l^T x^{(i)}} } .对于$ \\textstyle J(\\theta)$ 的最小化问题，目前还没有闭式解法。因此，我们使用迭代的优化算法（例如梯度下降法，或 L-BFGS）。经过求导，我们得到梯度公式如下： \\begin{align} \\nabla_{\\theta_j} J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^{m}{ \\left[ x^{(i)} \\left( 1\\{ y^{(i)} = j\\} - p(y^{(i)} = j | x^{(i)}; \\theta) \\right) \\right] } \\end{align}让我们来回顾一下符号 “$ \\textstyle \\nabla_{\\theta_j}$” 的含义。$\\textstyle \\nabla_{\\theta_j} J(\\theta)$ 本身是一个向量，它的第$ \\textstyle l $个元素$ \\textstyle \\frac{\\partial J(\\theta)}{\\partial \\theta_{jl}} $是$ \\textstyle J(\\theta)对\\textstyle \\theta_j $的第 $\\textstyle l $个分量的偏导数。 有了上面的偏导数公式以后，我们就可以将它代入到梯度下降法等算法中，来最小化$ \\textstyle J(\\theta)$。 例如，在梯度下降法的标准实现中，每一次迭代需要进行如下更新: $\\textstyle \\theta_j := \\theta_j - \\alpha \\nabla_{\\theta_j} J(\\theta)(\\textstyle j=1,\\ldots,k）$。 当实现 softmax 回归算法时， 我们通常会使用上述代价函数的一个改进版本。具体来说，就是和权重衰减(weight decay)一起使用。我们接下来介绍使用它的动机和细节。 Softmax回归模型参数化的特点Softmax 回归有一个不寻常的特点：它有一个“冗余”的参数集。为了便于阐述这一特点，假设我们从参数向量 $\\textstyle \\theta_j $中减去了向量 $\\textstyle \\psi$，这时，每一个$ \\textstyle \\theta_j $都变成了 $\\textstyle \\theta_j - \\psi(\\textstyle j=1, \\ldots, k)$。此时假设函数变成了以下的式子： \\begin{align} p(y^{(i)} = j | x^{(i)} ; \\theta) &= \\frac{e^{(\\theta_j-\\psi)^T x^{(i)}}}{\\sum_{l=1}^k e^{ (\\theta_l-\\psi)^T x^{(i)}}} \\\\ &= \\frac{e^{\\theta_j^T x^{(i)}} e^{-\\psi^Tx^{(i)}}}{\\sum_{l=1}^k e^{\\theta_l^T x^{(i)}} e^{-\\psi^Tx^{(i)}}} \\\\ &= \\frac{e^{\\theta_j^T x^{(i)}}}{\\sum_{l=1}^k e^{ \\theta_l^T x^{(i)}}}. \\end{align}换句话说，从$ \\textstyle \\theta_j $中减去$ \\textstyle \\psi$ 完全不影响假设函数的预测结果！这表明前面的 softmax 回归模型中存在冗余的参数。更正式一点来说， Softmax 模型被过度参数化了。对于任意一个用于拟合数据的假设函数，可以求出多组参数值，这些参数得到的是完全相同的假设函数$ \\textstyle h_\\theta$。 进一步而言，如果参数 $\\textstyle (\\theta_1, \\theta_2,\\ldots, \\theta_k) $是代价函数$ \\textstyle J(\\theta)$ 的极小值点，那么 $\\textstyle (\\theta_1 - \\psi, \\theta_2 - \\psi,\\ldots,\\theta_k - \\psi) $同样也是它的极小值点，其中 $\\textstyle \\psi$ 可以为任意向量。因此使 $\\textstyle J(\\theta)$ 最小化的解不是唯一的。（有趣的是，由于$ \\textstyle J(\\theta)$ 仍然是一个凸函数，因此梯度下降时不会遇到局部最优解的问题。但是 Hessian 矩阵是奇异的/不可逆的，这会直接导致采用牛顿法优化就遇到数值计算的问题） 注意，当$ \\textstyle \\psi = \\theta_1$ 时，我们总是可以将 $\\textstyle \\theta_1$替换为$\\textstyle \\theta_1 - \\psi = \\vec{0}$（即替换为全零向量），并且这种变换不会影响假设函数。因此我们可以去掉参数向量 $\\textstyle \\theta_1 $（或者其他 $\\textstyle \\theta_j $中的任意一个）而不影响假设函数的表达能力。实际上，与其优化全部的$ \\textstyle k\\times(n+1) $个参数 $\\textstyle (\\theta_1, \\theta_2,\\ldots, \\theta_k)$ （其中 $\\textstyle \\theta_j \\in \\Re^{n+1}）$，我们可以令$ \\textstyle \\theta_1 =\\vec{0}$，只优化剩余$的 \\textstyle (k-1)\\times(n+1)$ 个参数，这样算法依然能够正常工作。 在实际应用中，为了使算法实现更简单清楚，往往保留所有参数$ \\textstyle (\\theta_1, \\theta_2,\\ldots, \\theta_n)$，而不任意地将某一参数设置为 0。但此时我们需要对代价函数做一个改动：加入权重衰减。权重衰减可以解决 softmax 回归的参数冗余所带来的数值问题。 权重衰减我们通过添加一个权重衰减项$\\textstyle \\frac{\\lambda}{2} \\sum_{i=1}^k \\sum_{j=0}^{n} \\theta_{ij}^2$ 来修改代价函数，这个衰减项会惩罚过大的参数值，现在我们的代价函数变为： \\begin{align} J(\\theta) = - \\frac{1}{m} \\left[ \\sum_{i=1}^{m} \\sum_{j=1}^{k} 1\\left\\{y^{(i)} = j\\right\\} \\log \\frac{e^{\\theta_j^T x^{(i)}}}{\\sum_{l=1}^k e^{ \\theta_l^T x^{(i)} }} \\right] + \\frac{\\lambda}{2} \\sum_{i=1}^k \\sum_{j=0}^n \\theta_{ij}^2 \\end{align}有了这个权重衰减项以后 ($\\textstyle \\lambda &gt; 0$)，代价函数就变成了严格的凸函数，这样就可以保证得到唯一的解了。 此时的 Hessian矩阵变为可逆矩阵，并且因为$\\textstyle J(\\theta)$是凸函数，梯度下降法和 L-BFGS 等算法可以保证收敛到全局最优解。 为了使用优化算法，我们需要求得这个新函数$ \\textstyle J(\\theta)$ 的导数，如下： \\begin{align} \\nabla_{\\theta_j} J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^{m}{ \\left[ x^{(i)} ( 1\\{ y^{(i)} = j\\} - p(y^{(i)} = j | x^{(i)}; \\theta) ) \\right] } + \\lambda \\theta_j \\end{align} 通过最小化 \\textstyle J(\\theta)，我们就能实现一个可用的 softmax 回归模型。 # Softmax回归与Logistic 回归的关系 当类别数$ \\textstyle k = 2 $时，softmax 回归退化为 logistic 回归。这表明 softmax 回归是 logistic 回归的一般形式。具体地说，当 $\\textstyle k = 2 $时，softmax 回归的假设函数为：\\begin{align}h_\\theta(x) &amp;=\\frac{1}{ e^{\\theta_1^Tx} + e^{ \\theta_2^T x^{(i)} } }\\begin{bmatrix}e^{ \\theta_1^T x } \\\\e^{ \\theta_2^T x }\\end{bmatrix}\\end{align} 利用softmax回归参数冗余的特点，我们令$ \\textstyle \\psi = \\theta_1$，并且从两个参数向量中都减去向量$ \\textstyle \\theta_1$，得到:\\begin{align}h(x) &amp;=\\frac{1}{ e^{\\vec{0}^Tx} + e^{ (\\theta_2-\\theta_1)^T x^{(i)} } }\\begin{bmatrix}e^{ \\vec{0}^T x } \\\\e^{ (\\theta_2-\\theta_1)^T x }\\end{bmatrix} \\\\&amp;=\\begin{bmatrix}\\frac{1}{ 1 + e^{ (\\theta_2-\\theta_1)^T x^{(i)} } } \\\\\\frac{e^{ (\\theta_2-\\theta_1)^T x }}{ 1 + e^{ (\\theta_2-\\theta_1)^T x^{(i)} } }\\end{bmatrix} \\\\&amp;=\\begin{bmatrix}\\frac{1}{ 1 + e^{ (\\theta_2-\\theta_1)^T x^{(i)} } } \\\\1 - \\frac{1}{ 1 + e^{ (\\theta_2-\\theta_1)^T x^{(i)} } } \\\\\\end{bmatrix}\\end{align} $$因此，用$ \\textstyle \\theta$’来表示$\\textstyle \\theta_2-\\theta_1$，我们就会发现 softmax 回归器预测其中一个类别的概率为 $\\textstyle \\frac{1}{ 1 + e^{ (\\theta’)^T x^{(i)} } }$，另一个类别概率的为$ \\textstyle 1 - \\frac{1}{ 1 + e^{ (\\theta’)^T x^{(i)} } }$，这与 logistic回归是一致的。 Softmax 回归 vs. k 个二元分类器如果你在开发一个音乐分类的应用，需要对k种类型的音乐进行识别，那么是选择使用 softmax 分类器呢，还是使用 logistic 回归算法建立 k 个独立的二元分类器呢？ 这一选择取决于你的类别之间是否互斥，例如，如果你有四个类别的音乐，分别为：古典音乐、乡村音乐、摇滚乐和爵士乐，那么你可以假设每个训练样本只会被打上一个标签（即：一首歌只能属于这四种音乐类型的其中一种），此时你应该使用类别数 k = 4 的softmax回归。（如果在你的数据集中，有的歌曲不属于以上四类的其中任何一类，那么你可以添加一个“其他类”，并将类别数 k 设为5。） 如果你的四个类别如下：人声音乐、舞曲、影视原声、流行歌曲，那么这些类别之间并不是互斥的。例如：一首歌曲可以来源于影视原声，同时也包含人声 。这种情况下，使用4个二分类的 logistic 回归分类器更为合适。这样，对于每个新的音乐作品 ，我们的算法可以分别判断它是否属于各个类别。 现在我们来看一个计算视觉领域的例子，你的任务是将图像分到三个不同类别中。(i) 假设这三个类别分别是：室内场景、户外城区场景、户外荒野场景。你会使用sofmax回归还是 3个logistic 回归分类器呢？ (ii) 现在假设这三个类别分别是室内场景、黑白图片、包含人物的图片，你又会选择 softmax 回归还是多个 logistic 回归分类器呢？ 在第一个例子中，三个类别是互斥的，因此更适于选择softmax回归分类器 。而在第二个例子中，建立三个独立的 logistic回归分类器更加合适。 中英文对照 Softmax回归 Softmax Regression 有监督学习 supervised learning 无监督学习 unsupervised learning 深度学习 deep learning logistic回归 logistic regression 截距项 intercept term 二元分类 binary classification 类型标记 class labels 估值函数/估计值 hypothesis 代价函数 cost function 多元分类 multi-class classification 权重衰减 weight decay 原文链接：http://ufldl.stanford.edu/wiki/index.php/Softmax%E5%9B%9E%E5%BD%92英文链接：http://ufldl.stanford.edu/wiki/index.php/Softmax_Regression 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"SoftMax","slug":"SoftMax","permalink":"http://thinkgamer.cn/tags/SoftMax/"}]},{"title":"推荐系统的一些思考","slug":"RecSys/推荐系统的一些思考","date":"2018-03-25T21:55:44.000Z","updated":"2019-10-14T06:42:35.671Z","comments":true,"path":"2018/03/26/RecSys/推荐系统的一些思考/","link":"","permalink":"http://thinkgamer.cn/2018/03/26/RecSys/推荐系统的一些思考/","excerpt":"推荐系统一直以来都是电商网站必不可少的一项，在提升用户转化，增加GMV方面可谓功不可没，那么一个好的推荐算法必然会创造更大的价值，刚好最近听了一个关于推荐算法的讲座，写出来一些思考吧，算是分享一下。","text":"推荐系统一直以来都是电商网站必不可少的一项，在提升用户转化，增加GMV方面可谓功不可没，那么一个好的推荐算法必然会创造更大的价值，刚好最近听了一个关于推荐算法的讲座，写出来一些思考吧，算是分享一下。 学术界的推荐系统其实在大学期间也看过一些推荐的算法，还帮别人实现过关于推荐系统的毕设，但终究都是停留在协同过滤的层面，顶多是加了一些热门推荐来防止冷启动。不得不说，协同过滤打开了我对推荐系统认知的大门，当然在真实环境中这是远远不够的。 传统的推荐系统无非就是评分和排序两种方案，评分即计算出用户对item的可能评分，根据评分的高低进行排序，排序则不关心具体的评分是多少，只是为了得到一个顺序（其实这一点和推荐系统即为相似）。传统的推荐算法典型的有协同过滤和基于内容的过滤。如果你不明白什么是协同过滤算法可以参考：https://blog.csdn.net/gamer_gyt/article/details/51346159 ,如果你不知道协同过滤与基于内容的过滤的区别可参考：https://www.zhihu.com/question/19971859。 大学数学术界关于推荐算法的论文都是对协同过滤的改进，而最终得到一个相对于原先的算法有很大的提升的结果，但是这些都过于理想化了，真实的环境远比实验要复杂的多，网上最有名的推荐系统数据集莫过于那个电影评分数据了，里边只有用户对电影的评分，和电影的一些信息数据。建立在这些数据上的推荐算法其实有点理想化了，他并不能模拟出真实的电商环境，数据的缺乏也是导致协同过滤算法大行其道的原因。 工业界的推荐系统工业界的推荐系统，需要的是明确的价值走向，比如说电商网站的推荐系统是为了增加交易总额，那么在进行推荐的时候是不是应该适当过滤一些极其廉价的商品，是否应该根据用户对不同价格段的需求进行不同价格段商品的推送；如果电商的推荐系统是为了增加用户停留时间，提交CTR，那么推荐系统就不应该考虑过多别的因素，只找到用户最感兴趣的商品或者评论等，当然如何找到用户最感兴趣的也是一个问题，但是有一点不可否认的是这些如果用传统的协同过滤来做是很难满足需求的。这时候就需要开发出新的推荐架构，来适应不同的需求。 目前工业界用的最多的算法莫过于GBDT，LR，DNN等，但所有的推荐算法都会面临一个海量数据的情况，这个时候的做法便是对数据集进行数据召回，得到用户比较感兴趣的一些数据，然后再根据我们的推荐模型进行素材偏好度排序，过滤掉用户已经购买过的类别数据，继而推送给用户。 那么如何进行数据召回呢？这就需要一些基础的模型进行数据准备，比如说用户肖像，用户的价格段偏好，用户购买力水平等。根绝已有的用户数据和特征进行数据召回，适度拉取一些新的数据，保证召回结果的多样性，得到召回池数据之后，便是对模型的训练，其实模型本身难度不大，难度大的是如何选取有效的特征来作为模型的输入数据。你组合得到的有效特征越多，对于模型的训练结果就越准确。 推荐系统的多样性如何保证推荐结果的多样性呢，首先我们要先认识到推荐的可能性，比如说电商网页首页的推荐，商品详细页面的推荐，不同年龄下的推荐，推荐的结果和被评估的指标都是不一样的。这个时候不能单一对所有情况下使用同一种算法或者特征，而是要找到能够区分出不同位置，不同年龄的推荐结果的特征，进行模型训练。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"http://thinkgamer.cn/tags/推荐算法/"}]},{"title":"Scala解析XML","slug":"Spark/Scala解析XML","date":"2018-02-04T08:32:45.000Z","updated":"2019-10-14T06:42:35.674Z","comments":true,"path":"2018/02/04/Spark/Scala解析XML/","link":"","permalink":"http://thinkgamer.cn/2018/02/04/Spark/Scala解析XML/","excerpt":"在使用Spark时，有时候主函数入口参数过多的时候，会特别复杂，这个时候我们可以将相应的参数写在xml文件中，然后只要将xml文件的路径传进去即可，这里的xml路径可以是本地的，也可以是hdfs上的。","text":"在使用Spark时，有时候主函数入口参数过多的时候，会特别复杂，这个时候我们可以将相应的参数写在xml文件中，然后只要将xml文件的路径传进去即可，这里的xml路径可以是本地的，也可以是hdfs上的。 scala提供了类似于Xpath的语法来解析xml文件，其中很重要的两个操作符是”\\”和 “\\\\” \\ ：根据搜索条件得到下一个节点 \\\\：根据条件获取所有的节点 12345678910&lt;configure&gt; &lt;input&gt; &lt;name&gt;app_feature_goods&lt;/name&gt; &lt;hdfs&gt;/user/path/to/goods&lt;/hdfs&gt; &lt;/input&gt; &lt;input&gt; &lt;name&gt;app_feature_user&lt;/name&gt; &lt;hdfs&gt;/user/path/to/user&lt;/hdfs&gt; &lt;/input&gt;&lt;/configure&gt; 123456789101112131415161718192021222324252627282930val input = args(0)val xml = XML.load(input)// 找到所有的一级节点 inputval input_list = xml\\\"input\"input_list.foreach(println)// 遍历每个一级节点，得到具体的值for(one &lt;- input_list)&#123; println(one\\\"name\") println((one\\\"name\").text) println(one\\\"hdfs\") println((one\\\"hdfs\").text)&#125;// 得到所有的nameval name_list = xml\\\\\"name\"name_list.map(one =&gt; one.text).foreach(println)// 获取所有hdfsval hdfs_list = xml\\\\\"hdfs\"hdfs_list.map(one =&gt; one.text).foreach(println)// 获取具有class的值println(xml\\\"input\"\\\"name\"\\\\\"@class\")// 打印出具有class属性的name值和hdfs值println((xml\\\\\"name\").filter(_.attribute(\"class\").exists(_.text.equals(\"test\"))).text)println((xml\\\\\"hdfs\").filter(_.attribute(\"class\").exists(_.text.equals(\"test\"))).text) 打印出的信息为：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;input&gt; &lt;name&gt;app_feature_goods&lt;/name&gt; &lt;hdfs&gt;/user/path/to/goods&lt;/hdfs&gt; &lt;/input&gt;&lt;input&gt; &lt;name&gt;app_feature_user&lt;/name&gt; &lt;hdfs&gt;/user/path/to/user&lt;/hdfs&gt; &lt;/input&gt;&lt;input&gt; &lt;name class=\"test\"&gt;app_feature_user_test&lt;/name&gt; &lt;hdfs class=\"test\"&gt;/user/path/to/user_test&lt;/hdfs&gt; &lt;/input&gt;-------------&lt;name&gt;app_feature_goods&lt;/name&gt;app_feature_goods&lt;hdfs&gt;/user/path/to/goods&lt;/hdfs&gt;/user/path/to/goods&lt;name&gt;app_feature_user&lt;/name&gt;app_feature_user&lt;hdfs&gt;/user/path/to/user&lt;/hdfs&gt;/user/path/to/user&lt;name class=\"test\"&gt;app_feature_user_test&lt;/name&gt;app_feature_user_test&lt;hdfs class=\"test\"&gt;/user/path/to/user_test&lt;/hdfs&gt;/user/path/to/user_test-------------app_feature_goodsapp_feature_userapp_feature_user_test-------------/user/path/to/goods/user/path/to/user/user/path/to/user_test-------------test-------------app_feature_user_test/user/path/to/user_test-------------Process finished with exit code 0 当然还存在一种情况就是XML文件存在于hdfs之上，这时候就不能直接load xml文件里，不过可以通过下面一种方法获得12var rdd = sc.textFile(xml_path)val xml = XML.loadString(rdd.collect().mkString(\"\\n\")) 接下来便可以通过上边的方法进行解析了。 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"}]},{"title":"Spark求统计量的两种方法","slug":"Spark/Spark求统计量的两种方法","date":"2018-02-04T07:04:27.000Z","updated":"2019-10-14T06:42:35.675Z","comments":true,"path":"2018/02/04/Spark/Spark求统计量的两种方法/","link":"","permalink":"http://thinkgamer.cn/2018/02/04/Spark/Spark求统计量的两种方法/","excerpt":"Spark对于统计量中的最大值，最小值，平均值和方差（均值）的计算都提供了封装，这里小编知道两种计算方法，整理一下分享给大家","text":"Spark对于统计量中的最大值，最小值，平均值和方差（均值）的计算都提供了封装，这里小编知道两种计算方法，整理一下分享给大家 DataFrame形式加载Json数据源example.json文件格式如下123&#123;\"name\":\"thinkgamer\",\"age\":23,\"math\":78,\"chinese\":78,\"english\":95&#125;&#123;\"name\":\"think\",\"age\":25,\"math\":95,\"chinese\":88,\"english\":93&#125;&#123;\"name\":\"gamer\",\"age\":24,\"math\":93,\"chinese\":68,\"english\":88&#125; 1234// persist(StorageLevel.MEMORY_AND_DISK) 当内存不够时cache到磁盘里val df = spark.read.json(\"/path/to/example.json\").persist(StorageLevel.MEMORY_AND_DISK)df.show()df.describe() 我们便可以看到如下的形式1234567891011121314151617+---+-------+-------+----+----------+|age|chinese|english|math| name|+---+-------+-------+----+----------+| 23| 78| 95| 78|thinkgamer|| 25| 88| 93| 95| think|| 24| 68| 88| 93| gamer|+---+-------+-------+----+----------++-------+----+-------+-----------------+-----------------+----------+|summary| age|chinese| english| math| name|+-------+----+-------+-----------------+-----------------+----------+| count| 3| 3| 3| 3| 3|| mean|24.0| 78.0| 92.0|88.66666666666667| null|| stddev| 1.0| 10.0|3.605551275463989| 9.29157324317757| null|| min| 23| 68| 88| 78| gamer|| max| 25| 88| 95| 95|thinkgamer|+-------+----+-------+-----------------+-----------------+----------+ 如果是想看某列的通知值的话，可以用下面的方式1df.select(\"age\").describe().show() 123456789+-------+----+|summary| age|+-------+----+| count| 3|| mean|24.0|| stddev| 1.0|| min| 23|| max| 25|+-------+----+ RDD形式假设同样还是上边的数据，只不过现在变成按\\t分割的普通文本123thinkgamer 23 78 78 95think 25 95 88 93gamer 24 93 68 88 这里可以将rdd转换成dataframe洗形式，也可以使用rdd计算，转化为df的样例如下1234val new_data = data_txt .map(_.split(\"\\\\s+\")) .map(one =&gt; Person(one(0),one(1).toInt,one(2).toDouble,one(3).toDouble,one(4).toDouble)) .toDF() 接下来就是进行和上边df一样的操作了。 那么对于rdd形式的文件如何操作：12345678910111213141516import org.apache.spark.mllib.linalg.Vectorsimport org.apache.spark.mllib.stat.&#123;MultivariateStatisticalSummary, Statistics&#125;val data_txt = SparkSC.spark.sparkContext.textFile(input_txt).persist(StorageLevel.MEMORY_AND_DISK) val new_data = data_txt .map(_.split(\"\\\\s+\")) .map(one =&gt; Vectors.dense(one(1).toInt,one(2).toDouble,one(3).toDouble,one(4).toDouble)) val summary: MultivariateStatisticalSummary = Statistics.colStats(new_data) println(\"Max:\"+summary.max)println(\"Min:\"+summary.min)println(\"Count:\"+summary.count)println(\"Variance:\"+summary.variance)println(\"Mean:\"+summary.mean)println(\"NormL1:\"+summary.normL1)println(\"Norml2:\"+summary.normL2) 输出结果为：1234567Max:[25.0,95.0,88.0,95.0]Min:[23.0,78.0,68.0,88.0]Count:3Variance:[1.0,86.33333333333331,100.0,13.0]Mean:[24.0,88.66666666666667,78.0,92.0]NormL1:[72.0,266.0,234.0,276.0]Norml2:[41.593268686170845,154.1363033162532,135.83813897429545,159.43023552638942] 这里可以得到相关的统计信息，主要区别在于dataframe得到的是标准差，而使用mllib得到的统计值中是方差，但这并不矛盾，两者可以相互转化得到。 当然如果要求四分位数，可以转化成df，使用sql语句进行查询1Select PERCENTILE(col,&lt;0.25,0.75&gt;) from tableName; 自己实现下面是我自己实现的一个方法，传入的参数是一个rdd，返回的是一个字符串1234567891011121314151617181920212223242526272829// 计算最大值，最小值，平均值，方差，标准差，四分位数def getStat(data: RDD[String]):String= &#123; val sort_data = data .filter(one =&gt; Verify.istoDouble(one)) .map(_.toDouble) .sortBy(line=&gt;line) .persist(StorageLevel.MEMORY_AND_DISK) // 默认是true 升序，false为降序 val data_list = sort_data.collect() val len = data_list.length val min = data_list(0) val max = data_list(len-1) val mean = sort_data.reduce((a,b) =&gt; a+b) / len val variance = sort_data.map(one =&gt; math.pow(one-mean,2)).reduce((a,b)=&gt;a+b)/len val stdder = math.sqrt(variance) var quant = \"\" if(len&lt;4)&#123; val q1 = min val q2 = min val q3 = max quant = q1+\"\\t\"+q2+\"\\t\"+q3 &#125;else &#123; val q1 = data_list((len * 0.25).toInt - 1) val q2 = data_list((len * 0.5).toInt - 1) val q3 = data_list((len * 0.75).toInt - 1) quant = q1+\"\\t\"+q2+\"\\t\"+q3 &#125; max+\"\\t\"+min+\"\\t\"+mean+\"\\t\"+variance+\"\\t\"+stdder+\"\\t\"+quant&#125; 本地碰见的一个错误1：错误11scala.Predef$.refArrayOps([Ljava/lang/Object;)Lscala/collection/mutable/Array 原因是Spark中spark-sql_2.11-2.2.1 ，是用scala 2.11版本上编译的，而我的本地的scala版本为2.12.4，所以就错了，可以在里边把相应的scala版本就行修改就行了 2：错误21java.lang.NoSuchMethodError: scala.Product.$init$(Lscala/Product;)V 原因也是因为我下载安装的scala2.12版本，换成scala2.11版本就可以了 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"}]},{"title":"记一次百G数据的聚类算法实施过程","slug":"Spark/记一次百G数据的聚类算法实施过程","date":"2018-01-26T16:08:24.000Z","updated":"2019-10-14T06:42:35.676Z","comments":true,"path":"2018/01/27/Spark/记一次百G数据的聚类算法实施过程/","link":"","permalink":"http://thinkgamer.cn/2018/01/27/Spark/记一次百G数据的聚类算法实施过程/","excerpt":"如题，记一次百G数据的聚类算法实施过程，用的技术都不难，spark和kmeans，我想你会认为这没有什么难度，我接到这个任务的时候也认为没有难度，可是一周之后我发现我错了，数据量100G的确不大，但难度在于我需要对 kmeans 的 train过程执行将近3000次，而且需要高效的完成。那么问题就来了，如何保证高效和准确性。（声明小编对Spark也不是说很熟悉）","text":"如题，记一次百G数据的聚类算法实施过程，用的技术都不难，spark和kmeans，我想你会认为这没有什么难度，我接到这个任务的时候也认为没有难度，可是一周之后我发现我错了，数据量100G的确不大，但难度在于我需要对 kmeans 的 train过程执行将近3000次，而且需要高效的完成。那么问题就来了，如何保证高效和准确性。（声明小编对Spark也不是说很熟悉） 需求数据格式为三列，第一列为类别ID，第二列为商品ID，第三列为价格，数据格式如下12345671000 2000 45.31000 2001 121.31001 2002 4125.31000 2003 225.31001 2004 3415.31000 2005 12245.3 ... ... .... 数据有很多条，数据量为将近100G，存储在hdfs上，第一列品类ID不唯一，每个品类ID下有多个商品ID，商品ID唯一，价格为浮点型数据 现在要对每个品类下的价格进行聚类，得到1~7个价格level（7level的价格要比6level的价格高，以此类推） 第一次尝试第一次尝试很天真，思路也很正常，如下：1：全量加载数据，形成rdd2：数据split之后，按key进行groupby3：针对每个key（也就是类别ID）进行kmeans聚类和预测，并将结果写入hdfs4：加载每个类别的结果，进行聚合形成最终结果 那么开始写代码。papapa写了一堆，发现groupBy之后的数据格式是CompactBuffer，转化成spark kmeans train所需要的格式之后，代码卡着不会动，不明所以（我估计是格式没有转正确，不是kmeans 所需要的格式，但是如果不是kmeans 需要的格式，应该会报错呀），后来当我把代码打包，提交到集群上运行时，提示我kmeans train所在的函数中没有指定master url，可是我明明指定了，后来才发现是因为，我在rdd操作过程中能够，嵌套了函数，函数中又重新使用了rdd，也就是说rdd 不能嵌套rdd使用，具体可参考 Spark 为什么 不允许 RDD 嵌套-如 RDD[RDD[T]]，而我在本地测试时指的都是local，没有进行报错，至此这条路行不通，也就是说不能按这样的思路执行 在该思路的基础上进行改进：既然rdd不能嵌套rdd使用，何不先得到所有的类别id，然后在全量数据总filter单个类别id进行kmeans操作呢？ 该代码，测试，伪代码如下：12leibieID_list = XXXXXleibieID_list.map(one =&gt; kmeans(one,path)) 需要注意的是 leibieID_list.map 操作并不是分布式的，而是for 循环，这样3000个类别id运行完，时间可想而知，是极其耗时的，所以这条路也失败了（不是说行不通，是因为耗时） 第二次尝试经过上边的尝试发现不行，那么我想是不是先全量读取数据，然后按照类别ID，将同一个类别ID的数据写到一个文件（或者文件夹下），然后再对之操作 开始写classify by ID 的代码，这里遇到了问题是如何让同一个类别ID的数据写到一个文件中，上网查了一些资料，可以参考之前整理的笔记 Spark多路径输出和二次排序 这里边有实现的办法，但是还有一个问题，对全量数据（100G）进行shuffle的时候，由于数据量特别大，也特别占用资源，往往会出现一些内存上的错误。 这里采用的策略是将全量数据rdd进行random split，然后for循环遍历split之后的rdd，进行saveAsTestFile，保存的目录这样设计12345/path/split=0//path/split=1//path/split=2//path/split=3/ ... ... 这样的话，就可以避免大量数据 shuffle 耗费资源的问题了，而且也不影响后续数据的使用，同时这一步也会把类别id提取出来，保存在hdfs上，供下一步使用。 经历了上一步的数据准备，开始step 2的开发，第二步的思路：加载第一步保存的类别id list文件，分成5份，启动5个spark任务进行train，至此，思路是正确的，但却忽略了一个很严正的问题：数据倾斜 由于是随机对类别 id 进行分组操作，那么不能保证没组中每个类别id对应的数据条数的大概一致性，也就是存在某个ID 数据条数只有几十条，而有些ID 数据条数千万条，这种情况下就会导致代码在运行过程中，有些task很快运行完了，有些执行了好久也没完事。 第三次尝试有了第二次的经验，想法就是如何将数据条数差不多的分到同一组里，我采用的方法是进行统计，按照10的X次方形式进行分组，比如说12341~10 110~100 2100~1000 3.... 但是这样也有一个问题，就是这样大概符合正太分布，4、5、6这样的组里数据条数比较多，1、2、3和7、8、9这样的数据条数少，这样就会因为4、5、6组的程序运行时间较长，整体任务运行时间也较长。 所以这里采用合并和拆分的策略，比如说将1,2,3合并到一组，4、5、6分别拆成两组，7、8、9合成一组，这样就会保证每组运行的时间是差不多的。（实际情况中，要根据数据的分布进行合理的拆分和合并） 总结至此，问题算是最终解决了，相比原先的MR版本，时间缩减了将近8个小时，在整个优化的过程中，其实对于经验足够的开发者来说，可能很快就会解决，但对于我们这些新手，可能就要耗费些时间，涨涨记性了，在整个过程中对spark也算是有进一步的了解了。 其他的相关笔记： http://blog.csdn.net/gamer_gyt/article/details/79157055 http://blog.csdn.net/gamer_gyt/article/details/79135118 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"}]},{"title":"Spark多路径输出和二次排序","slug":"Spark/Spark多路径输出和二次排序","date":"2018-01-24T16:22:03.000Z","updated":"2019-10-14T06:42:35.675Z","comments":true,"path":"2018/01/25/Spark/Spark多路径输出和二次排序/","link":"","permalink":"http://thinkgamer.cn/2018/01/25/Spark/Spark多路径输出和二次排序/","excerpt":"在实际应用场景中，我们对于Spark往往有各式各样的需求，比如说想MR中的二次排序，Top N，多路劲输出等。那么这篇文章我们就来看下这几个问题。","text":"在实际应用场景中，我们对于Spark往往有各式各样的需求，比如说想MR中的二次排序，Top N，多路劲输出等。那么这篇文章我们就来看下这几个问题。 二次排序假设我们的数据是这样的：123456781 21 31 11 61 42 52 82 3 我们想要实现第一列按降序排列，当第一列相同时，第二列按降序排列 定义一个SecondSortKey类：12345678910class SecondSortKey(val first: Int, val second: Int) extends Ordered[SecondSortKey] with Serializable &#123; override def compare(that: SecondSortKey): Int = &#123; if (this.first - that.first == 0) &#123; this.second - that.second &#125; else &#123; this.first - that.first &#125; &#125;&#125; 然后这样去使用1234567val lines = sc.textFile(\"test.txt\")val pairs = lines.map &#123; x =&gt; (new SecondSortKey(x.split(\"\\\\s+\")(0).toInt, x.split(\"\\\\s+\")(1).toInt), x) &#125;val sortedPairs = pairs.sortByKey(false);sortedPairs.map(_._2).foreach(println) 当然这里如果想按第一列升序，当第一列相同时，第二列升序的顺序排列，只需要对SecondSoryKey做如下修改即可12345678910class SecondSortKey(val first: Int, val second: Int) extends Ordered[SecondSortKey] with Serializable &#123; override def compare(that: SecondSortKey): Int = &#123; if (this.first - that.first !== 0) &#123; this.second - that.second &#125; else &#123; this.first - that.first &#125; &#125;&#125; 当时使用的使用去掉1pairs.sortByKey(false) 中的false Top N同样还是上边的数据，假设我们要得到第一列中的前五位123456val lines = sc.textFile(\"test.txt\")val rdd = lines .map(x =&gt; x.split(\"\\\\s+\")) .map(x =&gt; (x(0),x(1))) .sortByKey()rdd.take(N).foreach(println) 多路径输出自己在使用的过程中，通过搜索发现了两种方法1：调用saveAsHadoopFile函数并自定义一个OutputFormat类 自定义RDDMultipleTextOutputFormat类 RDDMultipleTextOutputFormat类中的generateFileNameForKeyValue函数有三个参数，key和value就是我们RDD的Key和Value，而name参数是每个Reduce的编号。本例中没有使用该参数，而是直接将同一个Key的数据输出到同一个文件中。123456import org.apache.hadoop.mapred.lib.MultipleTextOutputFormat class RDDMultipleTextOutputFormat extends MultipleTextOutputFormat[Any, Any] &#123; override def generateFileNameForKeyValue(key: Any, value: Any, name: String): String = key.asInstanceOf[String] &#125; 调用1234sc.parallelize(List((\"w\", \"www\"), (\"b\", \"blog\"), (\"c\", \"com\"), (\"w\", \"bt\"))) .map(value =&gt; (value._1, value._2 + \"Test\")) .partitionBy(new HashPartitioner(3)) .saveAsHadoopFile(\"/iteblog\", classOf[String],classOf[String],classOf[RDDMultipleTextOutputFormat]) 这里的1new HashPartitioner(3) 中的3是有key的种类决定的，当然在实际应用场景中，我们可能并不知道有多少k，这个时候就可以通过一个rdd 的 distinct操作来得到唯一key的数目。 2：使用dataframe123people_rdd = sc.parallelize([(1, \"alice\"), (1, \"bob\"), (2,\"charlie\")])people_df = people_rdd.toDF([\"number\", \"name\"])people_df.write.partitionBy(\"number\").format(\"text\").save(path ) 当然这两种方法都有一个缺陷，就是当数据量特别大的时候，数据在repartition的过程中特别耗费资源，也会容易出现任务failed的情况，小编采用的解决办法是，适当的对原rdd进行split，然后遍历每个rdd，进行multioutput操作 形似如下：123456val rdd = sc.textFile(input)var split_rdd = rdd.randomSplit(Array(1.0,1.0,1.0,1.0))for (one &lt;- Array(1,2,3,4))&#123; split_rdd(one)XXXX&#125; 参考： Spark学习笔记——二次排序，TopN，TopNByGroup Spark多文件输出(MultipleOutputFormat) scala - Write to multiple outputs by key Spark - one Spark job Write to multiple outputs by key Spark - one Spark job 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"}]},{"title":"Spark提交参数说明和常见优化","slug":"Spark/Spark提交参数说明和常见优化","date":"2018-01-22T16:30:15.000Z","updated":"2019-10-14T06:42:35.675Z","comments":true,"path":"2018/01/23/Spark/Spark提交参数说明和常见优化/","link":"","permalink":"http://thinkgamer.cn/2018/01/23/Spark/Spark提交参数说明和常见优化/","excerpt":"最近在搞一个价格分类模型，虽说是分类，用的是kmeans算法，求出聚类中心，对每个价格进行级别定级。虽然说起来简单，但做起来却是并没有那么容易，不只是因为数据量大，在执行任务时要不是效率问题就是shuffle报错等。但在这整个过程中对scala编程,Spark rdd 机制，以及海量数据背景下对算法的认知都有很大的提升，这一篇文章主要是总结一些Spark在shell 终端提交jar包任务的时候的相关知识，在后续文章会具体涉及到相关的”实战经历“。","text":"最近在搞一个价格分类模型，虽说是分类，用的是kmeans算法，求出聚类中心，对每个价格进行级别定级。虽然说起来简单，但做起来却是并没有那么容易，不只是因为数据量大，在执行任务时要不是效率问题就是shuffle报错等。但在这整个过程中对scala编程,Spark rdd 机制，以及海量数据背景下对算法的认知都有很大的提升，这一篇文章主要是总结一些Spark在shell 终端提交jar包任务的时候的相关知识，在后续文章会具体涉及到相关的”实战经历“。 对Spark的认识由于之前接触过Hadoop，对Spark也是了解一些皮毛，但中间隔了好久才重新使用spark，期间也产生过一些错误的认识。 之前觉得MapReduce耗费时间，写一个同等效果的Spark程序很快就能执行完，很长一段时间自己都是在本地的单机环境进行测试学习，所以这种错误的认知就会更加深刻，但事实却并非如此，MR之所以慢是因为每一次操作数据都写在了磁盘上，大量的IO造成了时间和资源的浪费，但是Spark是基于内存的计算引擎，相比MR，减少的是大量的IO，但并不是说给一个Spark程序足够的资源，就可以为所欲为了，在提交一个spark程序时，不仅要考虑所在资源队列的总体情况，还要考虑代码本身的高效性，要尽量避免大量的shuffle操作和action操作，尽量使用同一个rdd。 会用spark，会调api和能用好spark是两回事，在进行开发的过程中，不仅要了解运行原理，还要了解业务，将合适的方法和业务场景合适的结合在一起，才能发挥最大的价值。 spark-submit进入spark的home目录，执行以下命令查看帮助1bin/spark-submit --help spark提交任务常见的两种模式1：local/local[K] 本地使用一个worker线程运行spark程序 本地使用K个worker线程运行spark程序 此种模式下适合小批量数据在本地调试代码 2：yarn-client/yarn-cluster yarn-client：以client方式连接到YARN集群，集群的定位由环境变量HADOOP_CONF_DIR定义，该方式driver在client运行。 yarn-cluster：以cluster方式连接到YARN集群，集群的定位由环境变量HADOOP_CONF_DIR定义，该方式driver也在集群中运行。 注意：若使用的是本地文件需要在file路径前加：file:// 在提交任务时的几个重要参数 executor-cores —— 每个executor使用的内核数，默认为1 num-executors —— 启动executors的数量，默认为2 executor-memory —— executor内存大小，默认1G driver-cores —— driver使用内核数，默认为1 driver-memory —— driver内存大小，默认512M 下边给一个提交任务的样式12345678910111213spark-submit \\ --master local[5] \\ --driver-cores 2 \\ --driver-memory 8g \\ --executor-cores 4 \\ --num-executors 10 \\ --executor-memory 8g \\ --class PackageName.ClassName XXXX.jar \\ --name \"Spark Job Name\" \\ InputPath \\ OutputPath 如果这里通过--queue 指定了队列，那么可以免去写--master 以上就是通过spark-submit来提交一个任务 几个参数的常规设置 executor_cores*num_executors表示的是能够并行执行Task的数目不宜太小或太大！一般不超过总队列 cores 的 25%，比如队列总 cores 400，最大不要超过100，最小不建议低于 40，除非日志量很小。 executor_cores不宜为1！否则 work 进程中线程数过少，一般 2~4 为宜。 executor_memory一般 6~10g 为宜，最大不超过20G，否则会导致GC代价过高，或资源浪费严重。 driver-memorydriver 不做任何计算和存储，只是下发任务与yarn资源管理器和task交互，除非你是 spark-shell，否则一般 1-2g 增加每个executor的内存量，增加了内存量以后，对性能的提升，有三点： 1、如果需要对RDD进行cache，那么更多的内存，就可以缓存更多的数据，将更少的数据写入磁盘，甚至不写入磁盘。减少了磁盘IO。 2、对于shuffle操作，reduce端，会需要内存来存放拉取的数据并进行聚合。如果内存不够，也会写入磁盘。如果给executor分配更多内存以后，就有更少的数据，需要写入磁盘，甚至不需要写入磁盘。减少了磁盘IO，提升了性能。 3、对于task的执行，可能会创建很多对象。如果内存比较小，可能会频繁导致JVM堆内存满了，然后频繁GC，垃圾回收，minor GC和full GC。（速度很慢）。内存加大以后，带来更少的GC，垃圾回收，避免了速度变慢，性能提升。 常规注意事项 预处理数据，丢掉一些不必要的数据 增加Task的数量 过滤掉一些容易导致发生倾斜的key 避免创建重复的RDD 尽可能复用一个RDD 对多次使用的RDD进行持久化 尽量避免使用shuffle算子 在要使用groupByKey算子的时候,尽量用reduceByKey或者aggregateByKey算子替代.因为调用groupByKey时候,按照相同的key进行分组,形成RDD[key,Iterable[value]]的形式,此时所有的键值对都将被重新洗牌,移动,对网络数据传输造成理论上的最大影响. 使用高性能的算子 参考：1：http://www.cnblogs.com/haozhengfei/p/e570f24c43fa15f23ebb97929a1b7fe6.html2：https://www.jianshu.com/p/4c584a3bac7d 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://thinkgamer.cn/tags/Spark/"}]},{"title":"用大把的时间仿徨，却用几个瞬间成长","slug":"随手记/用大把的时间仿徨，却用几个瞬间成长","date":"2017-12-31T03:02:00.000Z","updated":"2019-10-14T06:42:35.693Z","comments":true,"path":"2017/12/31/随手记/用大把的时间仿徨，却用几个瞬间成长/","link":"","permalink":"http://thinkgamer.cn/2017/12/31/随手记/用大把的时间仿徨，却用几个瞬间成长/","excerpt":"人总要在特定的阶段去完成特定的事情，然后转身告诉自己，继续往前。","text":"人总要在特定的阶段去完成特定的事情，然后转身告诉自己，继续往前。 提笔写这篇文章，内心是毫无波澜的，或许是因为曾经的经历让我意识到那一切都是缘的力所能及。以下的内容可能没有章节，没有顺序，但都是心灵能够触及的地方。 2017年对我个人来讲是比较重要的一年，可以说是完成了自我的一个改变吧，但是脱壳之后，需要的是更加努力的完善自我，这样才能够避免被淘汰。为什么这么说？因为这一年我觉得对我个人影响最大的两件事是：买了首套房（虽然只是付了首付）；在年末之时选择离开，侥幸的入职了京东。一个是为“家庭”做了必要的准备，一个是为“事业”做了点缀。而至于其他的大大小小的事情，则是17年的五味杂粮，并不是那么重要，但却也缺一不可。感谢17年，那些我认识的，或者我不认识的，帮助过我的，或者我帮助过的人。 转载请注明出处：https://thinkgamer.blog.csdn.net/article/details/78940968博主微博：http://weibo.com/234654758Github：https://github.com/thinkgamer 过往人上了年纪，总爱回忆！ 刚好这两天，“18岁”刷爆了朋友圈和QQ空间，或许这是连腾讯有没有预料到的起死回生或者苟延残喘吧。趁机翻了下我的QQ空间相册，突然发现了，这二十多年来以来，我也是经历颇丰。 从上海到江苏，从沈阳到长春，从南京到天津，最后到北京，这一条路一走便是4年。从初中到高中，从大学到社会，这一条路一走便是11年。 过往的这条路上遇见了很多人，碰见很多事，但终究还是走散了，看淡了，不过庆幸的是那些一直还有联系的，我们还能彼此叫出姓名的人，不管是18岁之前，还是18岁之后，我想我们是幸运的， 年少的我们曾经难免会埋下羞涩的种子，在记忆深处藏着一些不可告人的秘密，直到有一天我们盘膝而坐，三巡酒过，才道出那些现在我们认为可笑的不能再可笑的羞涩，从此，稚嫩青春里的唯一一朵留恋，也该告一段落。 一杯敬明天，一杯敬过往。灵魂不再无处安放。 遇见人有了目标，便爱胡闹！ 2017年，不管是工作，还是自我学习都收获了挺多知识，感谢万维接受了我这个毫无工作经验的“学生”吧，在这里的确收获了挺多，让我明白没有结合业务的技术，只是向别人吹嘘而毫无创造价值的垃圾，不管你在哪，技术都是为了推动业务的增长。 2017年，还是习惯性的写一些学习笔记，只不过是频率明显了降了下来，这只能归结于自己变得懒惰了，从开通博客到现在，所有的表层的收获只能通过这些浅显的数据来表达： 只是没有17年尾的时候访问量达到100W，不过一切随缘吧。 下边这几张图是最近一个月的访问分析情况，不管怎样，你学习了，也帮助其他人了，这就是成长。 2017年，开通了微信公众号【数据与算法联盟】（原名为码农故事多），没有刻意的运营，没有刻意的传播积累用户，一切随缘。当然如果你想加入我们的数据与算法学习交流群的话，欢迎加我的微信，拉你入群，群里有很多大牛，不定时进行“扯淡”。我们的宗旨就是以技术会友，分享与进步！感谢2017年和以往遇见的所有好友！ 2017年，很侥幸的加入了JD这个大家庭，未来的一切都是未知数，但你能做的就是向他人学习，围绕着工作进行深度的学习和成长。 新生人过了18，要努力发芽！ 过去的一年里定了太多的目标，结果大部分都没有实现，哎，分析一下，大部门的目标都是盲目的，没有围绕工作的目标（学习规划吧算是），其实实现起来是有难度的，所以新的一年里调整计划，重新出发。 2018不会定太多的目标，主要是想在技术和业务层面提升下自己，不管是学习大数据还是算法，都会围绕功能工作和一条主旋律进行展开。 感谢一路以来，遇见的所有人！ 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/tags/随手记/"}]},{"title":"Hexo-Yilia加入相册功能","slug":"随手记/Hexo-Yilia加入相册功能","date":"2017-12-14T09:55:29.000Z","updated":"2019-10-14T06:42:35.691Z","comments":true,"path":"2017/12/14/随手记/Hexo-Yilia加入相册功能/","link":"","permalink":"http://thinkgamer.cn/2017/12/14/随手记/Hexo-Yilia加入相册功能/","excerpt":"参考：点击查看","text":"参考：点击查看 但是其中有一些小问题，自己便重新整理了一下（本文适用于使用github存放照片） 主页新建相册链接主题_config.json文件的menu 中加入 相册和对应的链接123456themes/yilia/_config.jsonmenu: 主页: / ... ... 相册: /photos 新建目录并拷贝相应文件使用的是litten 大神的博客 photos文件夹，对应的路径为：https://github.com/litten/BlogBackup/tree/master/source/photos 自己的项目根目录下的source文件夹下新建photos文件夹，将下载的几个文件放在该文件夹中，或者不用新建，直接将下载的photos文件夹放在source目录下。 文件修改 修改 ins.js 文件的 render()函数这个函数是用来渲染数据的修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(github的路径)例如我的为：12var minSrc = 'https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/min_photos/' + data.link[i] + '.min.jpg';var src = 'https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/photos/' + data.link[i]; 生成json1：下载相应python工具文件 tools.py ImageProcess.py 下载地址：https://github.com/Thinkgamer/GitBlog 2：新建photos和min_photos文件夹在项目根目录下创建，用来存放照片和压缩后的照片12mkdir photosmkdir min_photos 3：py文件和文件夹都放在项目根目录下 4：生成json执行1python tools.py 如果提示：1234Traceback (most recent call last): File \"tools.py\", line 13, in &lt;module&gt; from PIL import ImageImportError: No module named PIL 说明你没有安装pillow，执行以下命令安装即可1pip install pillow 如果报错：1ValueError: time data 'DSC' does not match format '%Y-%m-%d' 说明你照片的命名方式不合格，这里必须命名为以下这样的格式（当然时间是随意的）12016-10-12_xxx.jpg/png ok，至此会在min_photos文件夹下生成同名的文件，但是大小会小很多 本地预览和部署本地预览项目根目录下执行1hexo s 浏览器4000端口访问，按照上边的方式进行配置，正常情况下你是看不到图片的，通过调试可以发现图片的url中后缀变成了 xxx.jpg.jpg，所以我们要去掉一个jpg 改正方法ins.js/render 函数12345678var minSrc = 'https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/min_photos/' + data.link[i] + '.min.jpg';换成var minSrc = 'https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/min_photos/' + data.link[i];注释掉该行：src += '.jpg'; 到这里没完，路径都对了，但是在浏览器中还是不能看到图片，调试发现，下载大神的photos文件夹的ins.js中有一行代码，饮用了一张图片，默认情况下，在你的项目中，这张图片是不存在的，改正办法就是在对应目录下放一张图片，并修改相应的名字 1src=\"/assets/img/empty.png ok，至此刷新浏览器是可以看到图片的，如果还看不到，应该就是浏览器缓存问题了，如果还有问题，可以加我微信进行沟通：gyt13342445911 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://thinkgamer.cn/tags/hexo/"}]},{"title":"梯度算法之批量梯度下降，随机梯度下降和小批量梯度下降","slug":"机器学习/梯度算法之批量梯度下降，随机梯度下降和小批量梯度下降","date":"2017-12-14T06:40:43.000Z","updated":"2019-10-14T06:42:35.687Z","comments":true,"path":"2017/12/14/机器学习/梯度算法之批量梯度下降，随机梯度下降和小批量梯度下降/","link":"","permalink":"http://thinkgamer.cn/2017/12/14/机器学习/梯度算法之批量梯度下降，随机梯度下降和小批量梯度下降/","excerpt":"在机器学习领域，体梯度下降算法分为三种 批量梯度下降算法（BGD，Batch gradient descent algorithm） 随机梯度下降算法（SGD，Stochastic gradient descent algorithm） 小批量梯度下降算法（MBGD，Mini-batch gradient descent algorithm）","text":"在机器学习领域，体梯度下降算法分为三种 批量梯度下降算法（BGD，Batch gradient descent algorithm） 随机梯度下降算法（SGD，Stochastic gradient descent algorithm） 小批量梯度下降算法（MBGD，Mini-batch gradient descent algorithm） 批量梯度下降算法BGD是最原始的梯度下降算法，每一次迭代使用全部的样本，即权重的迭代公式中(公式中用$\\theta$代替$\\theta_i$)， \\jmath (\\theta _0,\\theta _1,...,\\theta _n)=\\sum_{i=0}^{m}( h_\\theta(x_0,x_1,...,x_n)-y_i )^2 \\theta _i = \\theta _i - \\alpha \\frac{\\partial \\jmath (\\theta _1,\\theta _2,...,\\theta _n)}{\\partial \\theta _i} 公式(1)这里的m代表所有的样本，表示从第一个样本遍历到最后一个样本。 特点： 能达到全局最优解，易于并行实现 当样本数目很多时，训练过程缓慢 随机梯度下降算法SGD的思想是更新每一个参数时都使用一个样本来进行更新，即公式（1）中m为1。每次更新参数都只使用一个样本，进行多次更新。这样在样本量很大的情况下，可能只用到其中的一部分样本就能得到最优解了。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。 特点： 训练速度快 准确度下降，并不是最优解，不易于并行实现 小批量梯度下降算法MBGD的算法思想就是在更新每一参数时都使用一部分样本来进行更新，也就是公式（1）中的m的值大于1小于所有样本的数量。 相对于随机梯度下降，Mini-batch梯度下降降低了收敛波动性，即降低了参数更新的方差，使得更新更加稳定。相对于批量梯度下降，其提高了每次学习的速度。并且其不用担心内存瓶颈从而可以利用矩阵运算进行高效计算。一般而言每次更新随机选择[50,256]个样本进行学习，但是也要根据具体问题而选择，实践中可以进行多次试验，选择一个更新速度与更次次数都较适合的样本数。mini-batch梯度下降可以保证收敛性，常用于神经网络中。 补充在样本量较小的情况下，可以使用批量梯度下降算法，样本量较大的情况或者线上，可以使用随机梯度下降算法或者小批量梯度下降算法。 在机器学习中的无约束优化算法，除了梯度下降以外，还有前面提到的最小二乘法，此外还有牛顿法和拟牛顿法。 梯度下降法和最小二乘法相比，梯度下降法需要选择步长，而最小二乘法不需要。梯度下降法是迭代求解，最小二乘法是计算解析解。如果样本量不算很大，且存在解析解，最小二乘法比起梯度下降法要有优势，计算速度很快。但是如果样本量很大，用最小二乘法由于需要求一个超级大的逆矩阵，这时就很难或者很慢才能求解解析解了，使用迭代的梯度下降法比较有优势。 梯度下降法和牛顿法/拟牛顿法相比，两者都是迭代求解，不过梯度下降法是梯度求解，而牛顿法/拟牛顿法是用二阶的海森矩阵的逆矩阵或伪逆矩阵求解。相对而言，使用牛顿法/拟牛顿法收敛更快。但是每次迭代的时间比梯度下降法长。 sklearn中的SGDsklearn官网上查了一下，并没有找到BGD和MBGD的相关文档，只是看到可SGD的，感兴趣的可以直接去官网看英文文档，点击SGD查看：SGD，这也有一个中文的 SGD 123456789101112131415161718192021222324In [1]: from sklearn.linear_model import SGDClassifierIn [2]: X = [[0., 0.], [1., 1.]]In [3]: y = [0, 1]In [4]: clf = SGDClassifier(loss=\"hinge\", penalty=\"l2\")In [5]: clf.fit(X, y)Out[5]: SGDClassifier(alpha=0.0001, average=False, class_weight=None, epsilon=0.1, eta0=0.0, fit_intercept=True, l1_ratio=0.15, learning_rate='optimal', loss='hinge', n_iter=5, n_jobs=1, penalty='l2', power_t=0.5, random_state=None, shuffle=True, verbose=0, warm_start=False)In [6]: clf.predict([[2., 2.]])Out[6]: array([1])In [7]: clf.coef_ Out[7]: array([[ 9.91080278, 9.91080278]])In [8]: clf.intercept_ Out[8]: array([-9.97004991]) 参考： https://www.cnblogs.com/pinard/p/5970503.html http://blog.csdn.net/uestc_c2_403/article/details/74910107 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"梯度","slug":"梯度","permalink":"http://thinkgamer.cn/tags/梯度/"}]},{"title":"梯度算法之梯度上升和梯度下降","slug":"机器学习/梯度算法之梯度上升和梯度下降","date":"2017-12-14T06:11:11.000Z","updated":"2019-10-14T06:42:35.687Z","comments":true,"path":"2017/12/14/机器学习/梯度算法之梯度上升和梯度下降/","link":"","permalink":"http://thinkgamer.cn/2017/12/14/机器学习/梯度算法之梯度上升和梯度下降/","excerpt":"第一次看见随机梯度上升算法是看《机器学习实战》这本书，当时也是一知半解，只是大概知道和高等数学中的函数求导有一定的关系。下边我们就好好研究下随机梯度上升（下降）和梯度上升（下降）。","text":"第一次看见随机梯度上升算法是看《机器学习实战》这本书，当时也是一知半解，只是大概知道和高等数学中的函数求导有一定的关系。下边我们就好好研究下随机梯度上升（下降）和梯度上升（下降）。 高数中的导数设导数 y = f(x) 在 $ x_0 $的某个邻域内有定义，当自变量从 $ x_0 $ 变成 x_{0} + \\Delta x函数y=f(x)的增量 \\Delta y = f(x_0 + \\Delta x) - f(x_0)与自变量的增量 $ \\Delta x $ 之比： \\frac{ \\Delta y }{ \\Delta x } = \\frac{ f(x_0 + \\Delta x)-f(x_0) }{ \\Delta x }称为f(x)的平均变化率。如 $ \\Delta x \\rightarrow 0 $ 平均变化率的极限 \\lim_{\\Delta x \\rightarrow 0} \\frac{ \\Delta y }{ \\Delta x } = \\lim_{\\Delta x \\rightarrow 0} \\frac{ f(x_0 + \\Delta x)-f(x_0) }{ \\Delta x }存在，则称极限值为f(x)在$ x_0 $ 处的导数，并说f(x)在$ x_0 $ 处可导或有导数。当平均变化率极限不存在时，就说f(x)在 $ x_0 $ 处不可导或没有导数。 关于导数的说明 1）点导数是因变量在$ x_0 $ 处的变化率，它反映了因变量随自变量的变化而变化的快慢成都 2）如果函数y = f(x)在开区间 I 内的每点都可导，就称f(x)在开区间 I 内可导 3）对于任一 x 属于 I ，都对应着函数f(x)的一个导数，这个函数叫做原来函数f(x)的导函数 4）导函数在x1 处 为 0，若 x&lt;1 时，f’(x) &gt; 0 ，这 f(x) 递增，若f’(x)&lt;0 ，f(x)递减 5）f’(x0) 表示曲线y=f(x)在点 （x0,f($x_0$)）处的切线斜率 偏导数函数z=f(x,y)在点(x0,y0)的某一邻域内有定义，当y固定在y0而x在 $x_0$ 处有增量$ \\Delta x $ 时，相应的有函数增量 f(x_0 + \\Delta x, y_0) - f(x_0,y_0)如果 \\lim_{\\Delta x\\rightarrow 0 } \\frac {f(x_0 + \\Delta x, y_0) - f(x_0,y_0)}{\\Delta x}存在，则称z=f(x,y)在点($x_0$,$y_0$)处对x的偏导数，记为：$ f_x(x_0,y_0) $ 如果函数z=f(x,y)在区域D内任一点(x,y)处对x的偏导数都存在，那么这个偏导数就是x,y的函数，它就称为函数z=f(x,y)对自变量x的偏导数，记做 \\frac{ \\partial z }{ \\partial x } , \\frac{ \\partial f }{ \\partial x } , z_x , f_x(x,y),偏导数的概念可以推广到二元以上的函数，如 u = f(x,y,z)在x,y,z处 f_x(x,y,z)=\\lim_{\\Delta x \\rightarrow 0} \\frac{f(x + \\Delta x,y,z) -f(x,y,z)}{\\Delta x} f_y(x,y,z)=\\lim_{\\Delta y \\rightarrow 0} \\frac{f(x,y + \\Delta y,z) -f(x,y,z)}{\\Delta y} f_z(x,y,z)=\\lim_{\\Delta z \\rightarrow 0} \\frac{f(x,y,z + \\Delta z) -f(x,y,z)}{\\Delta z}可以看出导数与偏导数本质是一致的，都是自变量趋近于0时，函数值的变化与自变量的变化量比值的极限，直观的说，偏导数也就是函数在某一点沿坐标轴正方向的变化率。 区别：导数指的是一元函数中，函数y=f(x)某一点沿x轴正方向的的变化率；偏导数指的是多元函数中，函数y=f(x,y,z)在某一点沿某一坐标轴正方向的变化率。 偏导数的几何意义：偏导数$ z = f_x(x_0,y_0)$表示的是曲面被 $ y=y_0 $ 所截得的曲线在点M处的切线$ M_0T_x $对x轴的斜率偏导数$ z = f_y(x_0,y_0)$表示的是曲面被 $ x=x_0 $ 所截得的曲线在点M处的切线$ M_0T_y $对y轴的斜率 例子：求 $z = x^2 + 3 xy+y^2 $在点(1,2)处的偏导数。 \\frac{ \\partial z}{\\partial x} = 2x +3y \\frac{ \\partial z}{\\partial y} = 2y +3x所以:$z_x(x=1,y=2) = 8$$z_y(x=1,y=2) = 7$ 方向导数 \\frac{ \\partial }{ \\partial l } f(x_0,x_1,...,x_n) = \\lim_{\\rho \\rightarrow 0} \\frac{\\Delta y}{ \\Delta x } = \\lim_{\\rho \\rightarrow 0} \\frac{ f(x_0 + \\Delta x_0,...,x_j + \\Delta x_j,...,x_n + \\Delta x_n)-f(x_0,...,x_j,...,x_n)}{ \\rho } \\rho = \\sqrt{ (\\Delta x_0)^{2} +...+(\\Delta x_j)^{2}+...+(\\Delta x_n)^{2}}前边导数和偏导数的定义中，均是沿坐标轴正方向讨论函数的变化率。那么当讨论函数沿任意方向的变化率时，也就引出了方向导数的定义，即：某一点在某一趋近方向上的导数值。 通俗的解释是： 我们不仅要知道函数在坐标轴正方向上的变化率（即偏导数），而且还要设法求得函数在其他特定方向上的变化率。而方向导数就是函数在其他特定方向上的变化率。 梯度与方向导数有一定的关联，在微积分里面，对多元函数的参数求 $ \\partial $ 偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度。比如函数f(x,y), 分别对x,y求偏导数，求得的梯度向量就是 $( \\frac{ \\partial f }{ \\partial x },\\frac{ \\partial f }{ \\partial y })^T$ ,简称grad f(x,y)或者 $▽f(x,y)$。对于在点$(x_0,y_0)$的具体梯度向量就是$( \\frac{ \\partial f }{ \\partial x_0 },\\frac{ \\partial f }{ \\partial y_0 })^T$.或者$▽f(x_0,y_0)$，如果是3个参数的向量梯度，就是 $( \\frac{ \\partial f }{ \\partial x },\\frac{ \\partial f }{ \\partial y },\\frac{ \\partial f }{ \\partial z })^T$,以此类推。 那么这个梯度向量求出来有什么意义呢？他的意义从几何意义上讲，就是函数变化增加最快的地方。具体来说，对于函数f(x,y),在点$(x_0,y_0)$，沿着梯度向量的方向就是$( \\frac{ \\partial f }{ \\partial x_0 },\\frac{ \\partial f }{ \\partial y_0 })^T$的方向是f(x,y)增加最快的地方。或者说，沿着梯度向量的方向，更加容易找到函数的最大值。反过来说，沿着梯度向量相反的方向，也就是 $-( \\frac{ \\partial f }{ \\partial x_0 },\\frac{ \\partial f }{ \\partial y_0 })^T$的方向，梯度减少最快，也就是更加容易找到函数的最小值。 例如：函数 $f(x,y) = \\frac{1}{x^2+y^2} $ ，分别对x，y求偏导数得： \\frac{ \\partial f }{ \\partial x}=-\\frac{2x}{ (x^2+y^2)^2} \\frac{ \\partial f }{ \\partial y}=-\\frac{2y}{ (x^2+y^2)^2}所以 grad( \\frac{1}{x^2+y^2} ) = (-\\frac{2x}{ (x^2+y^2)^2} ,-\\frac{2y}{ (x^2+y^2)^2})函数在某一点的梯度是这样一个向量，它的方向与取得最大方向导数的方向一致，而它的模为方向导数的最大值。 注意点：1）梯度是一个向量2）梯度的方向是最大方向导数的方向3）梯度的值是最大方向导数的值 梯度下降与梯度上升在机器学习算法中，在最小化损失函数时，可以通过梯度下降思想来求得最小化的损失函数和对应的参数值，反过来，如果要求最大化的损失函数，可以通过梯度上升思想来求取。 梯度下降关于梯度下降的几个概念1）步长（learning rate）：步长决定了在梯度下降迭代过程中，每一步沿梯度负方向前进的长度2）特征（feature）：指的是样本中输入部门，比如样本（x0，y0），（x1，y1），则样本特征为x，样本输出为y3）假设函数（hypothesis function）：在监督学习中，为了拟合输入样本，而使用的假设函数，记为$h_θ(x)$。比如对于样本$（x_i,y_i）(i=1,2,…n)$,可以采用拟合函数如下： $h_θ(x) = θ0+θ1_x$。4）损失函数（loss function）：为了评估模型拟合的好坏，通常用损失函数来度量拟合的程度。损失函数极小化，意味着拟合程度最好，对应的模型参数即为最优参数。在线性回归中，损失函数通常为样本输出和假设函数的差取平方。比如对于样本（xi,yi）(i=1,2,…n),采用线性回归，损失函数为： \\jmath (\\theta _0,\\theta _1)=\\sum_{i=0}^{m}( h_\\theta(x_i)-y_i )^2其中$x_i$表示样本特征x的第i个元素，$y_i$表示样本输出y的第i个元素，$h_\\theta(x_i)$ 为假设函数。 梯度下降的代数方法描述 先决条件：确定优化模型的假设函数和损失函数这里假定线性回归的假设函数为$h_\\theta(x_1,x_2,…x_n)=\\theta_0+\\theta_1x_1+…+\\theta_nx_n$，其中 $\\theta _i(i=0,1,2…n)$ 为模型参数(公式中用$\\theta$代替)，$x_i(i=0,1,2…n)$为每个样本的n个特征值。 则对应选定得损失函数为： \\jmath (\\theta _0,\\theta _1,...,,\\theta _n)=\\sum_{i=0}^{m}( h_\\theta(x_0,x_1,...,x_n)-y_i )^2 算法相关参数的初始化主要是初始化 $ \\theta _0,\\theta _1…,\\theta _n$，算法终止距离 $\\varepsilon $ 以及步长 $ \\alpha $。在没有任何先验知识的时候，我喜欢将所有的 $\\theta$ 初始化为0， 将步长初始化为1。在调优的时候再优化。 算法过程 1)：确定当前损失函数的梯度，对于$\\theta _i $，其梯度表达式为： \\frac{\\partial }{\\partial \\theta _i}\\jmath (\\theta _1,\\theta _2,...,\\theta _n) 2)：用步长乘以损失函数的梯度，得到当前位置的下降距离，即 \\alpha \\frac{\\partial \\jmath (\\theta _1,\\theta _2,...,\\theta _n)}{\\partial \\theta _i} 3)：确定是否所有的$\\theta _i$ ，梯度下降的距离都小于 $ \\varepsilon $，如果小于$ \\varepsilon $，则算法停止，当前所有的 $\\theta _i(i=1,2,3,…,n)$ 即为最终结果。否则执行下一步。 4)：更新所有的 $\\theta$，对于$\\theta _i $，其更新表达式如下。更新完毕后继续转入步骤1)。 \\theta _i = \\theta _i - \\alpha \\frac{\\partial \\jmath (\\theta _1,\\theta _2,...,\\theta _n)}{\\partial \\theta _i}梯度下降的矩阵方式描述 先决条件：确定优化模型的假设函数和损失函数这里假定线性回归的假设函数为$h_\\theta(x_1,x_2,…x_n)=\\theta_0+\\theta_1x_1+…+\\theta_nx_n$，其中 $\\theta _i(i=0,1,2…n)$ 为模型参数，$x_i(i=0,1,2…n)$为每个样本的n个特征值。假设函数对应的矩阵表示为：$ h_\\theta (x) = X \\theta $，假设函数 $h_\\theta(x)$ 为mx1的向量，$\\theta $ 为nx1的向量，里面有n个代数法的模型参数。X为mxn维的矩阵。m代表样本的个数，n代表样本的特征数。则对应选定得损失函数为： \\jmath (\\theta)=(X \\theta −Y)^T (X \\theta−Y)其中YY是样本的输出向量，维度为m*12.算法相关参数初始化:$\\theta$ 向量可以初始化为默认值，或者调优后的值。算法终止距离 $\\varepsilon $ ，步长 $\\alpha$ 和 “梯度下降的代数方法”描述中一致。3.算法过程 1)：确定当前位置的损失函数的梯度，对于 $ \\theta $ 向量,其梯度表达式如下： \\frac{ \\partial }{\\partial \\theta } \\jmath (\\theta) 2)：用步长乘以损失函数的梯度，得到当前位置下降的距离，即 $\\alpha \\frac{ \\partial }{\\partial \\theta } \\jmath (\\theta)$ 3)：确定 $\\theta$ 向量里面的每个值,梯度下降的距离都小于 $\\varepsilon$，如果小于 $\\varepsilon$ 则算法终止，当前 $\\theta$ 向量即为最终结果。否则进入步骤4) 4)：更新 $\\theta$ 向量，其更新表达式如下。更新完毕后继续转入步骤1) \\theta =\\theta - \\alpha \\frac{ \\partial }{\\partial \\theta } \\jmath (\\theta) 梯度上升梯度上升和梯度下降的分析方式是一致的，只不过把 $ \\theta $ 的更新中 减号变为加号。 梯度下降的算法优化 算法的步长选择。在前面的算法描述中，我提到取步长为1，但是实际上取值取决于数据样本，可以多取一些值，从大到小，分别运行算法，看看迭代效果，如果损失函数在变小，说明取值有效，否则要增大步长。前面说了。步长太大，会导致迭代过快，甚至有可能错过最优解。步长太小，迭代速度太慢，很长时间算法都不能结束。所以算法的步长需要多次运行后才能得到一个较为优的值。 算法参数的初始值选择。 初始值不同，获得的最小值也有可能不同，因此梯度下降求得的只是局部最小值；当然如果损失函数是凸函数则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。 3.归一化。由于样本不同特征的取值范围不一样，可能导致迭代很慢，为了减少特征取值的影响，可以对特征数据归一化，也就是对于每个特征x，求出它的均值 $\\bar{x}$ 和标准差std(x)，然后转化为： \\frac{x - \\bar{x}}{std(x)}这样特征的新期望为0，新方差为1，迭代次数可以大大加快。 http://blog.csdn.net/walilk/article/details/50978864 https://www.zhihu.com/question/24658302 https://www.cnblogs.com/pinard/p/5970503.html http://www.doc88.com/p-7844239247737.html 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"梯度","slug":"梯度","permalink":"http://thinkgamer.cn/tags/梯度/"}]},{"title":"异常检测之指数平滑（利用elasticsearch来实现）","slug":"ELK/异常检测之指数平滑（利用elasticsearch来实现）","date":"2017-11-20T09:18:54.000Z","updated":"2019-10-14T09:45:51.415Z","comments":true,"path":"2017/11/20/ELK/异常检测之指数平滑（利用elasticsearch来实现）/","link":"","permalink":"http://thinkgamer.cn/2017/11/20/ELK/异常检测之指数平滑（利用elasticsearch来实现）/","excerpt":"指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。","text":"指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。 关于指数平滑的得相关资料： ES API接口： https://github.com/IBBD/IBBD.github.io/blob/master/elk/aggregations-pipeline.mdhttps://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movavg-aggregation.html 理论概念 http://blog.sina.com.cn/s/blog_4b9acb5201016nkd.html ES移动平均聚合：Moving Average的四种模型simple就是使用窗口内的值的和除于窗口值，通常窗口值越大，最后的结果越平滑: (a1 + a2 + … + an) / n12345678910111213141516171819202122232425curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"size\": 0, \"aggs\": &#123; \"my_date_histo\":&#123; \"date_histogram\":&#123; \"field\":\"date\", \"interval\":\"1M\" &#125;, \"aggs\":&#123; \"the_sum\":&#123; \"sum\":&#123; \"field\": \"price\" &#125; &#125;, \"the_movavg\":&#123; \"moving_avg\":&#123; \"buckets_path\": \"the_sum\", \"window\" : 30, \"model\" : \"simple\" &#125; &#125; &#125; &#125; &#125;&#125;' 线性模型：Linear对窗口内的值先做线性变换处理，再求平均：(a1 1 + a2 2 + … + an * n) / (1 + 2 + … + n) 12345678910111213141516171819202122232425curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"size\": 0, \"aggs\": &#123; \"my_date_histo\":&#123; \"date_histogram\":&#123; \"field\":\"date\", \"interval\":\"1M\" &#125;, \"aggs\":&#123; \"the_sum\":&#123; \"sum\":&#123; \"field\": \"price\" &#125; &#125;, \"the_movavg\": &#123; \"moving_avg\":&#123; \"buckets_path\": \"the_sum\", \"window\" : 30, \"model\" : \"linear\" &#125; &#125; &#125; &#125; &#125;&#125;' 指数平滑模型指数模型：EWMA (Exponentially Weighted)即： 一次指数平滑模型 EWMA模型通常也成为单指数模型（single-exponential）, 和线性模型的思路类似，离当前点越远的点，重要性越低，具体化为数值的指数下降，对应的参数是alpha。 alpha值越小，下降越慢。（估计是用1 - alpha去计算的）默认的alpha=0.3 计算模型：s2 = α x2 + (1 - α) s1 其中α是平滑系数，si是之前i个数据的平滑值，α取值为[0,1]，越接近1，平滑后的值越接近当前时间的数据值，数据越不平滑，α越接近0，平滑后的值越接近前i个数据的平滑值，数据越平滑，α的值通常可以多尝试几次以达到最佳效果。 一次指数平滑算法进行预测的公式为：xi+h=si，其中i为当前最后的一个数据记录的坐标，亦即预测的时间序列为一条直线，不能反映时间序列的趋势和季节性。 12345678910111213141516171819202122232425262728curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"size\": 0, \"aggs\": &#123; \"my_date_histo\":&#123; \"date_histogram\":&#123; \"field\":\"date\", \"interval\":\"1M\" &#125;, \"aggs\":&#123; \"the_sum\":&#123; \"sum\":&#123; \"field\": \"price\" &#125; &#125;, \"the_movavg\": &#123; \"moving_avg\":&#123; \"buckets_path\": \"the_sum\", \"window\" : 30, \"model\" : \"ewma\", \"settings\" : &#123; \"alpha\" : 0.5 &#125; &#125; &#125; &#125; &#125; &#125;&#125;' 二次指数平滑模型: Holt-Linear计算模型： s2 = α x2 + (1 - α) (s1 + t1) t2 = ß (s2 - s1) + (1 - ß) t1 默认alpha = 0.3 and beta = 0.1 二次指数平滑保留了趋势的信息，使得预测的时间序列可以包含之前数据的趋势。二次指数平滑的预测公式为 xi+h=si+hti 二次指数平滑的预测结果是一条斜的直线。 1234567891011121314151617181920212223242526272829curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"size\": 0, \"aggs\": &#123; \"my_date_histo\":&#123; \"date_histogram\":&#123; \"field\":\"date\", \"interval\":\"1M\" &#125;, \"aggs\":&#123; \"the_sum\":&#123; \"sum\":&#123; \"field\": \"price\" &#125; &#125;, \"the_movavg\": &#123; \"moving_avg\":&#123; \"buckets_path\": \"the_sum\", \"window\" : 30, \"model\" : \"holt\", \"settings\" : &#123; \"alpha\" : 0.5, \"beta\" : 0.5 &#125; &#125; &#125; &#125; &#125; &#125;&#125;' 三次指数平滑模型：Holt-Winters无季节模型三次指数平滑在二次指数平滑的基础上保留了季节性的信息，使得其可以预测带有季节性的时间序列。三次指数平滑添加了一个新的参数p来表示平滑后的趋势。 1: Additive Holt-Winters：Holt-Winters加法模型 下面是累加的三次指数平滑123si=α(xi-pi-k)+(1-α)(si-1+ti-1)ti=ß(si-si-1)+(1-ß)ti-1pi=γ(xi-si)+(1-γ)pi-k 其中k为周期 累加三次指数平滑的预测公式为： xi+h=si+hti+pi-k+(h mod k) 1234567891011121314151617181920212223242526272829303132curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"size\": 0, \"aggs\": &#123; \"my_date_histo\":&#123; \"date_histogram\":&#123; \"field\":\"date\", \"interval\":\"1M\" &#125;, \"aggs\":&#123; \"the_sum\":&#123; \"sum\":&#123; \"field\": \"price\" &#125; &#125;, \"the_movavg\": &#123; \"moving_avg\":&#123; \"buckets_path\": \"the_sum\", \"window\" : 30, \"model\" : \"holt_winters\", \"settings\" : &#123; \"type\" : \"add\", \"alpha\" : 0.5, \"beta\" : 0.5, \"gamma\" : 0.5, \"period\" : 7 &#125; &#125; &#125; &#125; &#125; &#125;&#125;' 2: Multiplicative Holt-Winters：Holt-Winters乘法模型 下式为累乘的三次指数平滑：123si=αxi/pi-k+(1-α)(si-1+ti-1)ti=ß(si-si-1)+(1-ß)ti-1pi=γxi/si+(1-γ)pi-k 其中k为周期 累乘三次指数平滑的预测公式为： xi+h=(si+hti)pi-k+(h mod k) α，ß，γ的值都位于[0,1]之间，可以多试验几次以达到最佳效果。 s,t,p初始值的选取对于算法整体的影响不是特别大，通常的取值为s0=x0,t0=x1-x0,累加时p=0,累乘时p=1. 123456789101112131415161718192021222324252627282930313233curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"size\": 0, \"aggs\": &#123; \"my_date_histo\":&#123; \"date_histogram\":&#123; \"field\":\"date\", \"interval\":\"1M\" &#125;, \"aggs\":&#123; \"the_sum\":&#123; \"sum\":&#123; \"field\": \"price\" &#125; &#125;, \"the_movavg\": &#123; \"moving_avg\":&#123; \"buckets_path\": \"the_sum\", \"window\" : 30, \"model\" : \"holt_winters\", \"settings\" : &#123; \"type\" : \"mult\", \"alpha\" : 0.5, \"beta\" : 0.5, \"gamma\" : 0.5, \"period\" : 7, \"pad\" : true &#125; &#125; &#125; &#125; &#125; &#125;&#125;' 预测模型：Prediction使用当前值减去前一个值，其实就是环比增长 1234567891011121314151617181920212223242526curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"size\": 0, \"aggs\": &#123; \"my_date_histo\":&#123; \"date_histogram\":&#123; \"field\":\"date\", \"interval\":\"1M\" &#125;, \"aggs\":&#123; \"the_sum\":&#123; \"sum\":&#123; \"field\": \"price\" &#125; &#125;, \"the_movavg\": &#123; \"moving_avg\":&#123; \"buckets_path\": \"the_sum\", \"window\" : 30, \"model\" : \"simple\", \"predict\" : 10 &#125; &#125; &#125; &#125; &#125;&#125;' 最小化：Minimization某些模型（EWMA，Holt-Linear，Holt-Winters）需要配置一个或多个参数。参数选择可能会非常棘手，有时不直观。此外，这些参数的小偏差有时会对输出移动平均线产生剧烈的影响。 出于这个原因，三个“可调”模型可以在算法上最小化。最小化是一个参数调整的过程，直到模型生成的预测与输出数据紧密匹配为止。最小化并不是完全防护的，并且可能容易过度配合，但是它往往比手动调整有更好的结果。 ewma和holt_linear默认情况下禁用最小化，而holt_winters默认启用最小化。 Holt-Winters最小化是最有用的，因为它有助于提高预测的准确性。 EWMA和Holt-Linear不是很好的预测指标，主要用于平滑数据，所以最小化对于这些模型来说不太有用。 通过最小化参数启用/禁用最小化：”minimize” : true 原始数据数据为SSH login数据其中 IP／user已处理1234567891011121314151617181920212223242526272829303132&#123; \"_index\": \"logstash-sshlogin-others-success-2017-10\", \"_type\": \"sshlogin\", \"_id\": \"AV-weLF8c2nHCDojUbat\", \"_version\": 2, \"_score\": 1, \"_source\": &#123; \"srcip\": \"222.221.238.162\", \"dstport\": \"\", \"pid\": \"20604\", \"program\": \"sshd\", \"message\": \"dwasw-ibb01:Oct 19 23:38:02 176.231.228.130 sshd[20604]: Accepted publickey for nmuser from 222.221.238.162 port 49484 ssh2\", \"type\": \"zhongcai-sshlogin\", \"ssh_type\": \"ssh_successful_login\", \"forwarded\": \"false\", \"manufacturer\": \"others\", \"IndexTime\": \"2017-10\", \"path\": \"/home/logstash/log/logstash_data/audit10/sshlogin/11.txt\", \"number\": 1, \"hostname\": \"176.231.228.130\", \"protocol\": \"ssh2\", \"@timestamp\": \"2017-10-19T15:38:02.000Z\", \"ssh_method\": \"publickey\", \"_hostname\": \"dwasw-ibb01\", \"@version\": \"1\", \"host\": \"localhost\", \"srcport\": \"49484\", \"dstip\": \"\", \"category\": \"sshlogin\", \"user\": \"nmuser\" &#125;&#125; 利用ES API接口去调用查询数据“interval”: “hour”: hour为单位，这里可以是分钟，小时，天，周，月 “format”: “yyyy-MM-dd HH”: 聚合结果得日期格式 12345\"the_sum\": &#123; \"sum\": &#123; \"field\": \"number\" &#125;&#125; number为要聚合得字段 123456789101112131415161718192021222324252627282930313233343536curl -POST 'localhost:9200/logstash-sshlogin-others-success-2017-10/sshlogin/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"size\": 0, \"query\": &#123; \"term\": &#123; \"ssh_type\": \"ssh_successful_login\" &#125; &#125;, \"aggs\": &#123; \"hour_sum\": &#123; \"date_histogram\": &#123; \"field\": \"@timestamp\", \"interval\": \"hour\", \"format\": \"yyyy-MM-dd HH\" &#125;, \"aggs\": &#123; \"the_sum\": &#123; \"sum\": &#123; \"field\": \"number\" &#125; &#125;, \"the_movavg\": &#123; \"moving_avg\": &#123; \"buckets_path\": \"the_sum\", \"window\": 30, \"model\": \"holt\", \"settings\": &#123; \"alpha\": 0.5, \"beta\": 0.7 &#125; &#125; &#125; &#125; &#125; &#125;&#125;' 得到的结果形式为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; \"took\" : 35, \"timed_out\" : false, \"_shards\" : &#123; \"total\" : 1, \"successful\" : 1, \"failed\" : 0 &#125;, \"hits\" : &#123; \"total\" : 206821, \"max_score\" : 0.0, \"hits\" : [ ] &#125;, \"aggregations\" : &#123; \"hour_sum\" : &#123; \"buckets\" : [ &#123; \"key_as_string\" : \"2017-09-30 16\", \"key\" : 1506787200000, \"doc_count\" : 227, \"the_sum\" : &#123; \"value\" : 227.0 &#125; &#125;, &#123; \"key_as_string\" : \"2017-09-30 17\", \"key\" : 1506790800000, \"doc_count\" : 210, \"the_sum\" : &#123; \"value\" : 210.0 &#125;, \"the_movavg\" : &#123; \"value\" : 113.5 &#125; &#125;, &#123; \"key_as_string\" : \"2017-09-30 18\", \"key\" : 1506794400000, \"doc_count\" : 365, \"the_sum\" : &#123; \"value\" : 365.0 &#125;, \"the_movavg\" : &#123; \"value\" : 210.0 &#125; &#125;, ... &#125;&#125; 对应得python代码（查询数据到画图）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# coding: utf-8from elasticsearch import Elasticsearchimport matplotlib.pyplot as pltfrom matplotlib.font_manager import FontManager, FontPropertiesclass Smooth: def __init__(self,index): self.es = Elasticsearch(['localhost:9200']) self.index = index # 处理mac中文编码错误 def getChineseFont(self): return FontProperties(fname='/System/Library/Fonts/PingFang.ttc') # 对index进行聚合 def agg(self): # \"format\": \"yyyy-MM-dd HH:mm:SS\" dsl = ''' &#123; \"size\": 0, \"query\": &#123; \"term\": &#123; \"ssh_type\": \"ssh_successful_login\" &#125; &#125;, \"aggs\": &#123; \"hour_sum\": &#123; \"date_histogram\": &#123; \"field\": \"@timestamp\", \"interval\": \"day\", \"format\": \"dd\" &#125;, \"aggs\": &#123; \"the_sum\": &#123; \"sum\": &#123; \"field\": \"number\" &#125; &#125;, \"the_movavg\": &#123; \"moving_avg\": &#123; \"buckets_path\": \"the_sum\", \"window\": 30, \"model\": \"holt_winters\", \"settings\": &#123; \"alpha\": 0.5, \"beta\": 0.7 &#125; &#125; &#125; &#125; &#125; &#125; &#125; ''' res = self.es.search(index=self.index, body=dsl) return res['aggregations']['hour_sum']['buckets'] # 画图 def draw(self): x,y_true,y_pred = [],[],[] for one in self.agg(): x.append(one['key_as_string']) y_true.append(one['the_sum']['value']) if 'the_movavg' in one.keys(): # 前几条数据没有 the_movavg 字段，故将真实值赋值给pred值 y_pred.append(one['the_movavg']['value']) else: y_pred.append(one['the_sum']['value']) x_line = range(len(x)) plt.figure(figsize=(10,5)) plt.plot(x_line,y_true,color=\"r\") plt.plot(x_line,y_pred,color=\"g\") plt.xlabel(u\"每单位时间\",fontproperties=self.getChineseFont()) #X轴标签 plt.xticks(range(len(x)), x) plt.ylabel(u\"聚合结果\",fontproperties=self.getChineseFont()) #Y轴标签 plt.title(u\"10月份 SSH 主机登录成功聚合图\",fontproperties=self.getChineseFont()) # 标题 plt.legend([u\"True value\",u\"Predict value\"]) plt.show()smooth = Smooth(\"logstash-sshlogin-others-success-2017-10\")print smooth.draw() 结果图示为： 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"ELK","slug":"ELK","permalink":"http://thinkgamer.cn/tags/ELK/"},{"name":"ES","slug":"ES","permalink":"http://thinkgamer.cn/tags/ES/"},{"name":"异常检测","slug":"异常检测","permalink":"http://thinkgamer.cn/tags/异常检测/"}]},{"title":"Elasticsearch-DSL部分集合","slug":"ELK/Elasticsearch-DSL部分集合","date":"2017-11-14T09:26:48.000Z","updated":"2019-10-14T06:42:35.654Z","comments":true,"path":"2017/11/14/ELK/Elasticsearch-DSL部分集合/","link":"","permalink":"http://thinkgamer.cn/2017/11/14/ELK/Elasticsearch-DSL部分集合/","excerpt":"ELK是日志收集分析神器，在这篇文章中将会介绍一些ES的常用命令。 点击阅读：ELK Stack 从入门到放弃","text":"ELK是日志收集分析神器，在这篇文章中将会介绍一些ES的常用命令。 点击阅读：ELK Stack 从入门到放弃 DSL中遇到的错误及解决办法分片限制错误1Trying to query 2632 shards, which is over the limit of 1000. This limit exists because querying many shards at the same time can make the job of the coordinating node very CPU and/or memory intensive. It is usually a better idea to have a smaller number of larger shards. Update [action.search.shard_count.limit] to a greater value if you really want to query that many shards at the same time. 解决办法：1234567891011修改该限制数目curl -k -u admin:admin -XPUT 'http://localhost:9200/_cluster/settings' -H 'Content-Type: application/json' -d' &#123; \"persistent\" : &#123; \"action.search.shard_count.limit\" : \"5000\" &#125;&#125;'-k -u admin:admin 表述如果有权限保护的话可以加上 Fileddate 错误1Fielddata is disabled on text fields by default. Set fielddata=true on [make] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. 解决办法：1234567891011121314cars: 索引名transactions：索引对应的类型color：字段curl -XPUT -k -u admin:admin 'localhost:9200/cars/_mapping/transactions?pretty' -H 'Content-Type: application/json' -d'&#123; \"properties\": &#123; \"color\": &#123; \"type\": \"text\", \"fielddata\": true &#125; &#125;&#125;' 指定关键词查询，排序和函数统计指定关键词from 为首个偏移量，size为返回数据的条数12345678910http://10.10.11.139:9200/logstash-nginx-access-*/nginx-access/_search?pretty&#123; \"from\":0,size\":1000, \"query\" : &#123; \"term\" : &#123; \"major\" : \"55\" &#125; &#125;&#125; 添加排序(需要进行mapping设置，asc 为升序 desc为降序)1234567891011&#123; \"from\":0,\"size\":1000, \"sort\":[ &#123;\"offset\":\"desc\"&#125; ], \"query\" : &#123; \"term\" : &#123; \"major\" : \"55\" &#125; &#125;&#125; mode 方法mode方法包括 min／max／avg／sum／median 假如现在要对price字段进行排序，但是price字段有多个值，这个时候就可以使用mode 方法了。 12345678&#123; \"query\" : &#123; \"term\" : &#123; \"product\" : \"chocolate\" &#125; &#125;, \"sort\" : [ &#123;\"price\" : &#123;\"order\" : \"asc\", \"mode\" : \"avg\"&#125;&#125; ]&#125; IP范围和网段查询IP range 搜索错误：1Fielddata is disabled on text fields by default. Set fielddata=true on [clientip] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. 解决办法：1234567891011curl -k -u admin:admin -XPUT '10.10.11.139:9200/logstash-nginx-access-*/_mapping/nginx-access?pretty' -H 'Content-Type: application/json' -d'&#123; \"properties\": &#123; \"clientip\": &#123; \"type\": \"text\", \"fielddata\": true, \"norms\": false &#125; &#125;&#125;' 查看某个索引的mapping1curl -k -u admin:admin -XGET http://10.10.11.139:9200/logstash-nginx-access-*/_mapping?pretty (当IP为不可解析使就会出现错误)123456789101112131415http://10.10.11.139:9200/logstash-sshlogin-others-success-*/zhongcai/_search?pretty&#123; \"size\":100, \"aggs\" : &#123; \"ip_ranges\" : &#123; \"ip_range\" : &#123; \"field\" : \"clientip\", \"ranges\" : [ &#123; \"to\" : \"40.77.167.73\" &#125;, &#123; \"from\" : \"40.77.167.75\" &#125; ] &#125; &#125; &#125;&#125; 网段查询1234567891011121314http://10.10.11.139:9200/logstash-sshlogin-others-success-*/zhongcai/_search?pretty&#123; \"aggs\" : &#123; \"ip_ranges\" : &#123; \"ip_range\" : &#123; \"field\" : \"ip\", \"ranges\" : [ &#123; \"mask\" : \"172.21.202.0/24\" &#125;, &#123; \"mask\" : \"172.21.202.0/24\" &#125; ] &#125; &#125; &#125;&#125; 关于索引的操作删除某个索引-k -u admin:admin 为用户名：密码1curl -XDELETE -k -u admin:admin 'http://localhost:9200/my_index' 查看某个索引的Mapping1curl -XGET \"http://127.0.0.1:9200/my_index/_mapping?pretty\" 索引数据迁移Es索引reindex(从ip_remote上迁移到本地)123456789101112131415curl -XPOST 'localhost:9200/_reindex?pretty' -H 'Content-Type: application/json' -d'&#123; \"source\": &#123; \"remote\": &#123; \"host\": \"http://ip_remote:9200\", \"username\": \"username\", \"password\": \"passwd\" &#125;, \"index\": \"old_index\" &#125;, \"dest\": &#123; \"index\": \"new_index\" &#125;&#125;' 为某个索引添加字段添加number字段： 唯一ID1234567curl -POST 'http://127.0.0.1:9200/my_idnex/my_index_type/id/_update?pretty' -H 'Content-Type: application/json' -d'&#123; \"doc\" : &#123; \"number\" : 1 &#125;&#125;' 批量操作123456789101112curl -XPOST 'localhost:9200/logstash-sshlogin-others-success-2017-*/_update_by_query?pretty' -H 'Content-Type: application/json' -d'&#123; \"script\": &#123; \"inline\": \"ctx._source.number=1\", \"lang\": \"painless\" &#125;, \"query\": &#123; \"match_all\": &#123; &#125; &#125;&#125;' 根据指定条件进行聚合每小时成功登录的次数进行聚合123456789101112131415161718curl -POST 'http://127.0.0.1:9200/logstash-sshlogin-others-success-2017-*/zhongcai-sshlogin/_search?pretty' -H 'Content-Type: application/json' -d'&#123; \"query\": &#123; \"term\": &#123; \"ssh_type\": \"ssh_successful_login\" &#125; &#125;, \"aggs\": &#123; \"sums\": &#123; \"date_histogram\": &#123; \"field\": \"@timestamp\", \"interval\": \"hour\", \"format\": \"yyyy-MM-dd HH\" &#125; &#125; &#125;&#125;' 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"ELK","slug":"ELK","permalink":"http://thinkgamer.cn/tags/ELK/"},{"name":"ES","slug":"ES","permalink":"http://thinkgamer.cn/tags/ES/"}]},{"title":"数据结构算法之链表","slug":"数据结构/数据结构算法之链表","date":"2017-11-12T16:58:37.000Z","updated":"2019-10-14T06:42:35.681Z","comments":true,"path":"2017/11/13/数据结构/数据结构算法之链表/","link":"","permalink":"http://thinkgamer.cn/2017/11/13/数据结构/数据结构算法之链表/","excerpt":"链表面试总结，使用python实现，参考：https://www.cnblogs.com/lixiaohui-ambition/archive/2012/09/25/2703195.html","text":"链表面试总结，使用python实现，参考：https://www.cnblogs.com/lixiaohui-ambition/archive/2012/09/25/2703195.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding:utf-8# 定义链表class ListNode: def __init__(self): self.data = None self.pnext = None# 链表操作类class ListNode_handle: def __init__(self): self.cur_node = None # 链表添加元素 def add(self,data): ln = ListNode() ln.data = data ln.pnext = self.cur_node self.cur_node = ln return ln # 打印链表 def prt(self,ln): while ln: print(ln.data,end=\" \") ln = ln.pnext # 逆序输出 def _reverse(self,ln): _list = [] while ln: _list.append(ln.data) ln = ln.pnext ln_2 = ListNode() ln_h = ListNode_handle() for i in _list: ln_2 = ln_h.add(i) return ln_2 # 求链表的长度 def _length(self,ln): _len = 0 while ln: _len += 1 ln = ln.pnext return _len # 查找指定位置的节点 def _find_loc(self,ln,loc): _sum = 0 while ln and _sum != loc: _sum += 1 ln = ln.pnext return ln.data # 判断某个节点是否在链表中 def _exist(self,ln,data): flag = False while ln and data != ln.data: ln = ln.pnext return flag# 创建链表 ln = ListNode()ln_h = ListNode_handle()a = [1,4,2,5,8,5,7,9]for i in a: ln = ln_h.add(i)print(\"正序输出...\")ln_h.prt(ln)print(\"\\n\\n逆序输出...\")ln_2 = ln_h._reverse(ln)ln_h.prt(ln_2)# 求链表ln的长度length = ln_h._length(ln)print(\"\\n\\nln的长度为:\",length)# 查找链表ln中的倒数第３个节点data = ln_h._find_loc(ln,ln_h._length(ln)-3)print(\"\\n\\n倒数第三个节点为:\",data)# 返回某个节点在链表中的位置loc = ln_h._loc(ln,5)# 判断某个节点是否在链表中flag = ln_h._exist(ln,5)print(\"\\n\\n５是否存在与链表ln中:\",end=\" \")if flag: print(\"Yes\")else: print(\"No\") 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://thinkgamer.cn/tags/数据结构/"}]},{"title":"数据结构算法之合并两个有序序列","slug":"数据结构/数据结构算法之合并两个有序序列","date":"2017-11-12T16:55:29.000Z","updated":"2019-10-14T06:42:35.681Z","comments":true,"path":"2017/11/13/数据结构/数据结构算法之合并两个有序序列/","link":"","permalink":"http://thinkgamer.cn/2017/11/13/数据结构/数据结构算法之合并两个有序序列/","excerpt":"有序序列的合并，python实现。","text":"有序序列的合并，python实现。 12345678910111213141516171819202122232425#coding:utf-8a = [2,4,6,8,10]b = [3,5,7,9,11,13,15]c = []def merge(a,b): i,j = 0,0 while i&lt;=len(a)-1 and j&lt;=len(b)-1: if a[i]&lt;b[j]: c.append(a[i]) i+=1 else: c.append(b[j]) j+=1 if i&lt;=len(a)-1: for m in a[i:]: c.append(m) if j&lt;=len(b)-1: for n in b[j:]: c.append(n) print(c)merge(a,b) 运行结果为：1[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15] 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://thinkgamer.cn/tags/数据结构/"}]},{"title":"数据结构算法之排序","slug":"数据结构/数据结构算法之排序","date":"2017-11-12T16:51:28.000Z","updated":"2019-10-14T06:42:35.681Z","comments":true,"path":"2017/11/13/数据结构/数据结构算法之排序/","link":"","permalink":"http://thinkgamer.cn/2017/11/13/数据结构/数据结构算法之排序/","excerpt":"数据结构面试中经常会被问到篇排序相关的问题，那么这篇文章会研究下怎么用python来实现排序。","text":"数据结构面试中经常会被问到篇排序相关的问题，那么这篇文章会研究下怎么用python来实现排序。 冒泡排序12345678910111213#coding：utf-8# 冒泡排序def maopao(): a = [2,1,4,3,9,5,6,8,7] for i in range(len(a)-1): for j in range(len(a)-1-i): if a[j]&gt;a[j+1]: temp = a[j] a[j] = a[j+1] a[j+1] = temp print(a)maopao() 结果为：1[1, 2, 3, 4, 5, 6, 7, 8, 9] 归并排序1234567891011121314151617181920212223242526272829# 归并排序def merge(a,b): i,j = 0,0 c = [] while i&lt;=len(a)-1 and j&lt;=len(b)-1: if a[i]&lt;b[j]: c.append(a[i]) i+=1 else: c.append(b[j]) j+=1 if i&lt;=len(a)-1: for m in a[i:]: c.append(m) if j&lt;=len(b)-1: for n in b[j:]: c.append(n) return cdef guibing(a): if len(a)&lt;=1: return a center = int(len(a)/2) left = guibing(a[:center]) right = guibing(a[center:]) return merge(left,right)print(guibing([2,1,4,3,9,5,6,8,7])) 结果为：1[1, 2, 3, 4, 5, 6, 7, 8, 9] 快速排序 快速排序Python实现 123456789101112131415161718192021222324252627# 快速排序 def kpsort(left,right,a): based = a[left] i = left j = right while i &lt; j: # 从数组右边开始遍历 while a[j]&gt;=based and i&lt;j: j -= 1 a[i] = a[j] while a[i]&lt;=based and i&lt;j: i += 1 a[j]= a[i] a[i] = based return i def kuaipai(left,right,a): if left&lt;right: p = kpsort(left,right,a) kuaipai(left,p-1,a) kuaipai(p+1,right,a) return a print(kuaipai(0,8,a =[2,1,4,3,9,5,6,8,7])) 结果为1[1, 2, 3, 4, 5, 6, 7, 8, 9] 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://thinkgamer.cn/tags/数据结构/"}]},{"title":"数据结构算法之二叉树","slug":"数据结构/数据结构算法之二叉树","date":"2017-11-12T16:44:41.000Z","updated":"2019-10-14T06:42:35.680Z","comments":true,"path":"2017/11/13/数据结构/数据结构算法之二叉树/","link":"","permalink":"http://thinkgamer.cn/2017/11/13/数据结构/数据结构算法之二叉树/","excerpt":"数据结构面试中经常会被问到篇二叉树相关的问题，那么这篇文章会研究下怎么用python来进行二叉树的构建和遍历。","text":"数据结构面试中经常会被问到篇二叉树相关的问题，那么这篇文章会研究下怎么用python来进行二叉树的构建和遍历。 注意：py2中1print root.elem, 在py3中要换成1print (root.elem,end=\" \") 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# coding:utf-8# 定义节点类class Node: def __init__(self,elem = -1,): self.elem = elem self.left = None self.right = None # 定义二叉树class Tree: def __init__(self): self.root = Node() self.myqu = [] # 添加节点 def add(self,elem): node = Node(elem) if self.root.elem == -1: # 判断如果是根节点 self.root = node self.myqu.append(self.root) else: treenode = self.myqu[0] if treenode.left == None: treenode.left = node self.myqu.append(treenode.left) else: treenode.right = node self.myqu.append(treenode.right) self.myqu.pop(0) # 利用递归实现树的先序遍历 def xianxu(self,root): if root == None: return print root.elem, self.xianxu(root.left) self.xianxu(root.right) # 利用递归实现树的中序遍历 def zhongxu(self,root): if root == None: return self.zhongxu(root.left) print root.elem, self.zhongxu(root.right) # 利用递归实现树的后序遍历 def houxu(self,root): if root == None: return self.houxu(root.left) self.houxu(root.right) print root.elem, # 利用队列实现层次遍历 def cengci(self,root): if root == None: return myq = [] node = root myq.append(node) while myq: node = myq.pop(0) print node.elem, if node.left != None: myq.append(node.left) if node.right != None: myq.append(node.right) # 求树的叶子节点 def getYeJiedian(self,root): if root == None: return 0 if root.left == None and root.right == None: return 1 return self.getYeJiedian(root.left) + self.getYeJiedian(root.right) # 由先序和中序,还原二叉树 def preMidToHou(self,pre,mid): if len(pre)==0: return None if len(pre)==1: Node(mid[0]) root = Node(pre[0]) root_index = mid.index(pre[0]) root.left = self.preMidToHou(pre[1:root_index + 1],mid[:root_index]) root.right = self.preMidToHou(pre[root_index + 1:],mid[root_index + 1:]) return root # 由后序和中序,还原二叉树 def preMidToHou(self,mid,hou): if len(hou)==0: return None if len(hou)==1: Node(mid[0]) root = Node(hou[-1]) root_index = mid.index(hou[-1]) root.left = self.preMidToHou(mid[:root_index],hou[:root_index]) root.right = self.preMidToHou(mid[root_index + 1:],mid[root_index + 1:]) return root# 创建一个树，添加节点tree = Tree()for i in range(10): tree.add(i) print(\"二叉树的先序遍历:\")print(tree.xianxu(tree.root))print(\"二叉树的中序遍历:\")print(tree.zhongxu(tree.root))print(\"二叉树的后序遍历:\")print(tree.houxu(tree.root))print(\"二叉树的层次遍历\")print(tree.cengci(tree.root))print(\"\\n二叉树的叶子节点为:\")print(tree.getYeJiedian(tree.root))print(\"\\n已知二叉树先序遍历和中序遍历，求后序:\")print(\"先序:\")print(tree.xianxu(tree.root))print(\"中序:\")print(tree.zhongxu(tree.root))print(\"后序:\")root = tree.preMidToHou([0,1,3,7,8,4,9,2,5,6],[7,3,8,1,9,4,0,5,2,6])print(tree.houxu(root))print(\"\\n已知二叉树后序遍历和中序遍历，求前序:\")print(\"后序:\")print(tree.houxu(tree.root))print(\"中序:\")print(tree.zhongxu(tree.root))print(\"前序:\")root = tree.preMidToHou([7,3,8,1,9,4,0,5,2,6],[7,8,3,9,4,1,5,6,2,0])print(tree.xianxu(root)) 运行结果为：123456789101112131415161718192021222324252627282930二叉树的先序遍历:0 1 3 7 8 4 9 2 5 6 None二叉树的中序遍历:7 3 8 1 9 4 0 5 2 6 None二叉树的后序遍历:7 8 3 9 4 1 5 6 2 0 None二叉树的层次遍历0 1 2 3 4 5 6 7 8 9 None二叉树的叶子节点为:5已知二叉树先序遍历和中序遍历，求后序:先序:0 1 3 7 8 4 9 2 5 6 None中序:7 3 8 1 9 4 0 5 2 6 None后序:1 3 7 8 4 9 0 5 2 6 None已知二叉树后序遍历和中序遍历，求前序:后序:7 8 3 9 4 1 5 6 2 0 None中序:7 3 8 1 9 4 0 5 2 6 None前序:0 1 3 7 8 4 9 6 2 5 None 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://thinkgamer.cn/tags/数据结构/"}]},{"title":"回归分析之Sklearn实现电力预测","slug":"机器学习/回归分析之Sklearn实现电力预测","date":"2017-11-07T05:39:15.000Z","updated":"2019-10-14T06:42:35.684Z","comments":true,"path":"2017/11/07/机器学习/回归分析之Sklearn实现电力预测/","link":"","permalink":"http://thinkgamer.cn/2017/11/07/机器学习/回归分析之Sklearn实现电力预测/","excerpt":"参考原文：http://www.cnblogs.com/pinard/p/6016029.html这里进行了手动实现，增强记忆。","text":"参考原文：http://www.cnblogs.com/pinard/p/6016029.html这里进行了手动实现，增强记忆。 1：数据集介绍使用的数据是UCI大学公开的机器学习数据 数据的介绍在这： http://archive.ics.uci.edu/ml/datasets/Combined+Cycle+Power+Plant 数据的下载地址在这：http://archive.ics.uci.edu/ml/machine-learning-databases/00294/ 里面是一个循环发电场的数据，共有9568个样本数据，每个数据有5列，分别是:AT（温度）, V（压力）, AP（湿度）, RH（压强）, PE（输出电力)。我们不用纠结于每项具体的意思。 我们的问题是得到一个线性的关系，对应PE是样本输出，而AT/V/AP/RH这4个是样本特征， 机器学习的目的就是得到一个线性回归模型，即: PE = \\theta _{0} + \\theta _{0} * AT + \\theta _{0} * V +\\theta _{0} * AP +\\theta _{0}*RH而需要学习的，就是θ0,θ1,θ2,θ3,θ4这5个参数。 2：准备数据下载源数据之后，解压会得到一个xlsx的文件，打开另存为csv文件，数据已经整理好，没有非法数据，但是数据并没有进行归一化，不过这里我们可以使用sklearn来帮我处理 sklearn的归一化处理参考：http://blog.csdn.net/gamer_gyt/article/details/77761884 3：使用pandas来进行数据的读取1234import pandas as pd# pandas 读取数据data = pd.read_csv(\"Folds5x2_pp.csv\")data.head() 然后会看到如下结果，说明数据读取成功： 123456 AT V AP RH PE0 8.34 40.77 1010.84 90.01 480.481 23.64 58.49 1011.40 74.20 445.752 29.74 56.90 1007.15 41.91 438.763 19.07 49.69 1007.22 76.79 453.094 11.80 40.66 1017.13 97.20 464.43 4：准备运行算法的数据1234X = data[[\"AT\",\"V\",\"AP\",\"RH\"]]print X.shapey = data[[\"PE\"]]print y.shape 12(9568, 4)(9568, 1) 说明有9658条数据，其中”AT”,”V”,”AP”,”RH” 四列作为样本特征，”PE”列作为样本输出。 5：划分训练集和测试集12345678from sklearn.cross_validation import train_test_split# 划分训练集和测试集X_train,X_test,y_train,y_test = train_test_split(X,y,random_state=1)print X_train.shapeprint y_train.shapeprint X_test.shapeprint y_test.shape 1234(7176, 4)(7176, 1)(2392, 4)(2392, 1) 75%的数据被划分为训练集，25的数据划分为测试集。 6：运行sklearn 线性模型12345678from sklearn.linear_model import LinearRegressionlinreg = LinearRegression()linreg.fit(X_train,y_train)# 训练模型完毕，查看结果print linreg.intercept_print linreg.coef_ 12[ 447.06297099][[-1.97376045 -0.23229086 0.0693515 -0.15806957]] 即我们得到的模型结果为： PE = 447.06297099 - 1.97376045*AT - 0.23229086*V + 0.0693515*AP -0.15806957*RH 7：模型评价我们需要评价模型的好坏，通常对于线性回归来讲，我么一般使用均方差（MSE，Mean Squared Error）或者均方根差（RMSE，Root Mean Squared Error）来评价模型的好坏 123456y_pred = linreg.predict(X_test)from sklearn import metrics# 使用sklearn来计算mse和Rmseprint \"MSE:\",metrics.mean_squared_error(y_test, y_pred)print \"RMSE:\",np.sqrt(metrics.mean_squared_error(y_test, y_pred)) 12MSE: 20.0804012021RMSE: 4.48111606657 得到了MSE或者RMSE，如果我们用其他方法得到了不同的系数，需要选择模型时，就用MSE小的时候对应的参数。 8：交叉验证我们可以通过交叉验证来持续优化模型，代码如下，我们采用10折交叉验证，即cross_val_predict中的cv参数为10： 12345# 交叉验证from sklearn.model_selection import cross_val_predictpredicted = cross_val_predict(linreg,X,y,cv=10)print \"MSE:\",metrics.mean_squared_error(y, predicted)print \"RMSE:\",np.sqrt(metrics.mean_squared_error(y, predicted)) 12MSE: 20.7955974619RMSE: 4.56021901469 可以看出，采用交叉验证模型的MSE比第6节的大，主要原因是我们这里是对所有折的样本做测试集对应的预测值的MSE，而第6节仅仅对25%的测试集做了MSE。两者的先决条件并不同。 9：画图查看结果12345678# 画图查看结果import matplotlib.pyplot as pltfig, ax = plt.subplots()ax.scatter(y, predicted)ax.plot([y.min(), y.max()], [y.min(), y.max()], 'k--', lw=4)ax.set_xlabel('Measured')ax.set_ylabel('Predicted')plt.show() 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"}]},{"title":"回归分析之线性回归（N元线性回归）","slug":"机器学习/回归分析之线性回归（N元线性回归）","date":"2017-09-29T08:45:14.000Z","updated":"2019-10-14T06:42:35.684Z","comments":true,"path":"2017/09/29/机器学习/回归分析之线性回归（N元线性回归）/","link":"","permalink":"http://thinkgamer.cn/2017/09/29/机器学习/回归分析之线性回归（N元线性回归）/","excerpt":"在上一篇文章中我们介绍了 回归分析之理论篇，在其中我们有聊到线性回归和非线性回归，包括广义线性回归，这一篇文章我们来聊下回归分析中的线性回归。","text":"在上一篇文章中我们介绍了 回归分析之理论篇，在其中我们有聊到线性回归和非线性回归，包括广义线性回归，这一篇文章我们来聊下回归分析中的线性回归。 一元线性回归预测房价： 输入编号 平方米 价格 1 150 6450 2 200 7450 3 250 8450 4 300 9450 5 350 11450 6 400 15450 7 600 18450 针对上边这种一元数据来讲，我们可以构建的一元线性回归函数为 H(x) = k*x + b其中H(x)为平方米价格表，k是一元回归系数，b为常数。最小二乘法的公式： k =\\frac{ \\sum_{1}^{n} (x_{i} - \\bar{x} )(y_{i} - \\bar{y}) } { \\sum_{1}^{n}(x_{i}-\\bar{x})^{2} }自己使用python代码实现为：123456789101112131415161718def leastsq(x,y): \"\"\" x,y分别是要拟合的数据的自变量列表和因变量列表 \"\"\" meanX = sum(x) * 1.0 / len(x) # 求x的平均值 meanY = sum(y) * 1.0 / len(y) # 求y的平均值 xSum = 0.0 ySum = 0.0 for i in range(len(x)): xSum += (x[i] - meanX) * (y[i] - meanY) ySum += (x[i] - meanX) ** 2 k = ySum/xSum b = ySum - k * meanX return k,b 使用python的scipy包进行计算:12345678910111213141516171819202122232425262728leastsq(func, x0, args=(), Dfun=None, full_output=0, col_deriv=0, ftol=1.49012e-08, xtol=1.49012e-08, gtol=0.0, maxfev=0, epsfcn=None, factor=100, diag=None)from scipy.optimize import leastsqimport numpy as npdef fun(p, x): \"\"\" 定义想要拟合的函数 \"\"\" k,b = p # 从参数p获得拟合的参数 return k*x + bdef err(p, x, y): return fun(p,x) - y#定义起始的参数 即从 y = 1*x+1 开始，其实这个值可以随便设，只不过会影响到找到最优解的时间p0 = [1,1]#将list类型转换为 numpy.ndarray 类型，最初我直接使用#list 类型,结果 leastsq函数报错，后来在别的blog上看到了，原来要将类型转#换为numpy的类型x1 = np.array([150,200,250,300,350,400,600])y1 = np.array([6450,7450,8450,9450,11450,15450,18450])xishu = leastsq(err, p0, args=(x1,y1))print xishu[0] 当然python的leastsq函数不仅仅局限于一元一次的应用，也可以应用到一元二次，二元二次，多元多次等，具体可以看下这篇博客：http://www.cnblogs.com/NanShan2016/p/5493429.html 多元线性回归总之：我们可以用python leastsq函数解决几乎所有的线性回归的问题了，比如说 y = a * x^2 + b * x + cy = a * x_1^2 + b * x_1 + c * x_2 + dy = a * x_1^3 + b * x_1^2 + c * x_1 + d在使用时只需把参数列表和 fun 函数中的return 换一下，拿以下函数举例 y = a * x_1^2 + b * x_1 + c * x_2 + d对应的python 代码是：12345678910111213141516171819202122232425262728from scipy.optimize import leastsqimport numpy as npdef fun(p, x1, x2): \"\"\" 定义想要拟合的函数 \"\"\" a,b,c,d = p # 从参数p获得拟合的参数 return a * (x1**2) + b * x1 + c * x2 + ddef err(p, x1, x2, y): return fun(p,x1,x2) - y#定义起始的参数 即从 y = 1*x+1 开始，其实这个值可以随便设，只不过会影响到找到最优解的时间p0 = [1,1,1,1]#将list类型转换为 numpy.ndarray 类型，最初我直接使用#list 类型,结果 leastsq函数报错，后来在别的blog上看到了，原来要将类型转#换为numpy的类型x1 = np.array([150,200,250,300,350,400,600]) # 面积x2 = np.array([4,2,7,9,12,14,15]) # 楼层y1 = np.array([6450,7450,8450,9450,11450,15450,18450]) # 价格/平方米xishu = leastsq(err, p0, args=(x1,x2,y1))print xishu[0] sklearn中的线性回归应用普通最小二乘回归这里我们使用的是sklearn中的linear_model来模拟y=a * x_1 + b * x_2 + c 1234567891011121314151617In [1]: from sklearn.linear_model import LinearRegressionIn [2]: linreg = LinearRegression()In [3]: linreg.fit([[0, 0], [1, 1], [2, 2]], [0, 1, 2])In [4]: linreg.coef_Out[4]: array([ 0.5, 0.5])In [5]: linreg.intercept_Out[5]: 1.1102230246251565e-16In [6]: linreg.predict([4,4])Out[6]: array([ 4.])In [7]: zip([\"x1\",\"x2\"], linreg.coef_)Out[7]: [('x1', 0.5), ('x2', 0.49999999999999989)] 所以可得y = 0.5 * x_1 + 0.5 * x_2 + 1.11e-16 linreg.coef_ 为系数 a,b linreg.intercept_ 为截距 c 缺点：因为系数矩阵x与它的转置矩阵相乘得到的矩阵不能求逆，导致最小二乘法得到的回归系数不稳定，方差很大。 多项式回归：基函数扩展线性模型机器学习中一种常见的模式是使用线性模型训练数据的非线性函数。这种方法保持了一般快速的线性方法的性能，同时允许它们适应更广泛的数据范围。 例如，可以通过构造系数的多项式特征来扩展一个简单的线性回归。在标准线性回归的情况下，你可能有一个类似于二维数据的模型： y(w,x) = w_{0} + w_{1} x_{1} + w_{2} x_{2}如果我们想把抛物面拟合成数据而不是平面，我们可以结合二阶多项式的特征，使模型看起来像这样: y(w,x) = w_{0} + w_{1} x_{1} + w_{2} x_{2} + w_{3} x_{1}x_{2} + w_{4} x_{1}^2 + w_{5} x_{2}^2我们发现，这仍然是一个线性模型，想象着创建一个新变量： z = [x_{1},x_{2},x_{1} x_{2},x_{1}^2,x_{2}^2]可以把线性回归模型写成下边这种形式： y(w,x) = w_{0} + w_{1} z_{1} + w_{2} z_{2} + w_{3} z_{3} + w_{4} z_{4} + w_{5} z_{5}我们看到，所得的多项式回归与我们上面所考虑的线性模型相同（即模型在W中是线性的），可以用同样的方法来求解。通过考虑在用这些基函数建立的高维空间中的线性拟合，该模型具有灵活性，可以适应更广泛的数据范围。 使用如下代码，将二维数据进行二元转换,转换规则为： [x_1, x_2] => [1, x_1, x_2, x_1^2, x_1 x_2, x_2^2]12345678910111213141516171819In [15]: from sklearn.preprocessing import PolynomialFeaturesIn [16]: import numpy as npIn [17]: X = np.arange(6).reshape(3,2)In [18]: XOut[18]: array([[0, 1], [2, 3], [4, 5]])In [19]: poly = PolynomialFeatures(degree=2)In [20]: poly.fit_transform(X)Out[20]: array([[ 1., 0., 1., 0., 0., 1.], [ 1., 2., 3., 4., 6., 9.], [ 1., 4., 5., 16., 20., 25.]]) 验证：1234567891011121314151617181920212223242526In [38]: from sklearn.preprocessing import PolynomialFeaturesIn [39]: from sklearn.linear_model import LinearRegressionIn [40]: from sklearn.pipeline import PipelineIn [41]: import numpy as npIn [42]: In [42]: model = Pipeline( [ (\"poly\",PolynomialFeatures(degree=3)),(\"linear\",LinearRegression(fit_intercept=False)) ] )In [43]: modelOut[43]: Pipeline(steps=[('poly', PolynomialFeatures(degree=3, include_bias=True, interaction_only=False)), ('linear', LinearRegression(copy_X=True, fit_intercept=False, n_jobs=1, normalize=False))])In [44]: x = np.arange(5)In [45]: y = 3 - 2 * x + x ** 2 - x ** 3In [46]: yOut[46]: array([ 3, 1, -5, -21, -53])In [47]: model = model.fit(x[:,np.newaxis],y)In [48]: model.named_steps['linear'].coef_Out[48]: array([ 3., -2., 1., -1.]) 我们可以看出最后求出的参数和一元三次方程是一致的。 这里如果把degree改为2，y的方程也换一下，结果也是一致的123456789101112131415161718In [51]: from sklearn.linear_model import LinearRegressionIn [52]: from sklearn.preprocessing import PolynomialFeaturesIn [53]: from sklearn.pipeline import PipelineIn [54]: import numpy as npIn [55]: model = Pipeline( [ (\"poly\",PolynomialFeatures(degree=2)),(\"linear\",LinearRegression(fit_intercept=False)) ] )In [56]: x = np.arange(5)In [57]: y = 3 + 2 * x + x ** 2In [58]: model = model.fit(x[:, np.newaxis], y)In [59]: model.named_steps['linear'].coef_Out[59]: array([ 3., 2., 1.]) 线性回归的评测在上一篇文章中我们聊到了回归模型的评测方法，解下来我们详细聊聊如何来评价一个回归模型的好坏。 这里我们定义预测值和真实值分别为：12true = [10, 5, 3, 2]pred = [9, 5, 5, 3] 1: 平均绝对误差（Mean Absolute Error, MAE） \\frac{1}{N}(\\sum_{1}^{n} |y_i - \\bar{y}|)2: 均方误差（Mean Squared Error, MSE） \\frac{1}{N}\\sum_{1}^{n}(y_i - \\bar{y})^23: 均方根误差（Root Mean Squared Error, RMSE） \\frac{1}{N} \\sqrt{ \\sum_{1}^{n}(y_i - \\bar{y})^2 }12345678910111213141516171819202122232425In [80]: from sklearn import metricsIn [81]: import numpy as npIn [82]: true = [10, 5, 3, 2]In [83]: pred = [9, 5, 5, 3]In [84]: print(\"MAE: \", metrics.mean_absolute_error(true,pred))('MAE: ', 1.0)In [85]: print(\"MAE By Hand: \", (1+0+2+1)/4.)('MAE By Hand: ', 1.0)In [86]: print(\"MSE: \", metrics.mean_squared_error(true,pred))('MSE: ', 1.5)In [87]: print(\"MSE By Hand: \", (1 ** 2 + 0 ** 2 + 2 ** 2 + 1 ** 2 ) / 4.)('MSE By Hand: ', 1.5)In [88]: print(\"RMSE: \", np.sqrt(metrics.mean_squared_error(true,pred)))('RMSE: ', 1.2247448713915889)In [89]: print(\"RMSE By Hand: \", np.sqrt((1 ** 2 + 0 ** 2 + 2 ** 2 + 1 ** 2 ) / 4.))('RMSE By Hand: ', 1.2247448713915889) 总结线性回归在现实中还是可以解决很多问题的，但是并不是万能的，后续我会继续整理逻辑回归，岭回归等相关回归的知识，如果你感觉有用，欢迎分享！ 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"}]},{"title":"几种距离计算公式在数据挖掘中的应用场景分析","slug":"机器学习/几种距离计算公式在数据挖掘中的应用场景分析","date":"2017-09-20T02:23:39.000Z","updated":"2019-10-14T06:42:35.683Z","comments":true,"path":"2017/09/20/机器学习/几种距离计算公式在数据挖掘中的应用场景分析/","link":"","permalink":"http://thinkgamer.cn/2017/09/20/机器学习/几种距离计算公式在数据挖掘中的应用场景分析/","excerpt":"本文涉及以下几种距离计算公式的分析，参考资料为《面向程序员的数据挖掘指南》 曼哈顿距离 欧几里得距离 闵可夫斯基距离 皮尔逊相关系数 余弦相似度","text":"本文涉及以下几种距离计算公式的分析，参考资料为《面向程序员的数据挖掘指南》 曼哈顿距离 欧几里得距离 闵可夫斯基距离 皮尔逊相关系数 余弦相似度 之前整理过一篇关于距离相关的文章：机器学习算法中的距离和相似性计算公式，分析以及python实现 闵可夫斯基距离两个n维变量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的闵可夫斯基距离定义为： \\sqrt[p]{ \\sum_{k=1}^{n} \\left | x_{1k}-x_{2k} \\right |^p}其中p是一个变参数。 当p=1时，就是曼哈顿距离 当p=2时，就是欧氏距离 当p→∞时，就是切比雪夫距离 根据变参数的不同，闵氏距离可以表示一类的距离。 p值越大，单个维度的差值大小会对整体距离有更大的影响 曼哈顿距离／欧几里得距离的瑕疵在《面向程序员的数据挖掘指南》中给出了这样一组样例数据, 下图为一个在线音乐网站的的用户评分情况，用户可以用1-5星来评价一个乐队，下边是8位用户对8个乐队的评价： 表中的横线表示用户没有对乐队进行评价，我们在计算两个用户的距离时，只采用他们都评价过的乐队。 现在来求Angelica和Bill的距离，因为他们共同评分过的乐队有5个，所以使用其对该5个乐队的评分进行曼哈顿距离的计算为： 1Dis_1 = |3.5-2| + |2-3.5| + |5-2| + |1.5-3.5| + |2-3| = 9 同样使用欧式距离计算为：1Dis_2 = sqrt( (3.5-2)^2 + (2-3.5)^2 + (5-2)^2 + (1.5-3.5)^2 + (2-3)^2 ) = 4.3 当对Angelica和Bill，Bill和Chan进行距离对比时，由于两者的共同评分过的乐队均为5，数据都在一个5维空间里，是公平的，如果现在要计算Angelica和Hailey与Bill的距离时，会发现，Angelica与Bill共同评分的有5个乐队，Hailey与Bill共同评分的有3个乐队，也就是说两者数据一个在5维空间里，一个在三维空间里，这样明显是不公平的。这将会对我们进行计算时产生不好的影响，所以曼哈顿距离和欧几里得距离在数据完整的情况下效果最好。 用户问题／皮尔逊相关系数／分数膨胀现象——用户问题仔细观察用户对乐队的评分数据，可以发现每个用户的评分标准不同： Bill没有打出极端的分数，都在2-4分之间 Jordyn似乎喜欢所有的乐队，打分都在4-5之间 Hailey是一个有趣的人，他的评分不是1就是4 那么如何比较这些用户呢？比如说Hailey的4分是相当于Jordyn的4分还是5分呢？我觉得更接近5分，这样一来，就影响推荐系统的准确性了！ 解决该现象解决该现象的办法之一就是 使用皮尔逊相关系数，例如下边这样的数据样例（Clara和Robert对五个乐队的评分）： 这种现象在数据挖掘领域被称为“分数膨胀“。我们将其评分画成图，如下： 一条直线-完全吻合，代表着Clara和Robert的喜好完全一致。 皮尔逊相关系数用于衡量两个变量之间的相关性，他的值在-1～1，1代表完全一致，-1代表完全相悖。所以我们可以利用皮尔逊相关系数来找到相似的用户。 皮尔逊相关系数的计算公式为：该公式除了看起来比较复杂，另外需要对数据进行两次遍历，第一次遍历求出 x平均值和y平均值，第二次遍历才能出现结果，这里提供另外一个计算公式，能够计算皮尔逊相关系数的近似值： 余弦相似度／稀疏数据假设这样一个数据集，一个在线音乐网站，有10000w首音乐（这里不考虑音乐类型，年代等因素），每个用户常听的也就其中的几十首，这种情况下使用曼哈顿或者欧几里得或者皮尔逊相关系数进行计算用户之间相似性，计算相似值会非常小，因为用户之间的交集本来就很少，这样对于计算结果来讲是很不准确的，这个时候就需要余弦相似度了，余弦相似度进行计算时会自动略过这些非零值。 总结这里只是简答的介绍了这几种相似性距离度量的方法和场景，但是在实际环境中远比这个复杂许多。这里总结下： 如果数据存在“分数膨胀“问题，就使用皮尔逊相关系数 如果数据比较密集，变量之间基本都存在共有值，且这些距离数据都是非常重要的，那就使用欧几里得或者曼哈顿距离 如果数据是稀疏的，就使用余弦相似度 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"距离计算","slug":"距离计算","permalink":"http://thinkgamer.cn/tags/距离计算/"},{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"}]},{"title":"机器学习中非常有名的理论或定理你知道几个","slug":"机器学习/机器学习中非常有名的理论或定理你知道几个","date":"2017-09-20T02:23:39.000Z","updated":"2019-10-14T06:42:35.686Z","comments":true,"path":"2017/09/20/机器学习/机器学习中非常有名的理论或定理你知道几个/","link":"","permalink":"http://thinkgamer.cn/2017/09/20/机器学习/机器学习中非常有名的理论或定理你知道几个/","excerpt":"在机器学习中,有一些非常有名的理论或定理,对理解机器学习的内在特性非常有帮助。 PCA学习理论当使用机器学习算法来解决某个问题时，通常靠经验或者多次实验来得到合适的模型，训练样本数量和相关的参数。但是经验判断成本较高，且不太可靠，因此希望有一套理论能够分析问题，计算模型能力，为算法提供理论保证。这就是计算学习理论（Computational Learning Theory），其中最基础的就是近似正确学习理论（Probably Approximately Coorrect，PCA）。","text":"在机器学习中,有一些非常有名的理论或定理,对理解机器学习的内在特性非常有帮助。 PCA学习理论当使用机器学习算法来解决某个问题时，通常靠经验或者多次实验来得到合适的模型，训练样本数量和相关的参数。但是经验判断成本较高，且不太可靠，因此希望有一套理论能够分析问题，计算模型能力，为算法提供理论保证。这就是计算学习理论（Computational Learning Theory），其中最基础的就是近似正确学习理论（Probably Approximately Coorrect，PCA）。 机器学习中一个很重要的问题就是期望错误与经验错误之间的误差，称为泛化误差（Generalization Error），用来衡量一个机器学习模型能否很好的泛化到未知数据。 根据大数定理，当训练的数据集D接近于无穷大时，泛化错误趋向于0，即经验风险趋向于期望风险。由于我们并不知道真实的数据分布，因此从有限的数据样本学习到一个期望错误为0的模型是很难的，因此需要降低对模型的期望，只要求学习到的模型能够以一定的概率学习到一个近似正确的假设，这就是PCA学习理论。 PCA学习理论包含了两部分：近似正确和可能。 没有免费午餐定理没有免费午餐定理（No Free Lunch Theorem，NFL）是由Wolpert和Macerday在最优化理论中提出的，NFL证明：对于基于迭代的最优化算法不会存在某种算法对所有问题（有限的搜索空间内）都有效。如果一个算法对某些问题有效，那么他一定在另一些问题上比纯随机搜索算法更差。也就是说，不能脱离具体问题来讨论算法的优劣，任何算法都有优劣性，必须要“具体问题具体分析”。 丑小鸭定理丑小鸭定理（Ugly Duckling Theorem）是1969年由渡边慧提出的[Watan-able, 1969]。“丑小鸭与白天鹅之间的区别和两只白天鹅之间的区别一样大”。这个定理初看好像不符合常识，但是仔细思考后是非常有道理的。因为世界上不存在相似性的客观标准，一切相似性的标准都是主观的。如果以体型大小的角度来看，丑小鸭和白天鹅的区别大于两只白天鹅的区别；但是如果以基因的角度来看，丑小鸭与它父母的差别要小于他父母和其他白天鹅之间的差别。 奥卡姆剃刀奥卡姆剃刀（Occam’s Razor）是由14世界逻辑学家William of Occam提出的一个解决问题的法则：“如无必要，勿增实体”。 奥卡姆剃刀的思想和机器学习上正则化思想十分相似：简答的模型泛化能力更好。如果有两个性能相近的模型，我们更倾向于选择简单的模型。因此在机器学习准则上，我们经常会引入参数正则化（比如L2正则）来限制模型能力，避免过拟合。 这里需要区分下L1正则和L2正则的区别，如果需要小编回答，可在评论区留言！ 奥卡姆剃刀的一种形式化是最小描述长度（Minimum Description Length, MDL）原则，即对一个数据集D，最好的模型f属于F是会使得数据集的压缩效果最好，即编码长度最小。 最小描述长度也可以通过贝叶斯学习的观点来解释，模型 f 在数据集 D 上的对数后验概率为： \\underset{f}{max\\log p(f|D)} = \\underset{f}{max\\log p(D|f)} + logp(f) = \\underset{f}{min}-log \\ p(D|f) - log \\ p(f)其中 -log p(f)和-log p(D|f)可以分别看作是模型f的编码长度和在该模型下数据集D的编码长度，也就是说我们不但要使得模型f可以编码数据集D，也要使模型f尽可能的简单。 归纳偏置在机器学习中，很多算法会对学习的问题做一些假设，这些假设就称为归纳偏置（Inductive Bias）。比如在最近邻分类器中，我们会假设在特征空间内，一个小的局部区域中的大部分样本都属于同一类。在朴素贝叶斯分类器中，我们会假设每个特征的条件概率是相互独立的。 归纳偏置在贝叶斯学习中也成为先验（priors）。 大数定理假设X1,X2,….是独立同分布的随机变量，记他们的均值为 $\\mu$，方差为：$\\sigma ^2$,则对于任意的正数$\\varepsilon$，有 \\displaystyle \\lim_{ n \\to \\infty } P(| \\bar{X}_n - \\mu| \\geq \\varepsilon) = 0我们通常对数据进行抽样估计利用的则是大数定理思想。 中心极限定理中心极限定理是研究独立随机变量和的极限分布为正态分布的命题。经过科学家长期的观察和总结，发现服从正态分布的随机现象往往是由独立(或弱相依)的随机变量产生的。 这类随机现象往往可视为独立随机变量之和 \\sum_{i=1}^{n} x_i在什么条件下渐进于正态分布的问题。为使问题规范化，数学家们将问题归结为讨论规范和 \\frac{\\sum_{i=1}^{n}x_i - E(\\sum_{i=1}^{n}x_i ) }{\\sqrt {D(\\sum_{i=1}^{n}x_i )} }有渐进分布N(0,1)的条件，并称有此结论的随机序列{x_n}服从中心极限定理。即： \\frac{\\sum_{i=1}^{n}x_i - E(\\sum_{i=1}^{n}x_i ) }{\\sqrt {D(\\sum_{i=1}^{n}x_i )} } \\sim N(0,1)独立同分布的中心极限定理和德莫佛-拉普拉斯中心极限定理参考： https://blog.csdn.net/baishuiniyaonulia/article/details/83998635 【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"}]},{"title":"回归分析之理论篇","slug":"机器学习/回归分析之理论篇","date":"2017-09-17T00:10:27.000Z","updated":"2019-10-14T06:42:35.684Z","comments":true,"path":"2017/09/17/机器学习/回归分析之理论篇/","link":"","permalink":"http://thinkgamer.cn/2017/09/17/机器学习/回归分析之理论篇/","excerpt":"2015年的机器学习博客其实都是看《机器学习实战》这本书时学到的，说实话当时也是知其然，不知其所以然，以至于对其理解不深刻，好多细节和理论知识都搞的是乱七八糟，自从工作之后再去看一个算法，思考的比之前多了点，查看资料也比之前多了点，生怕理解错误，影响其他人，当然在理解的程度上还是不够深刻，这也是一个学习的过程吧，记录一下，欢迎指正。","text":"2015年的机器学习博客其实都是看《机器学习实战》这本书时学到的，说实话当时也是知其然，不知其所以然，以至于对其理解不深刻，好多细节和理论知识都搞的是乱七八糟，自从工作之后再去看一个算法，思考的比之前多了点，查看资料也比之前多了点，生怕理解错误，影响其他人，当然在理解的程度上还是不够深刻，这也是一个学习的过程吧，记录一下，欢迎指正。 CSDN链接：点击阅读 一：一些名词定义1）指数分布族指数分布族是指可以表示为指数形式的概率分布。 f_X(x\\mid\\theta) = h(x) \\exp \\left (\\eta(\\theta) \\cdot T(x) -A(\\theta)\\right )其中，η为自然参数(nature parameter)，T(x)是充分统计量（sufficient statistic）。当参数A，h，T都固定以后，就定义了一个以η为参数的函数族。 伯努利分布与高斯分布是两个典型的指数分布族 伯努利分布又名两点分布或者0-1分布，是一个离散型概率分布。假设1的概率为p，0的概率为q，则其概率质量函数为：1&#123;\\displaystyle f_&#123;X&#125;(x)=p^&#123;x&#125;(1-p)^&#123;1-x&#125;=\\left\\&#123;&#123;\\begin&#123;matrix&#125;p&amp;&#123;\\mbox&#123;if &#125;&#125;x=1,\\\\q\\ &amp;&#123;\\mbox&#123;if &#125;&#125;x=0.\\\\\\end&#123;matrix&#125;&#125;\\right.&#125; 其期望值为： {\\displaystyle \\operatorname {E} [X]=\\sum _{i=0}^{1}x_{i}f_{X}(x)=0+p=p}其方差为： {\\displaystyle \\operatorname {var} [X]=\\sum _{i=0}^{1}(x_{i}-E[X])^{2}f_{X}(x)=(0-p)^{2}(1-p)+(1-p)^{2}p=p(1-p)=pq}正态分布(高斯分布)若随机变量X服从一个位置参数为 ${\\displaystyle \\mu }$ 、尺度参数为 ${\\displaystyle \\sigma } $ 的概率分布，记为： X \\sim N(\\mu,\\sigma^2),其概率密度函数为:1f(x) = &#123;1 \\over \\sigma\\sqrt&#123;2\\pi&#125; &#125;\\,e^&#123;- &#123;&#123;(x-\\mu )^2 \\over 2\\sigma^2&#125;&#125;&#125; 正态分布的数学期望值或期望值$ {\\displaystyle \\mu } $ 等于位置参数，决定了分布的位置；其方差 $ {\\displaystyle \\sigma ^{2}} $ 的开平方或标准差$ {\\displaystyle \\sigma }$ 等于尺度参数，决定了分布的幅度。 标准正态分布：如果$ {\\displaystyle \\mu =0} $ 并且 $ {\\displaystyle \\sigma =1} $ 则这个正态分布称为标准正态分布。简化为：1f(x) = \\frac&#123;1&#125;&#123;\\sqrt&#123;2\\pi&#125;&#125; \\, \\exp\\left(-\\frac&#123;x^2&#125;&#123;2&#125; \\right) 如下图所示： 正态分布中一些值得注意的量： 密度函数关于平均值对称 平均值与它的众数（statistical mode）以及中位数（median）同一数值。 函数曲线下68.268949%的面积在平均数左右的一个标准差范围内。 95.449974%的面积在平均数左右两个标准差 $ {\\displaystyle 2\\sigma } $ 的范围内。 99.730020%的面积在平均数左右三个标准差$ {\\displaystyle 3\\sigma } $ 的范围内。 99.993666%的面积在平均数左右四个标准差$ {\\displaystyle 4\\sigma } $ 的范围内。 函数曲线的反曲点（inflection point）为离平均数一个标准差距离的位置。 2）多重共线性和完全共线性多重共线性：指线性回归模型中的解释变量之间由于存在精确相关关系或高度相关关系而使模型估计失真或难以估计准确。一般来说，由于经济数据的限制使得模型设计不当，导致设计矩阵中解释变量间存在普遍的相关关系。通俗点理解就是自变量里边有一些是打酱油的，可以由另外一些变量推导出来，当变量中存在大量的多重共线性变量就会导致模型误差很大，这个时候就需要从自变量中将“打酱油”的变量给剔除掉。 完全共线性：在多元回归中，一个自变量是一个或多个其他自变量的线性函数。 两者在某种特殊情况下是有交集的。 3）T检验T检验又叫student T 检验，主要用于样本含量小，总标准差 $\\sigma$ 未知的正太分布数据。T检验是用于小样本的两个平均值差异程度的检查方法，他是用T分布理论值来推断事件发生的概率，从而判断两个平均数的差异是否显著。参考: http://blog.csdn.net/shulixu/article/details/53354206 4）关系 函数关系 确定性关系，y=3+2x 相关关系 非确定性关系，比如说高中时数学成绩好的人，一般物理成绩也好，这是因为它们背后使用的都是数学逻辑，这种酒叫做非确定性关系。 5）虚拟变量定义： 又称虚设变量、名义变量或哑变量，用以反映质的属性的一个人工变量，是量化了的自变量，通常取值为0或1。（通常为离散变量，因子变量） 作用： 引入哑变量可使线形回归模型变得更复杂，但对问题描述更简明，一个方程能达到两个方程的作用，而且接近现实。 设置： 例如：体重（w）和身高（h），性别（s）的关系，但这里性别并非连续的或者数字可以表示的变量，你并不能拿 1表示男，2表示女，这里的性别是离散变量，只能为男或者女，所以这里就需要引入哑变量来处理。性别（s） =》 isman（男1，非男0），iswoman （因为只有两种可能，所以这里只需要引入一个哑变量即可），同理假设这里有另外一个变量肤色（有黑，白，黄三种可能），那么这里只需引入两个哑变量即可（isblack，iswhite），因为不是这两种的话那肯定是黄色皮肤了。 例子：针对上边所说的体重和身高，性别的关系。 构建模型： 1）加法模型1w = a + b * h + c * isman 针对数据样本而言，性别是确定的，所以 c * isman 的结果不是c就是0，所以在加法模型下，影响的是模型在y轴上的截距。这说明的是针对不同的性别而言，回归方程是平衡的，只不过是截距不一样。 2）乘法模型1w = a + b * h + c * isman * h + d * iswoman * h 同样针对数据样本而言，性别也是确定的，假设一个男性，isman 为1，iswoman 为0，则上述模型变成了 w = a + bh + c h =a + (b+c) * h，这个时候就是在y轴上的截距一样，而斜率不一致。 3）混合模型1w = a + b * h + c * isman + d * iswoman + e * isman * h + f * iswoman * h 假设一个针对一个性别为男的样本数据，该模型变可以变成 w = a + bh + c + e h = a +c + (b+e)*h，这个时候斜率和截距都是不一样的。 二：什么是回归（分析）回归就是利用样本（已知数据），产生拟合方程，从而（对未知数据）进行预测。比如说我有一组随机变量X（X1，X2，X3…）和另外一组随机变量Y（Y1，Y2，Y3…）,那么研究变量X与Y之间的统计学方法就叫做回归分析。当然这里X和Y是单一对应的，所以这里是一元线性回归。 回归分为线性回归和非线性回归，其中一些非线性回归可以用线性回归的方法来进行分析的叫做==广义线性回归==，接下来我们来了解下每一种回归： 1）线性回归线性回归可以分为一元线性回归和多元线性回归。当然线性回归中自变量的指数都是1，这里的线性并非真的是指用一条线将数据连起来，也可以是一个二维平面，三维平面等。 一元线性回归：自变量只有一个的回归，比如说北京二环的房子面积（Area）和房子总价（Money）的关系，随着面积（Area）的增大，房屋价格也是不断增长。这里的自变量只有面积，所以这里是一元线性回归。 多元线性回归：自变量大于等于两个，比如说北京二环的房子面积（Area），楼层（floor）和房屋价格（Money）的关系，这里自变量是两个，所以是二元线性回归，三元，多元同理。 2）非线性回归有一类模型，其回归参数不是线性的，也不能通过转换的方法将其变为线性的参数，这类模型称为非线性回归模型。非线性回归可以分为一元回归和多元回归。非线性回归中至少有一个自变量的指数不为1。回归分析中，当研究的因果关系只涉及因变量和一个自变量时，叫做一元回归分析；当研究的因果关系涉及因变量和两个或两个以上自变量时，叫做多元回归分析。 3）广义线性回归一些非线性回归可以用线性回归的方法来进行分析叫做广义线性回归。典型的代表是Logistic回归。 4）如何衡量相关关系既判断适不适合使用线性回归模型？使用相关系数（-1，1），绝对值越接近于1，相关系数越高，越适合使用线性回归模型（Rxy&gt;0,代表正相关，Rxy&lt;0,代表负相关） r_{XY} = \\frac{ \\sum (X_{i}-\\bar{X})(Y_{i}-\\bar{Y}) }{ \\sqrt{ \\sum (X_{i}-\\bar{X})^2) \\sum (Y_{i}-\\bar{Y})^2) } }三：回归中困难点1）选定变量 假设自变量特别多，有一些是和因变量相关的，有一些是和因变量不相关的，这里我们就需要筛选出有用的变量，如果筛选后变量还特别多的话，可以采用降维的方式进行变量缩减（可以参考之前的PCA降维的文章：http://blog.csdn.net/gamer_gyt/article/details/51418069 ，基本是整理《机器学习实战》这本书的笔记） 2）发现多重共线性(1).方差扩大因子法( VIF) 一般认为如果最大的VIF超过10，常常表示存在多重共线性。 (2).容差容忍定法 如果容差（tolerance）&lt;=0.1，常常表示存在多重共线性。 (3). 条件索引 条件索引(condition index)&gt;10，可以说明存在比较严重的共线性 3）过拟合与欠拟合问题过拟合和欠拟合其实对每一个模型来讲都是存在的，过拟合就是模型过于符合训练数据的趋势，欠拟合就是模型对于训练数据和测试数据都表现出不好的情况。针对于欠拟合来讲，是很容易发现的，通常不被讨论。 在进行模型训练的时候，算法要进行不断的学习，模型在训练数据和测试数据上的错误都在不断下降，但是，如果学习的时间过长的话，模型在训练数据集上的表现将会继续下降，这是因为模型已经过拟合，并且学习到了训练数据集中不恰当的细节和噪音，同时，测试集上的错误率开始上升，也是模型泛化能力在下降。 这个完美的临界点就在于测试集中的错误率在上升时，此时训练集和测试集上都有良好的表现。通常有两种手段可以帮助你找到这个完美的临界点：重采样方法和验证集方法。 如何限制过拟合？ 过拟合和欠拟合可以导致很差的模型表现。但是到目前为止大部分机器学习实际应用时的问题都是过拟合。过拟合是个问题因为训练数据上的机器学习算法的评价方法与我们最关心的实际上的评价方法，也就是算法在位置数据上的表现是不一样的。当评价机器学习算法时我们有两者重要的技巧来限制过拟合使用重采样来评价模型效能保留一个验证数据集最流行的重采样技术是k折交叉验证。指的是在训练数据的子集上训练和测试模型k次，同时建立对于机器学习模型在未知数据上表现的评估。验证集只是训练数据的子集，你把它保留到你进行机器学习算法的最后才使用。在训练数据上选择和调谐机器学习算法之后，我们在验证集上在对于模型进行评估，以便得到一些关于模型在未知数据上的表现的认知。 4）检验模型是否合理验证目前主要采用如下三类办法：1、拟合优度检验主要有R^2，t检验，f检验等等这三种检验为常规验证，只要在95%的置信度内满足即可说明拟合效果良好。2、预测值和真实值比较主要是差值和比值，一般差值和比值都不超过5%。3、另外的办法GEH方法最为常用。GEH是Geoffrey E. Havers于1970年左右提出的一种模型验证方法，其巧妙的运用一个拟定的公式和标准界定模型的拟合优劣。GEH=(2(M-C)^2/(M+C))^(1/2)其中M是预测值，C是实际观测值如果GEH小于5，认为模型拟合效果良好，如果GEH在5-10之间，必须对数据不可靠需要进行检查，如果GEH大于10，说明数据存在问题的几率很高。http://blog.sina.com.cn/s/blog_66188c300100hl45.html 5）线性回归的模型评判 误差平方和（残差平方和） 例如二维平面上的一点（x1，y1），经过线性回归模型预测其值为 y_1，那么预测模型的好与坏就是计算预测结果到直线的距离的大小，由于是一组数据，那么便是这一组数据的和。 点到直线的距离公式为： \\frac{\\left | A_{x_{0}}+B_{y_{0}} +C \\right |}{\\sqrt{A^2 + B^2 }}由于涉及到开方，在计算过程中十分不方便，所以这里转换为纵轴上的差值，即利用预测值与真实值的差进行累加求和，最小时即为最佳的线性回归模型，但是这里涉及到预测值与真实值的差可能为负数，所以这里用平方，所以最终的误差平方和为： RSS = \\sum_{i=1}^{n}(y_{i}- \\hat{y_{i}} )^2 = \\sum_{i=1}^{n}[y_{i} - (\\alpha +\\beta x_{i})]^2 AIC准则（赤池信息准则） AIC=n ln (RSSp/n)+2pn为变量总个数，p为选出的变量个数，AIC越小越好 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"},{"name":"线性回归","slug":"线性回归","permalink":"http://thinkgamer.cn/tags/线性回归/"},{"name":"正态分布","slug":"正态分布","permalink":"http://thinkgamer.cn/tags/正态分布/"}]},{"title":"数据归一化和其在sklearn中的处理","slug":"特征工程/数据归一化和其在sklearn中的处理","date":"2017-09-01T03:33:50.000Z","updated":"2019-10-14T06:42:35.690Z","comments":true,"path":"2017/09/01/特征工程/数据归一化和其在sklearn中的处理/","link":"","permalink":"http://thinkgamer.cn/2017/09/01/特征工程/数据归一化和其在sklearn中的处理/","excerpt":"本文主要介绍数据归一化和其在sklearn中的处理。","text":"本文主要介绍数据归一化和其在sklearn中的处理。 一：数据归一化数据归一化（标准化）处理是数据挖掘的一项基础工作，不同评价指标往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。 归一化方法有两种形式，一种是把数变为（0，1）之间的小数，一种是把有量纲表达式变为无量纲表达式。在机器学习中我们更关注的把数据变到0～1之间，接下来我们讨论的也是第一种形式。 1）min-max标准化min-max标准化也叫做离差标准化，是对原始数据的线性变换，使结果落到[0,1]区间，其对应的数学公式如下： X_{scale} = \\frac{x-min}{max-min}对应的python实现为123# x为数据 比如说 [1,2,1,3,2,4,1]def Normalization(x): return [(float(i)-min(x))/float(max(x)-min(x)) for i in x] 如果要将数据转换到[-1,1]之间，可以修改其数学公式为： X_{scale} = \\frac{x-x_{mean}}{max-min}x_mean 表示平均值。 对应的python实现为12345import numpy as np# x为数据 比如说 [1,2,1,3,2,4,1]def Normalization(x): return [(float(i)-np.mean(x))/float(max(x)-min(x)) for i in x] 其中max为样本数据的最大值，min为样本数据的最小值。这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。 该标准化方法有一个缺点就是，如果数据中有一些偏离正常数据的异常点，就会导致标准化结果的不准确性。比如说一个公司员工（A，B，C，D）的薪水为6k,8k,7k,10w,这种情况下进行归一化对每个员工来讲都是不合理的。 当然还有一些其他的办法也能实现数据的标准化。 2）z-score标准化z-score标准化也叫标准差标准化，代表的是分值偏离均值的程度，经过处理的数据符合标准正态分布，即均值为0，标准差为1。其转化函数为 X_{scale} = \\frac{x-\\mu }{\\sigma }其中μ为所有样本数据的均值，σ为所有样本数据的标准差。 其对应的python实现为：12345import numpy as np#x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]def z_score(x): return (x - np.mean(x) )/np.std(x, ddof = 1) z-score标准化方法同样对于离群异常值的影响。接下来看一种改进的z-score标准化方法。 3）改进的z-score标准化将标准分公式中的均值改为中位数，将标准差改为绝对偏差。 X_{scale} = \\frac{x-x_{center} }{\\sigma_{1} }中位数是指将所有数据进行排序，取中间的那个值，如数据量是偶数，则取中间两个数据的平均值。 σ1为所有样本数据的绝对偏差,其计算公式为： \\frac{1}{N} \\sum_{1}^{n}|x_{i} - x_{center}| 二：sklearn中的归一化sklearn.preprocessing 提供了一些实用的函数 用来处理数据的维度，以供算法使用。 1）均值-标准差缩放即我们上边对应的z-score标准化。在sklearn的学习中，数据集的标准化是很多机器学习模型算法的常见要求。如果个别特征看起来不是很符合正态分布，那么他们可能为表现不好。 实际上，我们经常忽略分布的形状，只是通过减去整组数据的平均值，使之更靠近数据中心分布，然后通过将非连续数特征除以其标准偏差进行分类。 例如，用于学习算法（例如支持向量机的RBF内核或线性模型的l1和l2正则化器）的目标函数中使用的许多元素假设所有特征都以零为中心并且具有相同顺序的方差。如果特征的方差大于其他数量级，则可能主导目标函数，使估计器无法按预期正确地学习其他特征。 例子：12345678910&gt;&gt;&gt; from sklearn import preprocessing&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.],... [ 2., 0., 0.],... [ 0., 1., -1.]])&gt;&gt;&gt; X_scaled = preprocessing.scale(X_train)&gt;&gt;&gt; X_scaledarray([[ 0. , -1.22474487, 1.33630621], [ 1.22474487, 0. , -0.26726124], [-1.22474487, 1.22474487, -1.06904497]]) 标准化后的数据符合标准正太分布1234&gt;&gt;&gt; X_scaled.mean(axis=0)array([ 0., 0., 0.])&gt;&gt;&gt; X_scaled.std(axis=0)array([ 1., 1., 1.]) 预处理模块还提供了一个实用程序级StandardScaler，它实现了Transformer API来计算训练集上的平均值和标准偏差，以便能够稍后在测试集上重新应用相同的变换。1234567891011&gt;&gt;&gt; scaler = preprocessing.StandardScaler().fit(X_train)&gt;&gt;&gt; scalerStandardScaler(copy=True, with_mean=True, with_std=True)&gt;&gt;&gt; scaler.mean_array([ 1. , 0. , 0.33333333])&gt;&gt;&gt; scaler.scale_array([ 0.81649658, 0.81649658, 1.24721913])&gt;&gt;&gt; scaler.transform(X_train)array([[ 0. , -1.22474487, 1.33630621], [ 1.22474487, 0. , -0.26726124], [-1.22474487, 1.22474487, -1.06904497]]) 使用转换器可以对新数据进行转换123&gt;&gt;&gt; X_test = [[-1., 1., 0.]]&gt;&gt;&gt; scaler.transform(X_test)array([[-2.44948974, 1.22474487, -0.26726124]]) 2）min-max标准化X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) 12345678910&gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.],... [ 2., 0., 0.],... [ 0., 1., -1.]])&gt;&gt;&gt; min_max_scaler = preprocessing.MinMaxScaler()&gt;&gt;&gt; X_train_minmax = min_max_scaler.fit_transform(X_train)&gt;&gt;&gt; X_train_minmaxarray([[ 0.5 , 0. , 1. ], [ 1. , 0.5 , 0.33333333], [ 0. , 1. , 0. ]]) 上边我们创建的min_max_scaler 同样适用于新的测试数据1234&gt;&gt;&gt; X_test = np.array([[ -3., -1., 4.]])&gt;&gt;&gt; X_test_minmax = min_max_scaler.transform(X_test)&gt;&gt;&gt; X_test_minmaxarray([[-1.5 , 0. , 1.66666667]]) 可以通过scale_和min方法查看标准差和最小值1234&gt;&gt;&gt; min_max_scaler.scale_ array([ 0.5 , 0.5 , 0.33333333])&gt;&gt;&gt; min_max_scaler.min_array([ 0. , 0.5 , 0.33333333]) 3）最大值标准化对于每个数值／每个维度的最大值 12345678910111213141516&gt;&gt;&gt; X_trainarray([[ 1., -1., 2.], [ 2., 0., 0.], [ 0., 1., -1.]])&gt;&gt;&gt; max_abs_scaler = preprocessing.MaxAbsScaler()&gt;&gt;&gt; X_train_maxabs = max_abs_scaler.fit_transform(X_train)&gt;&gt;&gt; X_train_maxabsarray([[ 0.5, -1. , 1. ], [ 1. , 0. , 0. ], [ 0. , 1. , -0.5]])&gt;&gt;&gt; X_test = np.array([[ -3., -1., 4.]])&gt;&gt;&gt; X_test_maxabs = max_abs_scaler.transform(X_test)&gt;&gt;&gt; X_test_maxabs array([[-1.5, -1. , 2. ]])&gt;&gt;&gt; max_abs_scaler.scale_ array([ 2., 1., 2.]) 4）规范化规范化是文本分类和聚类中向量空间模型的基础 12345678&gt;&gt;&gt; X = [[ 1., -1., 2.],... [ 2., 0., 0.],... [ 0., 1., -1.]]&gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm='l2')&gt;&gt;&gt; X_normalizedarray([[ 0.40824829, -0.40824829, 0.81649658], [ 1. , 0. , 0. ], [ 0. , 0.70710678, -0.70710678]]) 解释：norm 该参数是可选的，默认值是l2（向量各元素的平方和然后求平方根），用来规范化每个非零向量，如果axis参数设置为0，则表示的是规范化每个非零的特征维度。 机器学习中的范数规则：点击阅读其他对应参数：点击查看 preprocessing模块提供了训练种子的功能，我们可通过以下方式得到一个新的种子，并对新数据进行规范化处理。123456789&gt;&gt;&gt; normalizer = preprocessing.Normalizer().fit(X)&gt;&gt;&gt; normalizerNormalizer(copy=True, norm='l2')&gt;&gt;&gt; normalizer.transform(X)array([[ 0.40824829, -0.40824829, 0.81649658], [ 1. , 0. , 0. ], [ 0. , 0.70710678, -0.70710678]])&gt;&gt;&gt; normalizer.transform([[-1,1,0]])array([[-0.70710678, 0.70710678, 0. ]]) 5）二值化将数据转换到0-1 之间123456789&gt;&gt;&gt; X[[1.0, -1.0, 2.0], [2.0, 0.0, 0.0], [0.0, 1.0, -1.0]]&gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X)&gt;&gt;&gt; binarizerBinarizer(copy=True, threshold=0.0)&gt;&gt;&gt; binarizer.transform(X)array([[ 1., 0., 1.], [ 1., 0., 0.], [ 0., 1., 0.]]) 可以调整二值化的门阀12345&gt;&gt;&gt; binarizer = preprocessing.Binarizer(threshold=1.1)&gt;&gt;&gt; binarizer.transform(X)array([[ 0., 0., 1.], [ 1., 0., 0.], [ 0., 0., 0.]]) 6）编码的分类特征通常情况下，特征不是作为连续值给定的。例如一个人可以有1[\"male\", \"female\"], [\"from Europe\", \"from US\", \"from Asia\"], [\"uses Firefox\", \"uses Chrome\", \"uses Safari\", \"uses Internet Explorer\"] 这些特征可以被有效的编码为整数，例如12[\"male\", \"from US\", \"uses Internet Explorer\"] =&gt; [0, 1, 3][\"female\", \"from Asia\", \"uses Chrome\"] would be [1, 2, 1]. 这样的整数不应该直接应用到scikit的算法中，可以通过one-of-k或者独热编码（OneHotEncorder），该种处理方式会把每个分类特征的m中可能值转换成m个二进制值。 123456&gt;&gt;&gt; enc = preprocessing.OneHotEncoder()&gt;&gt;&gt; enc.fit([[0, 0, 3], [1, 1, 0], [0, 2, 1], [1, 0, 2]])OneHotEncoder(categorical_features='all', dtype=&lt;class 'numpy.float64'&gt;, handle_unknown='error', n_values='auto', sparse=True)&gt;&gt;&gt; enc.transform([[0,1,3]]).toarray()array([[ 1., 0., 0., 1., 0., 0., 0., 0., 1.]]) 默认情况下，从数据集中自动推断出每个特征可以带多少个值。可以明确指定使用的参数n_values。在我们的数据集中有两种性别，三种可能的大陆和四种Web浏览器。然后，我们拟合估计量，并转换一个数据点。在结果中，前两个数字编码性别，下一组三个数字的大陆和最后四个Web浏览器。123456&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(n_values=[2,3,4])&gt;&gt;&gt; enc.fit([[1,2,3],[0,2,0]])OneHotEncoder(categorical_features='all', dtype=&lt;class 'numpy.float64'&gt;, handle_unknown='error', n_values=[2, 3, 4], sparse=True)&gt;&gt;&gt; enc.transform([[1,0,0]]).toarray()array([[ 0., 1., 1., 0., 0., 1., 0., 0., 0.]]) 7）填补缺失值由于各种原因，真实数据中存在大量的空白值，这样的数据集，显然是不符合scikit的要求的，那么preprocessing模块提供这样一个功能，利用已知的数据来填补这些空白。12345678910&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; from sklearn.preprocessing import Imputer&gt;&gt;&gt; imp = Imputer(missing_values='NaN',strategy='mean',verbose=0)&gt;&gt;&gt; imp.fit([[1, 2], [np.nan, 3], [7, 6]])Imputer(axis=0, copy=True, missing_values='NaN', strategy='mean', verbose=0)&gt;&gt;&gt; X = [[np.nan, 2], [6, np.nan], [7, 6]]&gt;&gt;&gt; print(imp.transform(X)) [[ 4. 2. ] [ 6. 3.66666667] [ 7. 6. ]] Imputer同样支持稀疏矩阵123456789101112&gt;&gt;&gt; import scipy.sparse as sp&gt;&gt;&gt; X = sp.csc_matrix([[1,2],[0,3],[7,6]])&gt;&gt;&gt; imp = Imputer(missing_values=0,strategy='mean',axis=0)&gt;&gt;&gt; imp.fit(X)Imputer(axis=0, copy=True, missing_values=0, strategy='mean', verbose=0)&gt;&gt;&gt; X_test = sp.cscsp.csc sp.csc_matrix( &gt;&gt;&gt; X_test = sp.csc_matrix([[0,2],[6,0],[7,6]])&gt;&gt;&gt; print(imp.transform(X_test))[[ 4. 2. ] [ 6. 3.66666667] [ 7. 6. ]] 8）生成多项式特征通常，通过考虑输入数据的非线性特征来增加模型的复杂度是很有用的。一个简单而常用的方法是多项式特征，它可以得到特征的高阶和相互作用项。 其遵循的原则是 (X_1, X_2) -> (1, X_1, X_2, X_1^2, X_1X_2, X_2^2)123456789101112&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures&gt;&gt;&gt; X = np.arange(6).reshape(3, 2)&gt;&gt;&gt; X array([[0, 1], [2, 3], [4, 5]])&gt;&gt;&gt; poly = PolynomialFeatures(2)&gt;&gt;&gt; poly.fit_transform(X) array([[ 1., 0., 1., 0., 0., 1.], [ 1., 2., 3., 4., 6., 9.], [ 1., 4., 5., 16., 20., 25.]]) 有些情况下，有相互关系的标签才是必须的，这个时候可以通过设置 interaction_only=True 来进行多项式特征的生成12345678910&gt;&gt;&gt; X = np.arange(9).reshape(3, 3)&gt;&gt;&gt; X array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])&gt;&gt;&gt; poly = PolynomialFeatures(degree=3, interaction_only=True)&gt;&gt;&gt; poly.fit_transform(X) array([[ 1., 0., 1., 2., 0., 0., 2., 0.], [ 1., 3., 4., 5., 12., 15., 20., 60.], [ 1., 6., 7., 8., 42., 48., 56., 336.]]) 其遵循的规则是： (X_1, X_2, X_3) -> (1, X_1, X_2, X_3, X_1X_2, X_1X_3, X_2X_3, X_1X_2X_3) 对应的scikit-learn资料为： http://scikit-learn.org/stable/modules/preprocessing.html 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"特征工程","slug":"特征工程","permalink":"http://thinkgamer.cn/tags/特征工程/"},{"name":"数据归一化","slug":"数据归一化","permalink":"http://thinkgamer.cn/tags/数据归一化/"}]},{"title":"MachingLearning中的距离和相似性计算以及python实现","slug":"机器学习/MachingLearning中的距离和相似性计算以及python实现","date":"2017-07-16T04:14:43.000Z","updated":"2019-10-14T06:42:35.682Z","comments":true,"path":"2017/07/16/机器学习/MachingLearning中的距离和相似性计算以及python实现/","link":"","permalink":"http://thinkgamer.cn/2017/07/16/机器学习/MachingLearning中的距离和相似性计算以及python实现/","excerpt":"写这篇文章的目的不是说摘抄网上其他人的总结，刚才最近在看这方面的东西，为了让自己能够实际的去感受下每种求距离公式的差别，然后用python进行具体实现。","text":"写这篇文章的目的不是说摘抄网上其他人的总结，刚才最近在看这方面的东西，为了让自己能够实际的去感受下每种求距离公式的差别，然后用python进行具体实现。 前言在机器学习中，经常要用到距离和相似性的计算公式，我么要常计算个体之间的差异大小，继而评价个人之间的差异性和相似性，最常见的就是数据分析中的相关分析，数据挖掘中的分类和聚类算法。如利用k-means进行聚类时，判断个体所属的类别，要利用距离计算公式计算个体到簇心的距离，如利用KNN进行分类时，计算个体与已知类别之间的相似性，从而判断个体所属的类别等。 文章编辑的过程中或许存在一个错误或者不合理的地方，欢迎指正。 参考：http://www.cnblogs.com/heaad/archive/2011/03/08/1977733.html 推荐：https://my.oschina.net/hunglish/blog/787596 欧氏距离也称欧几里得距离，是指在m维空间中两个点之间的真实距离。欧式距离在ML中使用的范围比较广，也比较通用，就比如说利用k-Means对二维平面内的数据点进行聚类，对魔都房价的聚类分析（price/m^2 与平均房价）等。 二维空间的欧氏距离二维平面上两点a(x1,y1)与b(x2,y2)间的欧氏距离 d12 =\\sqrt{(x_{1}-x_{2})^2+(y_{1}-y_{2})^2}python 实现为： 123456789# coding: utf-8from numpy import *def twoPointDistance(a,b): d = sqrt( (a[0]-b[0])**2 + (a[1]-b[1])**2 ) return dprint 'a,b 二维距离为：',twoPointDistance((1,1),(2,2)) 三维空间的欧氏距离三维空间两点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离 d12 =\\sqrt{(x_{1}-x_{2})^2+(y_{1}-y_{2})^2+(z_{1}-z_{2})^2}python 实现为：12345def threePointDistance(a,b): d = sqrt( (a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2 ) return dprint 'a,b 三维距离为：',threePointDistance((1,1,1),(2,2,2)) 多维空间的欧氏距离两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离 \\sqrt{\\sum_{n}^{k=1}(x_{1k}-x_{2k})^2 }python 实现为： 1234567def distance(a,b): sum = 0 for i in range(len(a)): sum += (a[i]-b[i])**2 return sqrt(sum)print 'a,b 多维距离为：',distance((1,1,2,2),(2,2,4,4)) 这里传入的参数可以是任意维的，该公式也适应上边的二维和三维 标准欧氏距离标准化欧氏距离是针对简单欧氏距离的缺点而作的一种改进方案。标准欧氏距离的思路：既然数据各维分量的分布不一样，好吧！那我先将各个分量都“标准化”到均值、方差相等吧。均值和方差标准化到多少呢？这里先复习点统计学知识吧，假设样本集X的均值(mean)为m，标准差(standard deviation)为s，那么X的“标准化变量”表示为： 而且标准化变量的数学期望为0，方差为1。因此样本集的标准化过程(standardization)用公式描述就是： X^* = \\frac{X-m}{s}标准化后的值 = ( 标准化前的值 － 分量的均值 ) /分量的标准差 经过简单的推导就可以得到两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的标准化欧氏距离的公式： d_{12} =\\sqrt {\\sum_{k=1}^{n} (\\frac{x_{1k}-x_{2k}}{s_{k}})^2}如果将方差的倒数看成是一个权重，这个公式可以看成是一种加权欧氏距离(Weighted Euclidean distance)。 python 实现为1234567891011def moreBZOSdis(a,b): sumnum = 0 for i in range(len(a)): # 计算si 分量标准差 avg = (a[i]-b[i])/2 si = sqrt( (a[i] - avg) ** 2 + (b[i] - avg) ** 2 ) sumnum += ((a[i]-b[i])/si ) ** 2 return sqrt(sumnum)print 'a,b 标准欧式距离：',moreBZOSdis((1,2,1,2),(3,3,3,4)) 曼哈顿距离又称为城市街区距离（City Block distance）, 想象你在曼哈顿要从一个十字路口开车到另外一个十字路口，驾驶距离是两点间的直线距离吗？显然不是，除非你能穿越大楼。实际驾驶距离就是这个“曼哈顿距离”。而这也是曼哈顿距离名称的来源。同样曼哈顿距离也分为二维，三维和多维。 在计程车几何学中，一个圆是由从圆心向各个固定曼哈顿距离标示出来的点围成的区域，因此这种圆其实就是旋转了45度的正方形。如果有一群圆，且任两圆皆相交，则整群圆必在某点相交；因此曼哈顿距离会形成一个超凸度量空间。 这里有一篇人脸表情分类的论文采用的曼哈顿距离进行计算的，一种人脸表情分类的新方法——Manhattan距离 二维曼哈顿距离二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离 d12 =\\left | x_{1}-x_{2} \\right | + \\left |y_{1}-y_{2} \\right |python实现为1234def twoMHDdis(a,b): return abs(a[0]-b[0])+abs(a[1]-b[1])print 'a,b 二维曼哈顿距离为：', twoMHDdis((1,1),(2,2)) 三维曼哈顿距离三维平面两点a(x1,y1,z1)与b(x2,y2,z2)间的曼哈顿距离 d12 =\\left | x_{1}-x_{2} \\right | + \\left |y_{1}-y_{2} \\right | + \\left |z_{1}-z_{2} \\right |python实现为1234def threeMHDdis(a,b): return abs(a[0]-b[0])+abs(a[1]-b[1]) + abs(a[2]-b[2]) print 'a,b 三维曼哈顿距离为：', threeMHDdis((1,1,1),(2,2,2)) 多维曼哈顿距离多维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离 d12 = \\sum_{k=1}^{n} \\left | x_{1k} - x_{2k} \\right |python实现为1234567def moreMHDdis(a,b): sum = 0 for i in range(len(a)): sum += abs(a[i]-b[i]) return sumprint 'a,b 多维曼哈顿距离为：', moreMHDdis((1,1,1,1),(2,2,2,2)) 由于维距离计算是比较灵活的，所以也同样适合二维和三维。 切比雪夫距离切比雪夫距离（Chebyshev Distance）的定义为：max( | x2-x1 | , |y2-y1 | , … ), 切比雪夫距离用的时候数据的维度必须是三个以上，这篇文章中曼哈顿距离，欧式距离，明式距离，切比雪夫距离区别 给了一个很形象的解释如下：1234567891011比如，有同样两个人，在纽约准备到北京参拜天安门，同一个地点出发的话，按照欧式距离来计算，是完全一样的。但是按照切比雪夫距离，这是完全不同的概念了。譬如，其中一个人是土豪，另一个人是中产阶级，第一个人就能当晚直接头等舱走人，而第二个人可能就要等机票什么时候打折再去，或者选择坐船什么的。这样来看的话，距离是不是就不一样了呢？或者还是不清楚，我再说的详细点。同样是这两个人，欧式距离是直接算最短距离的，而切比雪夫距离可能还得加上财力，比如第一个人财富值100，第二个只有30，虽然物理距离一样，但是所包含的内容却是不同的。 二维切比雪夫距离二维平面两点a(x1,y1)与b(x2,y2)间的切比雪夫距离 d_{12} = max( \\left | x_{1} - x_{2} \\right | , \\left | y_{1} - y_{2} \\right |)python 实现为 1234def twoQBXFdis(a,b): return max( abs(a[0]-b[0]), abs(a[1]-b[1]))print 'a,b二维切比雪夫距离：' , twoQBXFdis((1,2),(3,4)) 多维切比雪夫距离两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的切比雪夫距离 d12 = max_{i\\epsilon n}( \\left | x_{1i} - x_{2i} \\right | )python 实现为12345678def moreQBXFdis(a,b): maxnum = 0 for i in range(len(a)): if abs(a[i]-b[i]) &gt; maxnum: maxnum = abs(a[i]-b[i]) return maxnumprint 'a,b多维切比雪夫距离：' , moreQBXFdis((1,1,1,1),(3,4,3,4)) 马氏距离有M个样本向量X1~Xm，协方差矩阵记为S，均值记为向量μ，则其中样本向量X到u的马氏距离表示为 D(x) = \\sqrt{(X-\\mu )^TS^{-1}(X-\\mu)}而其中向量Xi与Xj之间的马氏距离定义为 D(X_{i},X_{j}) = \\sqrt{(X_{i}-X_{j} )^TS^{-1}(X_{i}-X_{j} )} 若协方差矩阵是单位矩阵（各个样本向量之间独立同分布）,则公式就成了： D(X_{i},X_{j}) = \\sqrt{(X_{i}-X_{j} )^T(X_{i}-X_{j} )}也就是欧氏距离了。 若协方差矩阵是对角矩阵，公式变成了标准化欧氏距离。 马氏距离的优缺点：量纲无关，排除变量之间的相关性的干扰。 夹角余弦几何中夹角余弦可用来衡量两个向量方向的差异，机器学习中借用这一概念来衡量样本向量之间的差异。 二维空间向量的夹角余弦相似度在二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式： \\cos \\theta = \\frac{x_{1}x_{2} + y_{1}y_{2}}{ \\sqrt{ x_{1}^2+x_{2}^2 }\\sqrt{ y_{1}^2+y_{2}^2 } }python 实现为12345def twoCos(a,b): cos = (a[0]*b[0]+a[1]*b[1]) / (sqrt(a[0]**2 + b[0]**2) * sqrt(a[1]**2 + b[1]**2) ) return cosprint 'a,b 二维夹角余弦距离：',twoCos((1,1),(2,2)) 多维空间向量的夹角余弦相似度两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦 类似的，对于两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)，可以使用类似于夹角余弦的概念来衡量它们间的相似程度。 \\cos \\theta = \\frac{a \\cdot b}{\\left | a \\right | \\left | b \\right |}即： \\cos \\theta = \\frac{ \\sum_{k=1}^{n} x_{1k}x_{2k} }{ \\sqrt{ \\sum_{k=1}^{n}x_{1k}^2 }\\sqrt{ \\sum_{k=1}^{n} x_{2k}^2 } }python实现为12345678910def moreCos(a,b): sum_fenzi = 0.0 sum_fenmu_1,sum_fenmu_2 = 0,0 for i in range(len(a)): sum_fenzi += a[i]*b[i] sum_fenmu_1 += a[i]**2 sum_fenmu_2 += b[i]**2 return sum_fenzi/( sqrt(sum_fenmu_1) * sqrt(sum_fenmu_2) )print 'a,b 多维夹角余弦距离：',moreCos((1,1,1,1),(2,2,2,2)) 夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。 闵可夫斯基距离闵氏距离不是一种距离，而是一组距离的定义 定义两个n维变量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的闵可夫斯基距离定义为： \\sqrt[p]{ \\sum_{k=1}^{n} \\left | x_{1k}-x_{2k} \\right |^p}其中p是一个变参数。 当p=1时，就是曼哈顿距离 当p=2时，就是欧氏距离 当p→∞时，就是切比雪夫距离 根据变参数的不同，闵氏距离可以表示一类的距离。 闵氏距离的缺点闵氏距离，包括曼哈顿距离、欧氏距离和切比雪夫距离都存在明显的缺点。 举个例子：二维样本(身高,体重)，其中身高范围是150 ~ 190，体重范围是50 ~ 60，有三个样本：a(180,50)，b(190,50)，c(180,60)。那么a与b之间的闵氏距离（无论是曼哈顿距离、欧氏距离或切比雪夫距离）等于a与c之间的闵氏距离，但是身高的10cm真的等价于体重的10kg么？因此用闵氏距离来衡量这些样本间的相似度很有问题。 简单说来，闵氏距离的缺点主要有两个：(1)将各个分量的量纲(scale)，也就是“单位”当作相同的看待了。(2)没有考虑各个分量的分布（期望，方差等)可能是不同的。 汉明距离定义两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。 应用：信息编码（为了增强容错性，应使得编码间的最小汉明距离尽可能大）。 python 实现12345678def hanmingDis(a,b): sumnum = 0 for i in range(len(a)): if a[i]!=b[i]: sumnum += 1 return sumnumprint 'a,b 汉明距离：',hanmingDis((1,1,2,3),(2,2,1,3)) 杰卡德距离 &amp; 杰卡德相似系数杰卡德距离与杰卡德相似系数相反的概念是杰卡德距离(Jaccard distance)。杰卡德距离可用如下公式表示： J_{\\delta} (A,B) = \\frac{| A \\bigcup B | - | A \\bigcap B |}{| A \\bigcup B |}杰卡德距离用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度。 python 实现1234567def jiekadeDis(a,b): set_a = set(a) set_b = set(b) dis = float(len( (set_a | set_b) - (set_a &amp; set_b) ) )/ len(set_a | set_b) return disprint 'a,b 杰卡德距离：', jiekadeDis((1,2,3),(2,3,4)) 杰卡德相似系数两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数，用符号J(A,B)表示。 J(A,B) = \\frac{| A \\bigcap B |}{| A \\bigcup B |}杰卡德相似系数是衡量两个集合的相似度一种指标。 python 实现1234567def jiekadeXSDis(a,b): set_a = set(a) set_b = set(b) dis = float(len(set_a &amp; set_b) )/ len(set_a | set_b) return disprint 'a,b 杰卡德相似系数：', jiekadeXSDis((1,2,3),(2,3,4)) 杰卡德相似系数与杰卡德距离的应用可将杰卡德相似系数用在衡量样本的相似度上。 样本A与样本B是两个n维向量，而且所有维度的取值都是0或1。例如：A(0111)和B(1011)。我们将样本看成是一个集合，1表示集合包含该元素，0表示集合不包含该元素。 p ：样本A与B都是1的维度的个数 q ：样本A是1，样本B是0的维度的个数 r ：样本A是0，样本B是1的维度的个数 s ：样本A与B都是0的维度的个数 那么样本A与B的杰卡德相似系数可以表示为： 这里p+q+r可理解为A与B的并集的元素个数，而p是A与B的交集的元素个数。 而样本A与B的杰卡德距离表示为： J= \\frac{p}{p+q+r}相关系数 &amp; 相关距离相关系数 \\rho_{XY} = \\frac{Cov(X,Y)}{\\sqrt{D(X)} \\sqrt{D(Y)}}=\\frac{ E( (X-EX) (Y-EY) ) }{ \\sqrt{D(X)} \\sqrt{D(Y)} }相关系数是衡量随机变量X与Y相关程度的一种方法，相关系数的取值范围是[-1,1]。相关系数的绝对值越大，则表明X与Y相关度越高。当X与Y线性相关时，相关系数取值为1（正线性相关）或-1（负线性相关）。 python 实现相关系数可以利用numpy库中的corrcoef函数来计算例如 对于矩阵a,numpy.corrcoef(a)可计算行与行之间的相关系数，numpy.corrcoef(a,rowvar=0)用于计算各列之间的相关系数，输出为相关系数矩阵。123456789101112131415161718from numpy import *a = array([[1, 1, 2, 2, 3], [2, 2, 3, 3, 5], [1, 4, 2, 2, 3]]) print corrcoef(a)&gt;&gt;array([[ 1. , 0.97590007, 0.10482848], [ 0.97590007, 1. , 0.17902872], [ 0.10482848, 0.17902872, 1. ]])print corrcoef(a,rowvar=0)&gt;&gt;array([[ 1. , -0.18898224, 1. , 1. , 1. ], [-0.18898224, 1. , -0.18898224, -0.18898224, -0.18898224], [ 1. , -0.18898224, 1. , 1. , 1. ], [ 1. , -0.18898224, 1. , 1. , 1. ], [ 1. , -0.18898224, 1. , 1. , 1. ]]) 相关距离 D_{xy} = 1 - \\rho _{XY}python 实现（基于相关系数）同样针对矩阵a12345678910111213141516# 行之间的相关距离ones(shape(corrcoef(a)),int) - corrcoef(a)&gt;&gt;array([[ 0. , 0.02409993, 0.89517152], [ 0.02409993, 0. , 0.82097128], [ 0.89517152, 0.82097128, 0. ]]) # 列之间的相关距离ones(shape(corrcoef(a,rowvar = 0)),int) - corrcoef(a,rowvar = 0)&gt;&gt;array([[ 0. , 1.18898224, 0. , 0. , 0. ], [ 1.18898224, 0. , 1.18898224, 1.18898224, 1.18898224], [ 0. , 1.18898224, 0. , 0. , 0. ], [ 0. , 1.18898224, 0. , 0. , 0. ], [ 0. , 1.18898224, 0. , 0. , 0. ]]) 信息熵信息熵并不属于一种相似性度量，是衡量分布的混乱程度或分散程度的一种度量。分布越分散(或者说分布越平均)，信息熵就越大。分布越有序（或者说分布越集中），信息熵就越小。 计算给定的样本集X的信息熵的公式： Entropy(X) = \\sum_{i=1}^{n} -p_{i} log_{2}p_{i}参数的含义： n：样本集X的分类数 pi：X中第i类元素出现的概率 信息熵越大表明样本集S分类越分散，信息熵越小则表明样本集X分类越集中。。当S中n个分类出现的概率一样大时（都是1/n），信息熵取最大值log2(n)。当X只有一个分类时，信息熵取最小值0 python进行计算和实现可参考：http://blog.csdn.net/autoliuweijie/article/details/52244246 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"距离计算","slug":"距离计算","permalink":"http://thinkgamer.cn/tags/距离计算/"},{"name":"机器学习","slug":"机器学习","permalink":"http://thinkgamer.cn/tags/机器学习/"}]},{"title":"一切的闹闹哄哄，只是他在水帘洞躲避风沙那晚做的一个梦","slug":"随手记/一切的闹闹哄哄，只是他在水帘洞躲避风沙那晚做的一个梦","date":"2017-04-15T17:03:56.000Z","updated":"2019-10-14T06:42:35.691Z","comments":true,"path":"2017/04/16/随手记/一切的闹闹哄哄，只是他在水帘洞躲避风沙那晚做的一个梦/","link":"","permalink":"http://thinkgamer.cn/2017/04/16/随手记/一切的闹闹哄哄，只是他在水帘洞躲避风沙那晚做的一个梦/","excerpt":"送同学走之后，我在路边默默的站了有五分钟，突然觉得我无处可去，有一种深入骨髓的悲哀和无奈，然后我就想起了一个命题，“如今的你，何去何从！”我不知道为什么会突然想到这样一个命题，或许是我们每个人都是至尊宝吧。其实每个人对《大话》的理解都是有所不同的，同样的人在不同的时期认识也会有偏差，就好比我第一次看的时候，笑得腹背抽筋，呲牙咧嘴，第二次看的时候，笑得少了，想的多了，过后便什么感觉也没有了，第三次看得时候，忽然觉得不知道是该哭还是该笑，笑得时候太牵强，哭得时候太尴尬。第四次便是这一次，看完之后觉得有一种无可奈何的悲哀。","text":"送同学走之后，我在路边默默的站了有五分钟，突然觉得我无处可去，有一种深入骨髓的悲哀和无奈，然后我就想起了一个命题，“如今的你，何去何从！”我不知道为什么会突然想到这样一个命题，或许是我们每个人都是至尊宝吧。其实每个人对《大话》的理解都是有所不同的，同样的人在不同的时期认识也会有偏差，就好比我第一次看的时候，笑得腹背抽筋，呲牙咧嘴，第二次看的时候，笑得少了，想的多了，过后便什么感觉也没有了，第三次看得时候，忽然觉得不知道是该哭还是该笑，笑得时候太牵强，哭得时候太尴尬。第四次便是这一次，看完之后觉得有一种无可奈何的悲哀。 对《大话》的解读有人说这是一部烂片，也有人说这是一部经典，有人说这是对西游文化的过度消费，有人说这是一代人的反思与成长，有人说阴差阳错的蝴蝶效应，让一个年代的人支撑起了这部超越中国电影水平50年的无厘头式作品，也有人说这是一部笑中带泪，总有一天你走在路上也会像一条狗的悲剧。 一千个人眼中有一千个哈姆雷特，对于一部影视作品，我们无法去评论任何一个人的理解是对还是错，因为经历不同，就像你不能把你的情感强加到别人身上。喜欢一部作品，在不知不觉间你会忽略他的缺点，讨厌一个事物，在不知不觉间就会放大他的短处。我们也不能用我们现代的思维和观念去评判20世纪港台电影的文化和情感。 至尊宝的路线是，有人给他点了三颗痣，拔出来紫青宝剑，开启了与紫霞的交涉，娶亲，戴上紧箍咒，大战牛魔王，西天取经。其实至尊宝这条路线，何尝不是我们的漫漫人生路呢，至尊宝用月光宝盒来寻找500年前的白晶晶，却阴差阳错遇到了紫霞仙子，最后在对白晶晶失而复得之后又得知紫霞在他内心留下的一滴眼泪，最终大彻大悟，明白了舍生取义，参透了生亦何哀，死亦何苦。我们的人生不也一样，总会有各种各样的未知因素影响我们的选择，在努力面对眼前一切之后，最终回头感叹年华，围炉小饮，本来无一物，何处惹尘埃。 对于紫霞和至尊宝的爱情，没有这种体验，是不会懂的，越是深情的人越容易受伤，她放下尊严来爱他，终于他后悔了。在至尊宝的梦里，紫霞仙子说：“飞蛾明明知道前面是火堆，却还义无反顾的扑进去。”她笑一下，接着说：“飞蛾就是这么傻！”而同样的至尊宝，“有一个名字叫紫霞的，你叫七百八十四次“，时光真是个好东西，所谓雕刻时光，是说生活像把钝刀，锉平我们的触觉，而电影则是解毒的重药，它让人突然领悟到，我们的内心要比自己想像的敏感干净得多！你等的那么辛苦，他却陌生到让你心疼。以至于在人生的不同阶段去欣赏《大话》，似乎都能从中找到某些影子，原先是笑，后来是苦，到最后便是沉默了。城墙上的一吻，至尊宝变成了旁观者，他借用夕阳武士的身份和转世的紫霞完成了他告别的深情，于是他的背影，他的离开，寂寞成了“好像一条狗”。 他好像一条狗呀！-“那个人的样子好怪啊”-“我也看到了，他好像条狗啊”是呀，英雄的离开，留下的永远只是背影，只不过在至尊宝这里加上了悲剧色彩，加上了人艰不拆的辛酸泪，以至于多少年后才明白了至尊宝转身离开有多难。至尊宝的结局是一个男人的悲怆与无奈。 至尊宝用了月光宝盒来寻找500年前的白晶晶，同时遇到了在她看来，他是她的命中注定的紫霞仙子，直到后来牛魔王的出现，夺走了紫霞，夺走了白晶晶，夺走了至尊宝往日的快乐，他明白他要夺回这一切，可是面对戏剧般的月光宝盒，至尊宝得到的更多是无力和苍白，面对这些无情的现实，幻想一次又一次地破灭。直到最后的关头，至尊宝终于醒悟，靠月光宝盒不行，至尊宝更是没有那个本事，只有成为孙悟空，只有戴上那个金刚圈，他才有能力同牛魔王一较高下。 这是一个极大的讽刺。你想要得到吗？好，那么你必须先放弃至尊宝的身份，你必须做出选择，必须忍受无尽的痛苦，他想要化解时间无尽的仇恨，就必须放弃自己的感情，不是不爱，而是大彻大悟之后的大爱，他必需化身为孙悟空，帮助唐三藏取得经书，化解这世间的恨。 那么至尊宝的放弃是自觉自愿的醒悟吗？不，他并不愿意，但是他必须拯救紫霞，必须化解人间的恨，他别无选择，他必须戴上紧箍咒。虽然成为了孙悟空，成了大英雄，但他对自己的生存状态极度不满。所以在最后，孙悟空将他心中残存的至尊宝的影子幻化作一位夕阳武士，在对现实世界彻底失望后，只能构造一个虚幻的想象来了却这桩心愿，并借武士的口中表达了对自己生存状态的不满，活得好象是一条狗一样。唉，一个男人的悲怆和无奈。 那句意中人，满足了多少人的少女心“我知道有一天，他会在一个万众瞩目的情况下出现，身披金甲圣衣，脚踏七色云彩来娶我”“我的意中人是个盖世英雄，有一天他会踏着云彩来娶我”这两句分别是紫霞在牛魔王娶她前的晚上和死前对孙悟空说的，多么经典的台词，以至于现在多少人还幻想着自己的意中人。 进入至尊宝内心的只有两个女人，一个是白晶晶，一个是紫霞，白晶晶问的是“他最喜欢的人是不是我”，紫霞问的是“他跟他的娘子是不是很恩爱呀？”，白晶晶的爱是一种索求的爱，而紫霞的爱则是无怨无悔的。 所以最终至尊宝回来了，在化身为孙悟空之后，身披金甲圣衣，脚踏七色云彩而来，他实现了紫霞的梦想，只不过加了一层掩饰与牵强。 从现如今这个角度反思紫霞的意中人，我是不太赞同的，童话毕竟是童话，正是这个经典的对白，让多少人活在自己的想象中，我们都渴望对方是个“意中人”的形象，可是我们却忽略乐一个”等价“的观念，你凭什么拥有你的”意中人“，你配得上吗？这不仅让我想起了另外一个命题：“不要去羡慕那些散发光芒的成功者，因为你不知道他背后付出的努力和艰辛”，这其实是一个道理，如果你仅仅是停留在幻想和计划的层面，那么你永远得不到你的”意中人“。 我猜中了开头，可是我猜不着这结局紫霞说猜得到开始，却猜不透这结局。大约直到最后，她也没能明白、没能理解至尊宝的苦心。又或者说，是至尊宝从来也未能真正了解她的心意。我曾经以为，死去的紫霞是最可怜的角色。可是，至尊宝又何尝不可怜呢，他甚至，连伤心的权利也没有了。在紫霞死去的一瞬间，他的心也已经跟着死去了。在他余下的人生里，再也不会有欢笑、快乐，再也不会有那样一个可以在他心里流下眼泪的女孩子。就算取回西经又能如何，心爱的人再也会不来了。就算成佛又能如何，没有了你，整个世界对我来说都毫无意义。 《大话》把遗憾和难题抛给了时间又一次的时空穿梭后，面对城头男女，孙悟空附身夕阳武士，给出无数人热泪纵横，内心中期盼的最后答案。没有失去过，也永远不能明白得到的快乐。附身后的孙悟空发自内心肺腑地给了女子一记深深长吻，这一吻穿越地老天荒，不再相信自欺欺人的一万年，他那般语气坚决地说出了那三个字。先前拒不让步的夕阳武士，拥抱着爱人幸福陶醉。转身远去的孙悟空了却尘缘心事，消失在大漠黄沙尽头。只是每次在紫霞被刺中或者孙悟空松手的瞬间，还是会心潮如水甚至潸然泪下。 十年大话，一群人围坐着观看《大话西游》的狂热时代过去了，心底保存的泪水也慢慢尘封直至故事终结。毫无拘束的开怀大笑渐渐沦为一个人的狂欢，难加掩饰的心底苍凉逐渐成了人生重担 如今的你，何去何从“如今的你，何去何从？”“对呀，何去何从” 真的羡慕至尊宝最初为了营救白晶晶，借用外力，使用月光宝盒穿越回500年前，为了解救紫霞，戴上紧箍咒。 而你呢？没有目标，你便是一个游荡的灵魂。 加长版加了什么1：紫霞刚出现时在沙漠和雪蛤精，孔雀王的对话以及 他们的拔剑抢婚，与影片中紫霞和至尊宝在 牛魔王婚礼上遇见时雪蛤精，孔雀王和反对结婚作了呼应。 2：约好二更相见，原版是牛夫人出现 ，然后是至尊宝直接被猪八戒和沙师弟拉去救师父，加长版中先是牛夫人出现，然后牛魔王，然后至尊宝 3：牛魔王婚礼时猪八戒和沙僧在小妖堆里跟他们“打成一片” 4：至尊宝被青霞揍晕第二次之后，早上跟紫霞说的那通话“你要让我拿点信物给他看, 你有什么项链啊,首饰啊,金银珠宝啊,月光宝盒啊什么的……”原版的这段声音不是石班瑜所配。新版中，这段声音是重新配音，换上了石班瑜的声音。 5：2K画面的修复 一切的闹闹哄哄，只是他在水帘洞躲避风沙那晚做的一个梦 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/tags/随手记/"}]},{"title":"别了青春与流年，遇见下一个自己","slug":"随手记/别了青春与流年，遇见下一个自己","date":"2016-12-20T16:35:00.000Z","updated":"2019-10-14T06:42:35.692Z","comments":true,"path":"2016/12/21/随手记/别了青春与流年，遇见下一个自己/","link":"","permalink":"http://thinkgamer.cn/2016/12/21/随手记/别了青春与流年，遇见下一个自己/","excerpt":"如果说岁月是年轮，我们便是推行者，如果说成长是一场华丽的蜕变，我们便是领舞者。一路走来，太多不易，告别青春的年少轻狂，我们成了岁月里被磨平的棱角，静静的守在属于自己的一亩三分地。","text":"如果说岁月是年轮，我们便是推行者，如果说成长是一场华丽的蜕变，我们便是领舞者。一路走来，太多不易，告别青春的年少轻狂，我们成了岁月里被磨平的棱角，静静的守在属于自己的一亩三分地。 2016-时间是长了脚的妖怪，跑的飞快&nbsp;&nbsp;&nbsp;&nbsp;四年时光，匆匆而过，沈阳占据了我23岁之前的太多第一次，第一次一个人一包行李，第一次21个小时的硬座，第一次坐地铁，第一次谈恋爱，第一次分手，第一次旅行，第一次坐摩天轮，第一次吃棉花糖，第一次看电影，第一次接触电脑，第一次……&nbsp;&nbsp;&nbsp;&nbsp;时间是长了脚的妖怪，跑的飞快，只是好像后来我们都离开，各自生活在喧嚣未来，当时的遗憾在回忆肆虐的某些时段，重新打开，又好象我们同时都在。&nbsp;&nbsp;&nbsp;&nbsp;有人说，谈过恋爱，分过手，挂过科，拿过奖学金，当过学生干部的大学才是完美的，那么我想我还是比较幸运的，回顾我的大学生活，除了两件我极力想做的事情没有完成之外，经历了太多，谈过恋爱，分过手，当过学生干部，拿过奖学金，参加过各种志愿活动，也做过校园代理，被坑过，被骗过，也干过兼职，做过外包，送过外卖，发过传单，在这整个过程中，认识了不少人，见过不少事，看明白了不少的社会道理，看清了多少人的虚情假意，感谢那一路让我经历成长的人。&nbsp;&nbsp;&nbsp;&nbsp;大一是我大学生活里最快乐的一年，那时的我们很单纯。只是后来，大家都变了。 2016-剑未配好，已出江湖，来一场说走就走的北漂&nbsp;&nbsp;&nbsp;&nbsp;该到来的还是会到来，虽然对于工作我是做好了准备，但是还是有点措手不及。 七月，别了流年&nbsp;&nbsp;&nbsp;&nbsp;那是七月，我的心情迫切的像火辣辣的太阳，拉着行李，从大学的门前离开，没有回头，虽然这里有我牵挂的人，有我念着的事，但我还是把更多的希望寄托在充满魔性的首都，因为我相信这里是梦会是开始的地方，于是在朋友的帮助下，我开启了我的北漂生活。 广联达&nbsp;&nbsp;&nbsp;&nbsp;我来北京的第一家公司是广联达，建筑行业国内算是龙头老大了，虽然在互联网行业不是太牛逼，但对于一个初出茅庐的我还是够我学习和经历了，而且凑巧的是公司是我一个八几年的校友创立的，只是这和我没有半毛钱关系，在那的三个月里，我连个人影都没有见过。&nbsp;&nbsp;&nbsp;&nbsp;后来的后来我选择了离开，不是公司不好，不是带我的师父不优秀，不是同事不牛逼，只是我感觉那里不适合我。&nbsp;&nbsp;&nbsp;&nbsp;我的师父是项目组组长吧，人有点娘娘腔，别人都叫他梅梅，但是对我们特别好，他技术也十分厉害，离开的时候和师父聊天，他说在公司是P3和P4的技术双认证，是一个技术架构师，自己带着团队几个月为公司写了一个云测试平台，现在更到3.x版本了吧。我个人是十分佩服我师父的，为人低调，技术够强，还有好人缘。&nbsp;&nbsp;&nbsp;&nbsp;在公司的那段时候里，我主要做的是一个以课题形式展示的数据分析平台，用到的技术无非就是大学里学的那些，那个时候和另外一个同事还吹牛逼说咱也是架构师了，这仅仅是因为自己画了个水的一逼的图&nbsp;&nbsp;&nbsp;&nbsp;哈哈，如果这幅图出自架构师之手，就是系统架构了，可是出自我们这等毛小子之手就是闹着玩了吧。就好比以国家的名义去挖墓，就是考古，以个人名义去挖墓就是盗墓了。 昌平线，煎熬&nbsp;&nbsp;&nbsp;&nbsp;西二旗是中国最堵得一个地铁站了，大家都说后村厂路堵车十分钟，中国互联网经济停滞2小时。&nbsp;&nbsp;&nbsp;&nbsp;昌平线是北漂人的聚集地了，不是因为别的，是因为这条线路上的房租便宜 ，那个时候我就盘踞在沙河高教园旁边的东沙屯村里，每月800元的房租还是负担的起的，除了交通不便之外，一切还都可以接受，毕竟你是在北漂。 2016-别了流年，是现在的我&nbsp;&nbsp;&nbsp;&nbsp;九月末我面试了现在所在的公司，离开了广联达，不是因为它不优秀，它不好，只是因为那里现在还不适合我，在我的棱角被磨平之前，我想出去闯一闯。&nbsp;&nbsp;&nbsp;&nbsp;可能是我所在部门的原因，我觉得特别懒散，感觉大家都是在混日子，每天改那么点bug，每天更新一点小功能，或者这就是大公司的尴尬，或者说转型之中的公司的短板吧，大家都沉浸在以前的辉煌之中，没有创造力，没有新奇的想法，没有交流的冲动，没有那种干劲。于是我选择了离开，我想先让我去经历一番我想要的工作与生活，等我累了，说不定我就会想念这种状态了。&nbsp;&nbsp;&nbsp;&nbsp;现在所在的是一个创业公司，像我想象中一样，大家窝在一个不大的办公司，交流与合作，为了梦想一起努力着，很开心。&nbsp;&nbsp;&nbsp;&nbsp;在这里我接触到了更多知识，技术的，做人的，交流的，至今我脑海中还清晰的记着那天赵总的一句话：读书要有收获，至少要涨气场。&nbsp;&nbsp;&nbsp;&nbsp;新的环境里我接触学习了Docker，ELK，重新学习了一些机器学习的算法知识。于是在我的CSDN博客中创建了两个技术专栏，由于刚刚接触，写的也不够深入，不过我会努力的。&nbsp;&nbsp;&nbsp;&nbsp;Docker江湖：http://blog.csdn.net/column/details/13159.html &nbsp;&nbsp;&nbsp;&nbsp;ELK从入门到放弃：http://blog.csdn.net/column/details/13079.html &nbsp;&nbsp;&nbsp;&nbsp;认认真真经历才能好好成长。 2016-我在CSDN的收获 鲍大神&nbsp;&nbsp;&nbsp;&nbsp;开始在CSDN上写博客是大一的时候，是一个牛逼的学长带我走上了这条”不归路”，谢谢鲍大神这一路的指导与传授，一直以来，他都是我的榜样。我也努力赶上他，只可惜看到的永远都是背影。 梦姐姐&nbsp;&nbsp;&nbsp;&nbsp;八月份的时候偶然的机会认识梦姐姐，做了博乐，后来也申请并通过了CSDN博客专家。 结识技术爱好者&nbsp;&nbsp;&nbsp;&nbsp;其实相比这些更重要的是通过CSDN所认识的每一个技术爱好者，可以说CSDN是国内的程序员的社交平台了。感觉那些给我留言提问我的人，可能有些疑问还是没有帮你们解决，只是我个人能力有限，不像郭神，鸿洋大神技术功底深厚。在这个平台之上，我也认识到了自己的许多不足和技术缺点，在阅读博客的过程中，也学到了不少东西。 &nbsp;&nbsp;&nbsp;&nbsp;谢谢你一路陪我成长，你若不离，我定不弃。 2016-开始commit我的github&nbsp;&nbsp;&nbsp;&nbsp;有人说开源垃圾，有人说开源缩减了开发的成本和时间，不管怎样，开源是一种趋势，而且势头不会减弱，很荣幸我也投入了开源的大军，即使现在我还是一个蝼蚁。&nbsp;&nbsp;&nbsp;&nbsp;我的github：https://github.com/thinkgamer 2016-杂乱无章&nbsp;&nbsp;&nbsp;&nbsp;这一年，从一个初出茅庐的蝼蚁一步步成长，一个个经历，我给交了一份70分的答卷，我没有让我的父母和亲人失望，我没有让我的老师失望，我没有让我喜欢的人失望，我也没有让曾经看不起我的人失望，只是我让自己失望了。&nbsp;&nbsp;&nbsp;&nbsp;有些东西我没有去争取，有些机会我没有把握，有些冲动我失了控。但正是这些完美的不完美的，才让你有更大的劲头去前进。 2017-下一个自己&nbsp;&nbsp;&nbsp;&nbsp;时间不会因为你的遗憾而停留，我们能做的就是把每一天都当成最后一天来过。&nbsp;&nbsp;&nbsp;&nbsp;2017，我要完成： 一个安卓APP和对应的Web 小说《这夏未眠》 发表社区划分论文 深入学习Scala和Spark 掌握一个深度学习框架（eg：Caffe） 跟进研究Hadoop家族的最近版本，并形成文档 换一台Mackbook Pro 攒够100K+ &nbsp;&nbsp;&nbsp;&nbsp;感谢这一路有你，加油！ 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/tags/随手记/"}]},{"title":"这夏未眠.前言","slug":"夏未眠/这夏未眠-前言","date":"2016-09-17T07:02:51.000Z","updated":"2019-10-14T06:42:35.680Z","comments":true,"path":"2016/09/17/夏未眠/这夏未眠-前言/","link":"","permalink":"http://thinkgamer.cn/2016/09/17/夏未眠/这夏未眠-前言/","excerpt":"青春在岁月中葬送了开始，用悲字调刻画的年轮在那片草地上画上了最后一圈，漫天飞舞的纸片如此刻房费的心一样苍白无力，尘埃落定，一切都已结束。你用对不起作结了那段美好时光，我用没关系掩饰心痛的泪水，转身离去，用空白再见。","text":"青春在岁月中葬送了开始，用悲字调刻画的年轮在那片草地上画上了最后一圈，漫天飞舞的纸片如此刻房费的心一样苍白无力，尘埃落定，一切都已结束。你用对不起作结了那段美好时光，我用没关系掩饰心痛的泪水，转身离去，用空白再见。 难以割舍的流河里，有你荡起的微笑，我回忆着，慢慢就流下了眼泪，此刻我想把记忆封存，我不想在若干年后拿起来温习时，只剩下一些虚无缥缈的梦幻，宁愿再看到一些文字而流下当初所认为的幸福的泪水，或许最无力的是如果，但我仍想说，如果时光循环到那年起点，我亦然会爱，因为夏未眠。 没有人永远青春，却永远有人正在青春着，是呀，那夏，他们平行的爱情会以最美丽的姿态延后，永远会有人经历着，或许分手，或许继续在一起，但那早已与他们无关，他只希望她幸福，她只希望他幸福。但结果呢？两个人都没有幸福！ 我们没有权利去质疑在那个年龄他们的感情有没有权利，只要快乐，为什么不能在一起，他可以为了她放弃自己，只要她愿意，他可以放弃所拥有的一切，可是结果呢？谁又能料到，他毁了，她成功了，却没有一个人心安理得。 夏天因为他们变得那么美，又因为他们变得那么悲。谁也不想，谁也不愿意去想，回忆总是短暂的，记忆却是痛的。 最难熬的便是这痛苦的时段，或许每一次闭上眼，泪水便在打转，熬过一夏晴天，幻化成瓢泼的雨季。让心在哭泣中成长，茁壮了，坚强了，淡忘了！ 曾经萌动在稚嫩青春里的唯一一朵留恋，在这一个夏末彻底的枯萎了。 看着窗外尘埃落满天，依稀记得已错过的昨天。时间是贼偷走一切，捉住了那只蝉，原来并不代表留住了整个夏天，爱我的与我爱的，I Miss You，But I Missed You！ 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"夏未眠","slug":"夏未眠","permalink":"http://thinkgamer.cn/categories/夏未眠/"}],"tags":[{"name":"这夏未眠","slug":"这夏未眠","permalink":"http://thinkgamer.cn/tags/这夏未眠/"}]},{"title":"这夏未眠.简介","slug":"夏未眠/这夏未眠-简介","date":"2016-09-16T10:13:50.000Z","updated":"2019-10-14T06:42:35.680Z","comments":true,"path":"2016/09/16/夏未眠/这夏未眠-简介/","link":"","permalink":"http://thinkgamer.cn/2016/09/16/夏未眠/这夏未眠-简介/","excerpt":"书整体分为三部分《夏之过往》，《夏之流年》，《夏之未至》。整本书讲的是男主人公顾艾哲（小艾）与莫晨（晨晨）之间的故事，从初中到高中再到大学，从相遇到相知再到相离。 两人同在陌乘一中念初中，同班同学，在中考来临的那段日子，两人相互鼓励，于是顾艾哲（小艾）考上了他从来都没有想过能考上的孟川一高，而莫晨（晨晨）呢，考上了预料之中的平阳一高，而她在这之前却从来没告诉过顾艾哲（小艾）她要去平阳，就这样，两个人分开了，一些都看起来那么顺理成章，一切又看起来那么暗淡失望。","text":"书整体分为三部分《夏之过往》，《夏之流年》，《夏之未至》。整本书讲的是男主人公顾艾哲（小艾）与莫晨（晨晨）之间的故事，从初中到高中再到大学，从相遇到相知再到相离。 两人同在陌乘一中念初中，同班同学，在中考来临的那段日子，两人相互鼓励，于是顾艾哲（小艾）考上了他从来都没有想过能考上的孟川一高，而莫晨（晨晨）呢，考上了预料之中的平阳一高，而她在这之前却从来没告诉过顾艾哲（小艾）她要去平阳，就这样，两个人分开了，一些都看起来那么顺理成章，一切又看起来那么暗淡失望。 在经历过高中的二年之后，顾艾哲（小艾）终于联系上了莫晨（晨晨），那天晚上，他用妈妈的电话给莫晨（晨晨）通了两个小时的电话，似乎要把两人两年里没有说的话都说完，可是有太多的话是无法用言语表达的，就这样电话欠费了，终止了聊天，可是那天晚上，小艾高兴的一宿没睡，那一晚上，他的笑容都是幸福的。 可是事情永远不会那么顺利，在香山公园里，当他拿起他买的情侣戒指送给晨晨时，晨晨没有接受，说了一堆他也没有听进去的话，就这样，又开始了分离，而谁也不知道这次分离竟然时一辈子的再也不见。 后来的后来，他又遇见了别的女孩，不知道是不是因为后来的女孩都像小艾记忆里的莫晨。只知道，他都很珍惜。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"夏未眠","slug":"夏未眠","permalink":"http://thinkgamer.cn/categories/夏未眠/"}],"tags":[{"name":"这夏未眠","slug":"这夏未眠","permalink":"http://thinkgamer.cn/tags/这夏未眠/"}]},{"title":"这夏未眠.序","slug":"夏未眠/这夏未眠-序","date":"2016-09-15T10:08:51.000Z","updated":"2019-10-14T06:42:35.680Z","comments":true,"path":"2016/09/15/夏未眠/这夏未眠-序/","link":"","permalink":"http://thinkgamer.cn/2016/09/15/夏未眠/这夏未眠-序/","excerpt":"这本书的整体构思是小主大学一年级时刚去的时候的一个想法，当时刚刚步入大学的我们，心里是那么的迷茫与懵懂，开学前两周，除了军训还是军训，晚上偶尔有个空闲时间，我想大概也许是无聊的，记得那个时候坐在图书馆靠窗的位置，看着窗外，没有明月，没有佳人，有的只是一望无际的黑暗。","text":"这本书的整体构思是小主大学一年级时刚去的时候的一个想法，当时刚刚步入大学的我们，心里是那么的迷茫与懵懂，开学前两周，除了军训还是军训，晚上偶尔有个空闲时间，我想大概也许是无聊的，记得那个时候坐在图书馆靠窗的位置，看着窗外，没有明月，没有佳人，有的只是一望无际的黑暗。 那个时候，还没有遇到你所想遇到的人，或许回忆还沉淀在高中的时光里，或是幸福，或是苦涩，或是幸福之后的苦涩，回过头来，看着满屋子的学长学姐，心里是及其复杂的，有种说不出的难过，那时候我是不是在想，现在的你（们）会在哪里念大学呢？ 想着想着眼角便淌出了泪水，我想我的大学要完成一件至少我自己觉得满意的事，于是便有了你现在看到的这个序，不知道是不是受郭敬明的影响，因为我看过他的唯一一本小说，也是我看过的唯一一本小说——《夏至未至》，我想写一本书，或者更准确的说，我想写一个人的青春。 在13年军训结束之后，我构思了整个体系，定了这本书的名字——《这夏未眠》，熟悉我的朋友，也知道这是我的QQ网名，QQ作为那个时代的记忆，总会残留一些悲伤的故事，于是我到现在四年了，我从没换过QQ网名，或许是害怕，害怕那些好久不联系的朋友，找不到我吧。 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"夏未眠","slug":"夏未眠","permalink":"http://thinkgamer.cn/categories/夏未眠/"}],"tags":[{"name":"这夏未眠","slug":"这夏未眠","permalink":"http://thinkgamer.cn/tags/这夏未眠/"}]},{"title":"搜索引擎：MapReduce实战----倒排索引","slug":"Hadoop/搜索引擎：MapReduce实战-倒排索引","date":"2015-07-28T02:23:00.000Z","updated":"2019-10-14T09:45:30.545Z","comments":true,"path":"2015/07/28/Hadoop/搜索引擎：MapReduce实战-倒排索引/","link":"","permalink":"http://thinkgamer.cn/2015/07/28/Hadoop/搜索引擎：MapReduce实战-倒排索引/","excerpt":"倒排索引（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。","text":"倒排索引（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。 1.倒排索引简介有两种不同的反向索引形式： 一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。后者的形式提供了更多的兼容性（比如短语搜索），但是需要更多的时间和空间来创建。 举例：以英文为例，下面是要被索引的文本：123T0 = \"it is what it is\"T1 = \"what is it\"T2 = \"it is a banana\" 我们就能得到下面的反向文件索引：12345\"a\": &#123;2&#125;\"banana\": &#123;2&#125;\"is\": &#123;0, 1, 2&#125;\"it\": &#123;0, 1, 2&#125;\"what\": &#123;0, 1&#125; 检索的条件”what”, “is” 和 “it” 将对应这个集合：{0,1}∩{0,1,2}∩{0,1,2}={0,1}。 对相同的文字，我们得到后面这些完全反向索引，有文档数量和当前查询的单词结果组成的的成对数据。 同样，文档数量和当前查询的单词结果都从零开始。 所以，”banana”: {(2, 3)} 就是说 “banana”在第三个文档里 (T2)，而且在第三个文档的位置是第四个单词(地址为 3)。12345\"a\": &#123;(2, 2)&#125;\"banana\": &#123;(2, 3)&#125;\"is\": &#123;(0, 1), (0, 4), (1, 1), (2, 1)&#125;\"it\": &#123;(0, 0), (0, 3), (1, 2), (2, 0)&#125;\"what\": &#123;(0, 2), (1, 0)&#125; 如果我们执行短语搜索”what is it” 我们得到这个短语的全部单词各自的结果所在文档为文档0和文档1。但是这个短语检索的连续的条件仅仅在文档1得到。 2.分析和设计1）Map过程首先使用默认的TextInputFormat类对输入文件进行处理，得到文本中每行的偏移量及其内容，Map过程首先必须分析输入的对，得到倒排索引中需要的三个信息：单词、文档URI和词频，如图所示： 存在两个问题，第一：对只能有两个值，在不使用Hadoop自定义数据类型的情况下，需要根据情况将其中的两个值合并成一个值，作为value或key值； 第二，通过一个Reduce过程无法同时完成词频统计和生成文档列表，所以必须增加一个Combine过程完成词频统计1234567891011121314151617181920public static class Map extends Mapper&lt;Object,Text,Text,Text&gt;&#123; private Text keyInfo = new Text(); private Text valueInfo = new Text(); private FileSplit split; //存储所在文件的路径 public void map(Object key,Text value,Context context) throws IOException,InterruptedException&#123; split = (FileSplit)context.getInputSplit(); //获取当前任务分割的单词所在的文件路径 StringTokenizer itr = new StringTokenizer(value.toString()); while(itr.hasMoreTokens())&#123; keyInfo.set(itr.nextToken()+\"+\"+split.getPath().toString()); //keyvalue是由单词和URI组成的 valueInfo.set(\"1\"); //value值设置成1 context.write(keyInfo,valueInfo); &#125; &#125; &#125; （2）Combine过程将key值相同的value值累加，得到一个单词在文档中的词频，如图 123456789101112131415161718 public static class Combiner extends Reducer&lt;Text,Text,Text,Text&gt;&#123; private Text info = new Text(); public void reduce(Text key,Iterable&lt;Text&gt;values,Context context) throws IOException, InterruptedException&#123; int sum = 0; for(Text value:values)&#123; sum += Integer.parseInt(value.toString()); &#125;// int index = key.toString().indexOf(\"+\");// info.set(key.toString().substring(index+1)+\":\"+sum); // key.set(key.toString().substring(0,index)); String record = key.toString(); String[] str = record.split(\"[+]\"); info.set(str[1]+\":\"+sum); key.set(str[0]); context.write(key,info); &#125; &#125; （3）Reduce过程讲过上述两个过程后，Reduce过程只需将相同key值的value值组合成倒排索引文件所需的格式即可，剩下的事情就可以直接交给MapReduce框架进行处理了 1234567891011121314public static class Reduce extends Reducer&lt;Text,Text,Text,Text&gt;&#123; private Text result = new Text(); public void reduce(Text key,Iterable&lt;Text&gt;values,Context context) throws IOException, InterruptedException&#123; String value =new String(); for(Text value1:values)&#123; value += value1.toString()+\" ; \"; &#125; result.set(value); context.write(key,result); &#125; &#125; 完整代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package ReverseIndex;import java.io.*;import java.util.StringTokenizer;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.*;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.input.FileSplit;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class ReverseIndex &#123; public static class Map extends Mapper&lt;Object,Text,Text,Text&gt;&#123; private Text keyInfo = new Text(); private Text valueInfo = new Text(); private FileSplit split; //存储所在文件的路径 public void map(Object key,Text value,Context context) throws IOException,InterruptedException&#123; split = (FileSplit)context.getInputSplit(); //获取当前任务分割的单词所在的文件路径 StringTokenizer itr = new StringTokenizer(value.toString()); while(itr.hasMoreTokens())&#123; keyInfo.set(itr.nextToken()+\"+\"+split.getPath().toString()); //keyvalue是由单词和URI组成的 valueInfo.set(\"1\"); //value值设置成1 context.write(keyInfo,valueInfo); &#125; &#125; &#125; public static class Combiner extends Reducer&lt;Text,Text,Text,Text&gt;&#123; private Text info = new Text(); public void reduce(Text key,Iterable&lt;Text&gt;values,Context context) throws IOException, InterruptedException&#123; int sum = 0; for(Text value:values)&#123; sum += Integer.parseInt(value.toString()); &#125;//下面三行注释和紧接着四行功能一样，只不过实现方法不一样罢了// int index = key.toString().indexOf(\"+\");// info.set(key.toString().substring(index+1)+\":\"+sum); // key.set(key.toString().substring(0,index));//对传进来的key进行拆分，以+为界 String record = key.toString(); String[] str = record.split(\"[+]\"); info.set(str[1]+\":\"+sum); key.set(str[0]); context.write(key,info); &#125; &#125; public static class Reduce extends Reducer&lt;Text,Text,Text,Text&gt;&#123; private Text result = new Text(); public void reduce(Text key,Iterable&lt;Text&gt;values,Context context) throws IOException, InterruptedException&#123; String value =new String(); for(Text value1:values)&#123; value += value1.toString()+\" ; \"; &#125; result.set(value); context.write(key,result); &#125; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException,InterruptedException &#123; // TODO Auto-generated method stub Job job = new Job(); job.setJarByClass(ReverseIndex.class); job.setNumReduceTasks(1); //设置reduce的任务数量为1，平常的小测试不需要开辟太多的reduce任务进程 job.setMapperClass(Map.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(Text.class); job.setCombinerClass(Combiner.class); job.setReducerClass(Reduce.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(Text.class); FileInputFormat.addInputPath(job, new Path(\"/thinkgamer/input\")); FileOutputFormat.setOutputPath(job, new Path(\"/thinkgamer/output\")); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://thinkgamer.cn/tags/Hadoop/"}]},{"title":"MapReducer中的多次归约处理","slug":"Hadoop/MapReducer中的多次归约处理","date":"2015-07-28T01:06:00.000Z","updated":"2019-10-14T06:42:35.655Z","comments":true,"path":"2015/07/28/Hadoop/MapReducer中的多次归约处理/","link":"","permalink":"http://thinkgamer.cn/2015/07/28/Hadoop/MapReducer中的多次归约处理/","excerpt":"我们知道，MapReduce是分为Mapper任务和Reducer任务，Mapper任务的输出，通过网络传输到Reducer任务端，作为输入。 在Reducer任务中，通常做的事情是对数据进行归约处理。既然数据来源是Mapper任务的输出，那么是否可以在Mapper端对数据进行归约处理，业务逻辑与Reducer端做的完全相同。处理后的数据再传送到Reducer端，再做一次归约。这样的好处是减少了网络传输的数量。","text":"我们知道，MapReduce是分为Mapper任务和Reducer任务，Mapper任务的输出，通过网络传输到Reducer任务端，作为输入。 在Reducer任务中，通常做的事情是对数据进行归约处理。既然数据来源是Mapper任务的输出，那么是否可以在Mapper端对数据进行归约处理，业务逻辑与Reducer端做的完全相同。处理后的数据再传送到Reducer端，再做一次归约。这样的好处是减少了网络传输的数量。 可能有人疑惑几个问题： 为什么需要在Mapper端进行归约处理？ 为什么可以在Mapper端进行归约处理？ 既然在Mapper端可以进行归约处理，为什么在Reducer端还要处理？ 回答第一个问题：因为在Mapper进行归约后，数据量变小了，这样再通过网络传输时，传输时间就变短了，减少了整个作业的运行时间。 回答第二个问题：因为Reducer端接收的数据就是来自于Mapper端。我们在Mapper进行归约处理，无非就是把归约操作提前到Mapper端做而已。 回答第三个问题：因为Mapper端的数据仅仅是本节点处理的数据，而Reducer端处理的数据是来自于多个Mapper任务的输出。因此在Mapper不能归约的数据，在Reducer端有可能归约处理。 在Mapper进行归约的类称为Combiner。那么，怎么写Combiner哪？非常简单，就是我们自定义的Reducer类。那么，怎么用哪？更简单，见如下代码 job.setCombineClass(Mapper.class) 要注意的是，Combiner只在Mapper任务所在的节点运行，不会跨Mapper任务运行。Reduce端接收所有Mapper端的输出来作为输入。虽然两边的归约类是同一个，但是执行的位置完全不一样。 并不是所有的归约工作都可以使用Combiner来做。比如求平均值就不能使用Combiner。因为对于平均数的归约算法不能多次调用。 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://thinkgamer.cn/tags/Hadoop/"},{"name":"MapReduce","slug":"MapReduce","permalink":"http://thinkgamer.cn/tags/MapReduce/"}]},{"title":"hadoop命令——hdfs","slug":"Hadoop/hadoop命令——hdfs","date":"2015-07-11T09:11:00.000Z","updated":"2019-10-14T12:28:36.834Z","comments":true,"path":"2015/07/11/Hadoop/hadoop命令——hdfs/","link":"","permalink":"http://thinkgamer.cn/2015/07/11/Hadoop/hadoop命令——hdfs/","excerpt":"hdfs是hadoop大体系下的分布式文件管理系统，是英文Hadoop Distributed File System的简写，其常用命令如下：","text":"hdfs是hadoop大体系下的分布式文件管理系统，是英文Hadoop Distributed File System的简写，其常用命令如下： 一：fs命令（和Linux终端运行命令一致，也是hdfs最常用命令） 二：其他相关命令1、hadoop 归档文件shell： hadoop archive -archiveName file.har -p /gyt/input /gyt/output (file.har为归档后的文件 /gyt/inut/为多个文件所在目录 /gyt/output/是归档后的输出目录) 2、运行JAR程序包shell：hadoop jar /home/hadoop/hadoop-1.1.2/hadoop-examples-1.1.2.jar wordcount /user/hadoop/input output（XXX.jar是程序目录，wordcount是程序入口，XXX/input是文件输入源，output是文件输出源） 4、查看HDFS状态：hadoop dfsadmin -report比如有哪些datanode，每个datanode的情况 5、离开安全模式：hadoop dfsadmin -safemode leave 6、进入安全模式： hadoop dfsadmin -safemode enter 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://thinkgamer.cn/tags/Hadoop/"}]},{"title":"Virtualbox虚拟Ubuntu系统与主机互ping","slug":"Linux/虚拟Ubuntu系统与主机互ping","date":"2015-07-08T15:04:00.000Z","updated":"2019-10-14T06:42:35.660Z","comments":true,"path":"2015/07/08/Linux/虚拟Ubuntu系统与主机互ping/","link":"","permalink":"http://thinkgamer.cn/2015/07/08/Linux/虚拟Ubuntu系统与主机互ping/","excerpt":"互ping的前提是主机和虚拟机的ip地址在同一波段【eg:主机为：192.168.1.10虚拟Linux：192.168.1.11】","text":"互ping的前提是主机和虚拟机的ip地址在同一波段【eg:主机为：192.168.1.10虚拟Linux：192.168.1.11】 1、设置主机ip打开网络共享中心-&gt;更改适配器设置-&gt;以太网，修改其ip 在主机上运行CMD输入ipconfig显示如下 2、设置虚拟机ip打开终端以root身份运行执行 sudo gedit /etc/hosts 修改如下 执行 sudo gedit /etc/network/interfaces 修改如下 执行 sudo gedit /etc/resolv.conf 修改如下 nameserver后边紧跟的是主机的DNS，不同机器对应不同 重启网络服务 sudo /etc/init.d/networking restart 关闭防火墙 sudo ufw disable 3、虚拟机网络连接设置小编亲测，若虚拟机网络格式设置错误的话是不会ping的通的，因此应该格外注意 若主机连的是WiFi，则虚拟机设置-&gt;网络-&gt;启用网络连接（桥接网卡，Realtek …… Wireless Lan …….） 若主机连的是有线网，则虚拟机设置-&gt;网络-&gt;启用网络连接（桥接网卡，Realtek PCIe GBE Family ……..） 至此，已全部设置成功，主机与虚拟机之间便可以互ping了 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thinkgamer.cn/tags/Linux/"}]},{"title":"linux-ifconfig命令配置ip地址","slug":"Linux/linux-ifconfig命令配置ip地址","date":"2015-07-08T04:31:00.000Z","updated":"2019-10-14T06:42:35.660Z","comments":true,"path":"2015/07/08/Linux/linux-ifconfig命令配置ip地址/","link":"","permalink":"http://thinkgamer.cn/2015/07/08/Linux/linux-ifconfig命令配置ip地址/","excerpt":"Linux下网卡命名规律：eth0，eth1。第一块以太网卡，第二块。lo为环回接口，它的IP地址固定为127.0.0.1，掩码8位。它代表你的机器本身。ifconfig 是查看网卡的信息 ，如果不加参数查看的是所有的网卡信息","text":"Linux下网卡命名规律：eth0，eth1。第一块以太网卡，第二块。lo为环回接口，它的IP地址固定为127.0.0.1，掩码8位。它代表你的机器本身。ifconfig 是查看网卡的信息 ，如果不加参数查看的是所有的网卡信息 加上参数eth0的话是查看eth0网卡的信息 网卡信息的一些解释：第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址） 第二三行：网卡的IP地址、子网、掩码 第四行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节 www.2cto.com 下面就是接收、发送数据包情况统计和发送接受数据字节数的统计信息。 配置网卡的IP地址 ifconfig eth0 192.168.168.64 netmask 255.255.255.0 在eth0上配置上192.168.168.64 的IP地址及子网掩码。 配置网卡的硬件地址ifconfig eth0 hw ether xx：xx：xx：xx：xx：xx 禁用网卡eth0ifconfig eth0 down 启用网卡eth0ifconfig eth0 up 另外启动和禁用网卡还可以使用ifup | ifdown eth0 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://thinkgamer.cn/tags/linux/"}]},{"title":"二、hadoop伪分布搭建","slug":"Hadoop/二、hadoop伪分布搭建","date":"2015-07-07T12:14:00.000Z","updated":"2019-10-14T12:28:36.835Z","comments":true,"path":"2015/07/07/Hadoop/二、hadoop伪分布搭建/","link":"","permalink":"http://thinkgamer.cn/2015/07/07/Hadoop/二、hadoop伪分布搭建/","excerpt":"本文主要介绍Hadoop的伪分布安装，基于Ubuntu14.04进行。","text":"本文主要介绍Hadoop的伪分布安装，基于Ubuntu14.04进行。 环境虚拟机：VirtualBoxUbuntu:14.04hadoop:2.6 安装1、创建hadoop用户sudo useradd -m hadoop -s/bin/bash【Ubuntu终端复制粘贴快捷键】【在Ubuntu终端窗口中，复制粘贴的快捷键需要加上shift，即粘贴是 ctrl+shift+v。】使用如下命令修改密码，按提示输入两次密码 hadoop : 1sudo passwd hadoop 可为 hadoop 用户增加管理员权限，方便部署，避免一些对新手来说比较棘手的权限问题：1sudo adduser hadoop sudo 2、切换到hadoop用户下1su hadoop 3、安装SSH server、配置SSH无密码登陆集群、单节点模式都需要用到SSH登陆（类似于远程登陆，你可以登录某台Linux电脑，并且在上面运行命令），Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server：1sudo apt-get install openssh-server 安装后，可以使用如下命令登陆本机：1ssh localhost 此时会有提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码hadoop，这样就登陆到本机了。 但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。 首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中：1234exit # 退出刚才的 ssh localhostcd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa # 会有提示，都按回车就可以cat id_rsa.pub &gt;&gt; authorized_keys # 加入授权 此时再用 ssh localhost 命令，无需输入密码就可以直接登陆此时再用 ssh localhost 命令，无需输入密码就可以直接登陆 4、安装Java环境Java环境可选择 Oracle 的 JDK，或是 OpenJDK，按http://wiki.apache.org/hadoop/HadoopJavaVersions中说的，新版本在 OpenJDK 1.7 下是没问题的。为图方便，这边直接通过命令安装 OpenJDK 7。1sudo apt-get install openjdk-7-jre openjdk-7-jdk OpenJDK 默认的安装位置为: /usr/lib/jvm/java-7-openjdk-amd64 (32位系统则是 /usr/lib/jvm/java-7-openjdk-i86 ，可通过命令dpkg -L openjdk-7-jdk查看到)。安装完后就可以使用了，可以用java -version 检查一下。 接着需要配置一下 JAVA_HOME 环境变量，为方便，我们在 ~/.bashrc 中进行设置（扩展阅读:设置Linux环境变量的方法和区别）：1vi ~/.bashrc 在文件最前面添加如下单独一行（注意 = 号前后不能有空格），并保存：1export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64 如下图所示（该文件原本可能不存在，内容为空，这不影响）： 配置JAVA_HOME变量 接着还需要让该环境变量生效，执行如下代码：12source ~/.bashrc# 使变量设置生效echo $JAVA_HOME# 检验是否设置正确 设置正确的话，会输出如下结果： 成功配置JAVA_HOME变量 5、安装hadoop进入hadoop所在的目录将其解压到/usr/local/hadoop12345sudo tar -zxvf ./hadoop-2.6.0.tar.gz -C /usr/local # 解压到/usr/local中cd /usr/local/sudo mv ./hadoop-2.6.0/ ./hadoop # 将文件夹名改为hadoopsudo chown -R hadoop:hadoop ./hadoop # 修改文件权限 Hadoop解压后即可使用。输入如下命令来检查 Hadoop是否可用，成功则会显示命令用法：12cd ./hadoop./bin/hadoop 6、hadoop伪分布配置Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件core-site.xml 和hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。 修改配置文件 core-site.xml (vim /usr/local/hadoop/etc/hadoop/core-site.xml)，将当中的12&lt;configuration&gt;&lt;/configuration&gt; 修改为下面配置：1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 同样的，修改配置文件 hdfs-site.xml：1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改配置文件yarn-site.xml12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 配置完成后，执行 namenode 的格式1bin/hdfs namenode -format 成功的话，会看到successfully formatted 的提示，且倒数第5行的提示如下，Exitting with status 0 表示成功，若为Exitting with status 1 则是出错 接着开启如下进程12sbin/start-dfs.shsbin/start-yarn.sh 至此，所有的已经安装完事，且所有服务都已经启动 验证http://127.0.0.1:8088 http://localhost:50070 提示每次进入虚拟机系统时必须先进入hadoop用户下（su hadoop），才能开启服务，否则会报错参考文章：www.powerxing.com/install-hadoop/ QQ交流：1923361654 hadoop完全分布式部署参考：http://blog.csdn.net/gamer_gyt/article/details/51991893 hadoop单机版部署参考：http://blog.csdn.net/gamer_gyt/article/details/46545303 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://thinkgamer.cn/tags/Hadoop/"}]},{"title":"MySQLdb的安装与使用","slug":"Python/MySQLdb的安装与使用","date":"2015-07-05T03:44:00.000Z","updated":"2019-10-14T06:42:35.662Z","comments":true,"path":"2015/07/05/Python/MySQLdb的安装与使用/","link":"","permalink":"http://thinkgamer.cn/2015/07/05/Python/MySQLdb的安装与使用/","excerpt":"安装已编译版本(此方法简便快捷): http://www.codegood.com/downloads 根据自己系统下载，双击安装，搞定，然后import MySQLdb，查看是否成功","text":"安装已编译版本(此方法简便快捷): http://www.codegood.com/downloads 根据自己系统下载，双击安装，搞定，然后import MySQLdb，查看是否成功 安装我的，win7,32位，2.7版本 MySQL-python-1.2.3.win-amd32-py2.7.exe 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python# encoding: utf-8import time,MySQLdb# 打开数据库连接db = MySQLdb.connect(\"localhost\",\"root\",\"root\",\"Python\" )# 使用cursor()方法获取操作游标cursor = db.cursor()#删除表sql = \"drop table if exists thinkgamer\"cursor.execute(sql)#创建sql = \"create table if not exists thinkgamer(name varchar(128) primary key,created int(10))\"cursor.execute(sql)#写入sql = \"insert into thinkgamer(name,created) values(%s,%s)\"param = (\"aaa\",int(time.time()))n = cursor.execute(sql,param)print 'insert',n#写入多行sql = \"insert into thinkgamer(name,created) values(%s,%s)\"param = ((\"bbb\",int(time.time())),(\"ccc\",33),(\"ddd\",44))n = cursor.executemany(sql,param)print \"insertmany\",n#更新sql= \"update thinkgamer set name=%s where name='aaa'\"param = (\"zzz\")n = cursor.execute(sql,param)print \"updata\",n#查询n = cursor.execute(\"select * from thinkgamer\")for row in cursor.fetchall(): print row for r in row: print r#删除sql = \"delete from thinkgamer where name =%s\"param = (\"bbb\")n = cursor.execute(sql,param)print \"delete\",n#查询n = cursor.execute(\"select * from thinkgamer\")print cursor.fetchall()cursor.close()#提交db.commit()#关闭db.close()输出结果：insert 1insertmany 3updata 1('zzz', 1436067892L)zzz1436067892('bbb', 1436067892L)bbb1436067892('ccc', 33L)ccc33('ddd', 44L)ddd44delete 1(('zzz', 1436067892L), ('ccc', 33L), ('ddd', 44L)) 更多详情请戳：MySQLdb User’s Guide 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkgamer.cn/tags/Python/"}]},{"title":"VirtualBox共享文件夹设置及开机自动挂载","slug":"Linux/VirtualBox共享文件夹设置及开机自动挂载","date":"2015-06-28T15:22:00.000Z","updated":"2019-10-14T06:42:35.659Z","comments":true,"path":"2015/06/28/Linux/VirtualBox共享文件夹设置及开机自动挂载/","link":"","permalink":"http://thinkgamer.cn/2015/06/28/Linux/VirtualBox共享文件夹设置及开机自动挂载/","excerpt":"首先声明：本人的Vbox虚拟机里装的是Ubuntu，本机是windows","text":"首先声明：本人的Vbox虚拟机里装的是Ubuntu，本机是windows 1、用VirtualBox虚拟机的共享文件夹设置共享的本地文件（我的是设置的是本地E盘，java文件夹） 2、进入虚拟机Ubuntu系统，打开终端，用root用户操作（sudo -s回车输入密码）首先在虚拟机上创建一个共享目录 eg:mkdir /mnt/share 实现挂载 mount -t vboxsf java /mnt/share （java为本机windows上设置的共享文件夹） 再次进入 /mnt/share 目录下就可以看到windows下java内的文件了 3、实现开机自动挂载功能PS：网上查到了资料基本都是说在/etc/fstab 文件末添加一项 /etc/fstab 文件末添加一项1sharing /mnt/share vboxsf defaults 0 0 (或者sharing /mnt/share vboxsf rw,gid=100,uid=1000,auto 0 0） 注意！！！但我试了N遍，证明这是不好使的。 正确的解决办法是： 在文件 /etc/rc.local 中（用root用户）追加如下命令1mount -t vboxsf java /mnt/share 电脑关机在开机就好使了（小编亲测） 另外，在 VirtualBox 4.x 版本中，已有一个“自动挂载”功能，如下图所示： 再使用命令 mount实现挂载它自动把这些共享文件夹挂载到 /media/ ，目录下了，我想要说的是，这个挂载目录不是我想要的，所以我没采用VirtualBox的自动挂载功能（因为挂载目录自己不可控）。 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://thinkgamer.cn/tags/linux/"}]},{"title":"VirtualBox导入XXXX.vdi时报错","slug":"Linux/VirtualBox导入XXXX-vdi时报错","date":"2015-06-27T02:21:00.000Z","updated":"2019-10-14T06:42:35.659Z","comments":true,"path":"2015/06/27/Linux/VirtualBox导入XXXX-vdi时报错/","link":"","permalink":"http://thinkgamer.cn/2015/06/27/Linux/VirtualBox导入XXXX-vdi时报错/","excerpt":"virtualbox导入vdi文件时出现下面的问题：","text":"virtualbox导入vdi文件时出现下面的问题： 解决方法： windows+R，输入cmd,进入virtualbox的安装目录（或者在硬盘中直接进入virtualbox的安装目录，在任务栏里输入cmd），输入VBoxManage internalcommands setvdiuuid D:\\path\\ubuntu.vdi 注意，在virtualbox4.0.4以上该命令改为 VBoxManage internalcommands sethduuid D:\\path\\ubuntu.vdi 然后重新导入即可。 这是一个重新设置UUID（通用唯一识别码）号的命令，VirtualBox没有集成到GUI环境中，只能在命令行中使用。 什么是UUID？ 请点击UUID请点击UUID 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://thinkgamer.cn/tags/linux/"}]},{"title":"新浪明星日志热门推荐（java实现）","slug":"Java/新浪明星日志热门推荐（java实现）","date":"2015-06-19T00:15:00.000Z","updated":"2019-10-14T06:42:35.658Z","comments":true,"path":"2015/06/19/Java/新浪明星日志热门推荐（java实现）/","link":"","permalink":"http://thinkgamer.cn/2015/06/19/Java/新浪明星日志热门推荐（java实现）/","excerpt":"现在进行推荐的三步如下：","text":"现在进行推荐的三步如下： 1:利用数据的格式如下 2：编程语言采用的是Java，源代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package top10;import java.util.*;import java.io.*;public class top &#123; public static void top(String []one,String []two,String []three)&#123; int []one1 = new int[15688]; for(int i =0;i&lt;15687;i++) &#123; one1[i]=0; for(int j=i;j&lt;15688;j++) if(one[j]==one[i]) &#123; one1[i]++; &#125; &#125; for(int i =0;i&lt;15688;i++) for(int j=i;j&lt;15688;j++) if(one1[i]&gt;one1[j]) &#123; String temp1; temp1=one[i]; one[i]=one[j]; one[j]=temp1; String temp2; temp2=two[i]; two[i]=two[j]; two[j]=temp2; String temp3; temp3=three[i]; three[i]=three[j]; three[j]=temp3; &#125; System.out.println(\"Top前十的结果为：\"); System.out.println(\"姓名\\t\"+\"\\t推荐博客地址\"+\"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"+\"推荐作者博客首地址\"); for(int k=1;k&lt;=10;k++) &#123; String str; str = String.format(\"%s\\t\\t%s\\t\\t%s\", one[k],two[k],three[k]); System.out.println(str); &#125; &#125; public static void list() throws IOException&#123; FileReader in = new FileReader(\"title.txt\"); BufferedReader br = new BufferedReader(in); String s1 = null; String []one = new String[15688]; String []two = new String[15688]; String []three = new String[15688]; int i = 0,k=0,m=0,j = 1; while((s1 = br.readLine()) != null) &#123; if(j%3==2) &#123; two[k] = s1; k++; &#125; else if(j%3==0) &#123; three[m] = s1; m++; &#125; else &#123; one[i] = s1; i++; &#125; j++; &#125; br.close(); in.close();// System.out.println(j); top(one,two,three); &#125; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub System.out.println(\"+++++++++++++++++|||||||||||||||++++++++++++++++++\"); System.out.println(\"**************欢迎使用新浪明星博客推荐系统 ***************\"); System.out.println(\"************** 1、使用推荐功能 ***************\"); System.out.println(\"************** 2、退出此系统,谢谢使用 ***************\"); System.out.println(\"+++++++++++++++++|||||||||||||||++++++++++++++++++\"); Scanner in = new Scanner(System.in); while(true) &#123; int i = in.nextInt(); &#123; switch(i) &#123; case 1: list();break; case 2:System.out.println(\"谢谢使用！！！\");break; default:System.out.println(\"请重新输入！！！\"); &#125; &#125; &#125; &#125;&#125; 3：运行的结果如图 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thinkgamer.cn/tags/Java/"}]},{"title":"一、Hadoop2.6.0单机模式配置","slug":"Hadoop/一、Hadoop2-6-0单机模式配置","date":"2015-06-18T02:49:00.000Z","updated":"2019-10-14T06:42:35.656Z","comments":true,"path":"2015/06/18/Hadoop/一、Hadoop2-6-0单机模式配置/","link":"","permalink":"http://thinkgamer.cn/2015/06/18/Hadoop/一、Hadoop2-6-0单机模式配置/","excerpt":"增加hadoop用户组，同时在该组里增加hadoop用户，后续在涉及到hadoop操作时，我们使用该用户。","text":"增加hadoop用户组，同时在该组里增加hadoop用户，后续在涉及到hadoop操作时，我们使用该用户。 一、在Ubuntu下创建hadoop组和hadoop用户1、创建hadoop用户组 2、创建hadoop用户1sudo adduser -ingroup hadoop hadoop 回车后会提示输入新的UNIX密码，这是新建用户hadoop的密码，输入回车即可。 如果不输入密码，回车后会重新提示输入密码，即密码不能为空。 最后确认信息是否正确，如果没问题，输入 Y，回车即可。 3、为hadoop用户添加权限输入：sudo gedit /etc/sudoers回车，打开sudoers文件给hadoop用户赋予和root用户同样的权限 二、用新增加的hadoop用户登录Ubuntu系统三、安装ssh1sudo apt-get install openssh-server 安装完成后，启动服务1sudo /etc/init.d/ssh start 查看服务是否正确启动1ps -e | grep ssh 设置免密码登录，生成私钥和公钥1ssh-keygen -t rsa -P \"\" 此时会在／home／hadoop/.ssh下生成两个文件：id_rsa和id_rsa.pub，前者为私钥，后者为公钥。 下面我们将公钥追加到authorized_keys中，它用户保存所有允许以当前用户身份登录到ssh客户端用户的公钥内容。1cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 登录ssh1ssh localhost 退出1exit 四、安装Java环境1sudo apt-get install openjdk-7-jdk 查看安装结果，输入命令：java -version，结果如下表示安装成功。 五、安装hadoop2.4.01、官网下载http://mirror.bit.edu.cn/apache/hadoop/common/2、安装解压1sudo tar xzf hadoop-2.4.0.tar.gz 假如我们要把hadoop安装到/usr/local下拷贝到/usr/local/下，文件夹为hadoop1sudo mv hadoop-2.4.0 /usr/local/hadoop 赋予用户对该文件夹的读写权限1sudo chmod 774 /usr/local/hadoop 3、配置1）配置~/.bashrc配置该文件前需要知道Java的安装路径，用来设置JAVA_HOME环境变量，可以使用下面命令行查看安装路径1update-alternatives - -config java 执行结果如下： 完整的路径为 1/usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java 我们只取前面的部分 /usr/lib/jvm/java-7-openjdk-amd64配置.bashrc文件1sudo gedit ~/.bashrc 该命令会打开该文件的编辑窗口，在文件末尾追加下面内容，然后保存，关闭编辑窗口。123456789101112#HADOOP VARIABLES STARTexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export HADOOP_INSTALL=/usr/local/hadoopexport PATH=$PATH:$HADOOP_INSTALL/binexport PATH=$PATH:$HADOOP_INSTALL/sbinexport HADOOP_MAPRED_HOME=$HADOOP_INSTALLexport HADOOP_COMMON_HOME=$HADOOP_INSTALLexport HADOOP_HDFS_HOME=$HADOOP_INSTALLexport YARN_HOME=$HADOOP_INSTALLexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_INSTALL/lib/nativeexport HADOOP_OPTS=\"-Djava.library.path=$HADOOP_INSTALL/lib\"#HADOOP VARIABLES END 最终结果如下图： 执行下面命，使添加的环境变量生效：1source ~/.bashrc 2）编辑/usr/local/hadoop/etc/hadoop/hadoop-env.sh执行下面命令，打开该文件的编辑窗口1sudo gedit /usr/local/hadoop/etc/hadoop/hadoop-env.sh 找到JAVA_HOME变量，修改此变量如下1export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64 修改hadoop-env.sh文件 六、WordCount测试单机模式安装完成，下面通过执行hadoop自带实例WordCount验证是否安装成功： 在/usr/local/hadoop路径下创建input文件夹：12mkdir input(或 sudo mkdir /usr/local/hadoop/input) 拷贝README.txt到input：1cp README.txt input 执行WordCount：1bin/hadoop jarshare/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.4.0-sources.jarorg.apache.hadoop.examples.WordCount input output 执行1cat output/* 查看字符统计结果 至此，单机模式安装成功！ hadoop伪分布部署参考：点击打开链接 hadoop完全分布式部署参考：点击打开链接 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://thinkgamer.cn/tags/Hadoop/"}]},{"title":"Ubuntu下终端闪退","slug":"Linux/Ubuntu下终端闪退","date":"2015-03-22T03:45:00.000Z","updated":"2019-10-14T06:42:35.659Z","comments":true,"path":"2015/03/22/Linux/Ubuntu下终端闪退/","link":"","permalink":"http://thinkgamer.cn/2015/03/22/Linux/Ubuntu下终端闪退/","excerpt":"执行命令1sudo ls -al / | grep tmp","text":"执行命令1sudo ls -al / | grep tmp 继续执行命令：1sudo chmod 1777 /temp 即可 附：关于tmp的相关说明： http://www.ubuntu-tw.org/modules/newbb/viewtopic.php?viewmode=compact&amp;topic_id=11904&amp;forum=2 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thinkgamer.cn/tags/Linux/"}]},{"title":"Java文件的写入与读出","slug":"Java/Java文件的写入与读出","date":"2015-03-17T07:19:00.000Z","updated":"2019-10-14T06:42:35.658Z","comments":true,"path":"2015/03/17/Java/Java文件的写入与读出/","link":"","permalink":"http://thinkgamer.cn/2015/03/17/Java/Java文件的写入与读出/","excerpt":"由于要将爬虫的结果写到文件里，就自己晚上搜了一点资料，看了别人的博客，补充了一点文件的基础知识，现将其整理如下，供大家参考 Java文件的写入和读出有很多种方法我所介绍的主要是Read/Writer，OutputStream/InputStream","text":"由于要将爬虫的结果写到文件里，就自己晚上搜了一点资料，看了别人的博客，补充了一点文件的基础知识，现将其整理如下，供大家参考 Java文件的写入和读出有很多种方法我所介绍的主要是Read/Writer，OutputStream/InputStream 一：Read/Writer由于Java本身可以导入许多包，在这里可以直接调用Java的io，语句是 import java.io；本人是将FileWriter和FileRead理解为一个类，分别定义了两个对象，FileWriter gyt = new FileWriter(“Thinkgamer.txt”);FileReader out = new FileReader(“Thinkgamer.txt”);使用gyt.write(str,int,int)将其写入到.txt格式的文件里，再用ch = out.read()将其输出。其完整代码如下123456789101112131415161718192021222324252627package Thinkgamer;import java.io.*;public class cyan &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String str = \"Thinkgamer QQ is 1923361654\"; try&#123; FileWriter gyt = new FileWriter(\"Thinkgamer.txt\"); gyt.write(str,0,str.length()); gyt.flush(); FileReader out = new FileReader(\"Thinkgamer.txt\"); int ch = 0; while((ch = out.read())!=-1)&#123; System.out.print((char)ch); &#125; &#125; catch(Exception as)&#123; as.printStackTrace(); &#125; &#125;&#125; 二：OutputStream/InputStream1234567891011121314151617181920212223242526272829303132package Thinkgamer;import java.io.*;public class cyan &#123; public static void main(String[] args) &#123; String str = \"Thinkgamer QQ is 1923361654\"; try&#123; // OutputStream gyt = new FileOutputStream(\"Thinkgamer.txt\"); // OutputStreamWriter out = new OutputStreamWriter(gyt); OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(\"Thinkgamer.txt\")); FileInputStream in = new FileInputStream(\"Thinkgamer.txt\"); out.write(str,0,str.length()); out.flush(); for(int i =0;i &lt; str.length();i++) &#123; System.out.print((char)in.read()); &#125; &#125; catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125; &#125; 特别注意：//在使用文件之后注意将文件关闭//关闭的语句是gyt.flush();//gyt为Read/Writer或OutputStream/InputStream所创建的一个对象OutputStream/InputStream的理解和Read/Writer方法差不多，在这里小编只将本人写的代码贴出来 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thinkgamer.cn/tags/Java/"}]},{"title":"Python中try...except...finally的理解","slug":"Python/Python中try-except-finally的理解","date":"2015-01-05T15:24:00.000Z","updated":"2019-10-14T06:42:35.662Z","comments":true,"path":"2015/01/05/Python/Python中try-except-finally的理解/","link":"","permalink":"http://thinkgamer.cn/2015/01/05/Python/Python中try-except-finally的理解/","excerpt":"首先我们打开一个不存在的文件： 1fp = open(\"null.txt\",\"r\") 然后提示报错如下：","text":"首先我们打开一个不存在的文件： 1fp = open(\"null.txt\",\"r\") 然后提示报错如下： 12345IOErro Traceback (most recent call last) &lt;ipython-input-3-f70973547c7e&gt; in &lt;module&gt;() ----&gt; 1 fp = open(\"null.txt\",\"r\") IOError: [Errno 2] No such file or directory: 'null.txt' 接着我们使用try…except…来执行这条语句 123456In [4]: try: ...: fp = open(\"null.txt\",\"r\") ...: except: ...: print \"open error\" ...: open error 接着我们再在后面加一条finally语句，所谓的filally就是最后要执行的，它不管你前边是否发送错误123456789In [4]: try: ...: fp =open('null.txt','r') ...: except: ...: print 'opoen error' ...: finally: ...: print 'end' ...: opoen error end 接着我们使用except打印出错误类型，然后观察错误的type 12345678In [5]: try: ...: fp = open('null.txt','r') ...: except Exception,e: ...: print e ...: print type(e) ...: [Errno 2] No such file or directory: 'null.txt' &lt;type 'exceptions.IOError'&gt; 我们可以看到except把错误捕捉到赋值给e，然后将其打印出，可以看到为IOError，所以在这里我们可以修改上边为：123456In [9]: try: ...: fp = open('null.txt', 'r') ...: except IOError,e: ...: print \"ioerror\" ...: ioerror 当然这里如果不是IOError的话，上边except语句是捕捉不到的，例如： 123456789101112131415In [10]: try: ....: a = 10/0 ....: except IOError,e: ....: print \"ioerror\" ....: --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) &lt;ipython-input-10-e17eff88239d&gt; in &lt;module&gt;() 1 try: ----&gt; 2 a = 10/0 3 except IOError,e: 4 print \"ioerror\" 5 ZeroDivisionError: integer division or modulo by zero 这时我们需要另外的错误类型进行捕获，例如：12345678In [11]: try: ....: a = 10/0 ....: except IOError,e: ....: print \"IOError\" ....: except ZeroDivisionError,e: ....: print \"Zero Error\" ....: Zero Error 可以看到第一个except并没有捕捉到错误，所以传给下一个except，当然如果所有的except都没有捕获到的话，程序就会抛出异常在这里我们不得不注意的是，python的错误类型其实都是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：12345678In [14]: try: ....: a = 10 /0 ....: except StandardError,e: ....: print 'standardError' ....: except ZeroDivisionError,e: ....: print 'zero error' ....: standardError 第二个except永远也捕获不到ValueError，因为ZeroDivisionError是StandardError的子类，如果有，也被第一个except给捕获了。使用try…except…finally的另外一个好处是，可以跨越多层调用，例如： 12345678910111213141516171819In [15]: def foo(m): ....: return 10/int(m) ....: In [16]: def goo(): ....: a = \"0\" ....: foo(a) ....: In [17]: def main(): ....: goo() ....: In [18]: try: ....: main() ....: except Exception,e: ....: print e ....: integer division or modulo by zero 在foo()函数中抛出的错误，然而在goo和main函数中都没有进行捕捉，在执行main函数时进行捕获，也可以捕获到 除了try…except…finally之外还有python的logging模块，也可以进行错误调试，当然我们也可以使用raise抛出异常 打开微信扫一扫，关注公众号【搜索与推荐Wiki】","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://thinkgamer.cn/categories/技术篇/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkgamer.cn/tags/Python/"}]},{"title":"逝去的夏天","slug":"随手记/逝去的夏天","date":"2013-10-01T06:21:17.000Z","updated":"2019-10-14T06:42:35.694Z","comments":true,"path":"2013/10/01/随手记/逝去的夏天/","link":"","permalink":"http://thinkgamer.cn/2013/10/01/随手记/逝去的夏天/","excerpt":"那年的夏天，我们拎起书包 无奈的走向，复习班的怀抱 幻想一年后，大学生活的逍遥 寂寥与苦恼，我们一起去熬","text":"那年的夏天，我们拎起书包 无奈的走向，复习班的怀抱 幻想一年后，大学生活的逍遥 寂寥与苦恼，我们一起去熬 月光下，漫步操场，有人和心爱姑娘倾诉着衷肠 听着歌，踏进流年，哼出那动人的歌谣在嘴边 到夜晚，傻傻发呆，等待她回复美丽的笑颜 被窝里，谁流着泪，望着椭圆和磁场，画出无尽的茫然 表示从下课到上课的铃声原来一直没变 表示老班面庞带着囧样长的多荒唐 看着钟摆晃荡 时光飞扬 还有可爱姑娘 看着曾经传出的纸条 跨过几人几肩膀 我们追逐梦想，奔向希望，一路走来跌跌又撞撞 留下汗水 擦干眼泪向前一起闯 考试和爱情的守望多么令人向往 各种壮丽诗行和篇章从此不会再彷徨 多年后，你若想念，我们一直都坚持的笑颜 多年后，你若怀念，课堂上睡觉的瓜子脸 都说吃他的菜喝他的汤钱照样会花光 都说拍她的肩请她吃糖一笑为红颜 都说一分一秒努力学习或者传纸条 都说会把功劳全都记在流年的怀抱 我们即将高考，分别之后，奔波在中国不同角落 瞥见短发女孩，还会以为是我心动那个谁 蕾峰彩月金豆同桌，某某我等你 也许彼此把彼此丢进记忆的流年 但记得那排我们快乐的日子 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/tags/随手记/"}]},{"title":"十八岁，半夏锦年","slug":"随手记/十八岁，半夏锦年","date":"2012-06-10T06:25:51.000Z","updated":"2019-10-14T06:42:35.692Z","comments":true,"path":"2012/06/10/随手记/十八岁，半夏锦年/","link":"","permalink":"http://thinkgamer.cn/2012/06/10/随手记/十八岁，半夏锦年/","excerpt":"送走了我的青春，迎来我未知的迷惘，将来我会身在何方，我将永世不忘。 再见！","text":"送走了我的青春，迎来我未知的迷惘，将来我会身在何方，我将永世不忘。 再见！ 散落一地，流离 回忆不起，青石板长巷的雨季 独自撑伞，没有你陪伴的故地 簌簌樱花，零落成思绪 一场雨，让我离开这里 出其不意，燕啄泥 诉说那十八岁半夏锦年 未完的结局 风萧萧，雨寒寒 断了谁的琴弦，无语问寒蝉 倚窗边，空白回忆里 艰难婉转… 打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】","categories":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"http://thinkgamer.cn/tags/随手记/"}]}]}