<!DOCTYPE html>
<html lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Thinkgamer的博客">
    <meta name="keyword"  content="Python,Django,爬虫,Hadoop,Maching Learning,数据挖掘,机器学习,云计算,大数据,深度学习,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,用户体验">
    <link rel="shortcut icon" href="/assets/img/favicon.ico">

    <title>
        
        常见的五种神经网络(2)-卷积神经网络 - Thinkgamer的博客 | Thinkgamer&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> All In CTR、DL、ML、RL、NLP、KG </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/assets/img/head.jpg" />
        </div>
        <div class="name">
            <i>Thinkgamer</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#卷积的概念"><span class="toc-text">卷积的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一维卷积"><span class="toc-text">一维卷积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二维卷积"><span class="toc-text">二维卷积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#互相关"><span class="toc-text">互相关</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常见的卷积核及特征"><span class="toc-text">常见的卷积核及特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的卷积核"><span class="toc-text">常见的卷积核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#卷积核的特征"><span class="toc-text">卷积核的特征</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#卷积的变种"><span class="toc-text">卷积的变种</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#卷积的数学性质"><span class="toc-text">卷积的数学性质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#交换性"><span class="toc-text">交换性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#导数"><span class="toc-text">导数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#卷积神经网络"><span class="toc-text">卷积神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#用卷积代替全连接"><span class="toc-text">用卷积代替全连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#卷积层"><span class="toc-text">卷积层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇聚层"><span class="toc-text">汇聚层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全连接层"><span class="toc-text">全连接层</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#典型的卷积网络结构"><span class="toc-text">典型的卷积网络结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参数学习"><span class="toc-text">参数学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#误差项的计算"><span class="toc-text">误差项的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#卷积层-1"><span class="toc-text">卷积层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#汇聚层-1"><span class="toc-text">汇聚层</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#几种典型的卷积神经网络"><span class="toc-text">几种典型的卷积神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeNet-5"><span class="toc-text">LeNet-5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AlexNet"><span class="toc-text">AlexNet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inception"><span class="toc-text">Inception</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#残差网络"><span class="toc-text">残差网络</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他卷积方式"><span class="toc-text">其他卷积方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#转置卷积"><span class="toc-text">转置卷积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空洞卷积"><span class="toc-text">空洞卷积</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> All In CTR、DL、ML、RL、NLP、KG </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        <div class="post-container">
    <div class="post-title">
        常见的五种神经网络(2)-卷积神经网络
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-09-05 18:05:24</span></span>
        
        <span class="attr">标签：/
            
            <a class="tag" href="/tags/#神经网络" title="神经网络">神经网络</a>
            <span>/</span>
            
            
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span>
        </span>
    </div>
    <div class="post-content no-indent">
        <p><img src="https://img-blog.csdnimg.cn/2019090518010966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<p>该系列的其他文章：</p>
<ul>
<li><a href="https://blog.csdn.net/Gamer_gyt/article/details/89459131" target="_blank" rel="external">常见的五种神经网络(1)-前馈神经网络</a></li>
<li><a href="https://blog.csdn.net/Gamer_gyt/article/details/100531593" target="_blank" rel="external">常见的五种神经网络(2)-卷积神经网络</a></li>
<li><a href="https://blog.csdn.net/Gamer_gyt/article/details/100600661" target="_blank" rel="external">常见的五种神经网络(3)-循环神经网络(上篇)</a></li>
<li><a href="https://blog.csdn.net/Gamer_gyt/article/details/100709422" target="_blank" rel="external">常见的五种神经网络(3)-循环神经网络(中篇)</a></li>
<li><a href="https://thinkgamer.blog.csdn.net/article/details/100943664" target="_blank" rel="external">常见的五种神经网络(3)-循环神经网络(下篇)</a></li>
<li>常见的五种神经网络(4)-深度信念网络</li>
<li>常见的五种神经网络(5)-生成对抗网络</li>
</ul>
<hr>
<blockquote>
<p>卷积神经网络（Convolutional Neural Network）是一种具有局部连接，权重共享等特性的深层前馈神经网络。一般是由卷积层，汇聚层，全连接层交叉堆叠而成，使用反向传播算法进行训练。其有三个结构上的特征：局部连接，权重共享以及汇聚。这些特征使得卷积神经网络具有一定程度上的平移，缩放和旋转不变性。较前馈神经网络而言，其参数更少。</p>
</blockquote>
<p>卷积神经网络目前主要应用在图像和视频分析的各种任务上，比如图像分类，人脸识别，物体识别，图像分割等，其准确率也远远超过了其他的人工神经网络。近年来，卷积神经网络也应用到自然语言处理和推荐系统等领域。</p>
<h1 id="卷积的概念"><a href="#卷积的概念" class="headerlink" title="卷积的概念"></a>卷积的概念</h1><p>卷积（Convolution）也叫摺积，是分析数学中一种重要的运算。在信号处理或者图像处理中，会经常使用一维或二维卷积。</p>
<h2 id="一维卷积"><a href="#一维卷积" class="headerlink" title="一维卷积"></a>一维卷积</h2><p>一维卷积经常用在信号处理上，用来计算信号的累积。假设一个信号发生器每个时刻t发生一个信号 $x_t$，其信号衰减率维$w_k$，即在$k-1$时刻后，信息变为原来的$w_k$倍，假设$w_1 = 1, w_2=1/2,w_3=1/4$那么在t时刻收到的信号$y_t$为当前时刻产生的信息之前时刻产生的延迟信息的叠加(公式1.1)。</p>
<script type="math/tex; mode=display">
y_t = 1 * x_t + 1/2 * x_{t-1} + 1/4 * x_{t-2}
\\
=w_1 * x_t + w_2 * x_{t-1} + w_3 * x{t-2}
\\
= \sum_{k=1}^{3} w_k * x_{t-k+1}</script><p>我们把$w_1, w_2, ….$称为滤波器（Filter）或者卷积核（Convolution Kernel）。假设滤波器长度为m，它和一个信号序列$x_1,x_2,…$的卷积为(公式1.2)：</p>
<script type="math/tex; mode=display">\sum_{k=1}^{m} w_k * x_{t-k+1}</script><p>信号序列x和滤波器w的卷积定义为(公式1.3)：</p>
<script type="math/tex; mode=display">y = w \otimes  x</script><p>一维卷积示例如下：<br><img src="https://img-blog.csdnimg.cn/20190904075135300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="一维卷积神经网络"></p>
<h2 id="二维卷积"><a href="#二维卷积" class="headerlink" title="二维卷积"></a>二维卷积</h2><p>卷积也常用在图像处理中，因为图像是一个二维结构，需要对一维卷积进行扩展。给定一个图像$X \in R^{M<em>N}$和滤波器$W \in R^{m</em>n}$，一般$m &lt;&lt; M, n &lt;&lt;N$，其卷积为(公式1.4)：</p>
<script type="math/tex; mode=display">
y_{ij}=\sum_{u=1}^{M}\sum_{v=1}^{N} w_{uv} * x_{i-u+1,j-v+1}</script><p>二维卷积示例如下：<br><img src="https://img-blog.csdnimg.cn/20190904080806425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="二维卷积示例"></p>
<blockquote>
<p>注意：上图中的展示的卷积核（3*3矩阵）和二维结构数据相乘时需要逆时针旋转180度！对照着卷积公式可以理解。</p>
</blockquote>
<h2 id="互相关"><a href="#互相关" class="headerlink" title="互相关"></a>互相关</h2><p>在计算卷积过程中，需要进行卷积核翻转，在具体实现上一般会以互相关操作来代替卷积，从而会减少一些不必要的操作或者开销。互相关是一个衡量两个序列相关性的函数，通常是用滑动窗口的点积计算来实现。给定一个图像$X \in R^{M<em>N}$和卷积核$W \in R^{m</em>n}$，他们的互相关为(公式1.5)：</p>
<script type="math/tex; mode=display">
y_{ij}=\sum_{u=1}^{M}\sum_{v=1}^{N} w_{uv} * x_{i+u-1,j+v-1}</script><p>和公式1.4相比，互相关和卷积的区别在于是否对卷积核进行翻转，因此互相关也称为不翻转卷积。</p>
<p>在神经网络中使用卷积是为了进行特征抽取，卷积核是否进行核翻转与其特征抽取能力无关。特别是当卷积核是可学习的参数时，卷积和互相关是等价的，因此为了实现方便，通常使用互相关来代替卷积。事实上很多深度学习工具中卷积操作都是用互相关来代替的。</p>
<p>公式1.5可以表示为：</p>
<script type="math/tex; mode=display">
Y = W \otimes X</script><hr>
<h1 id="常见的卷积核及特征"><a href="#常见的卷积核及特征" class="headerlink" title="常见的卷积核及特征"></a>常见的卷积核及特征</h1><h2 id="常见的卷积核"><a href="#常见的卷积核" class="headerlink" title="常见的卷积核"></a>常见的卷积核</h2><ol>
<li>对图像无任何影响的卷积核<script type="math/tex; mode=display">
\begin{bmatrix}
0  & 0 & 0 \\ 
0 &  1 & 0 \\ 
0 & 0  & 0
\end{bmatrix}</script></li>
<li>对图像进行锐化的滤波器<script type="math/tex; mode=display">
\begin{bmatrix}
-1  & -1 & -1 \\ 
-1 &  9 & -1 \\ 
-1 & -1  & -1
\end{bmatrix}</script></li>
<li>浮雕滤波器<script type="math/tex; mode=display">
\begin{bmatrix}
-1  & -1 & 0 \\ 
-1 &  0 & 1 \\ 
0 & 1  & 1
\end{bmatrix}</script></li>
<li><p>均值模糊滤波器</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
0  & 0.2 & 0 \\ 
0.2 &  0.2 & 0.2 \\ 
0 & 0.2  & 0
\end{bmatrix}</script><blockquote>
<p>均值模糊是对像素点周围的像素进行均值化处理，将上下左右及当前像素点分文5份，然后进行平均，每份占0.2，即对当前像素点周围的点进行均值化处理。</p>
</blockquote>
</li>
<li><p>高斯模糊滤波器</p>
<blockquote>
<p>均值模糊是一种简单的模糊处理方式，但是会现实模糊不够平滑，而高斯模糊可以很好的处理，因此高斯模糊经常用于图像的降噪处理上，尤其是在边缘检测之前，进行高斯模糊，可以移除细节带来的影响。</p>
</blockquote>
</li>
</ol>
<ul>
<li>一维高斯模糊<script type="math/tex; mode=display">
G(x)=\frac{1}{ \sqrt{2 \pi \sigma ^2}} e^{( -\frac{x^2}{2\sigma ^2} )}</script></li>
<li>二维高斯模糊<script type="math/tex; mode=display">
G(x)=\frac{1}{ \sqrt{2 \pi \sigma ^2}} e^{( -\frac{x^2+y^2}{2\sigma ^2} )}</script></li>
</ul>
<h2 id="卷积核的特征"><a href="#卷积核的特征" class="headerlink" title="卷积核的特征"></a>卷积核的特征</h2><blockquote>
<p>这里的滤波器就是卷积核</p>
</blockquote>
<ul>
<li>当滤波器矩阵中的值相加为0甚至更小时，被滤波器处理之后的图像相对会比原始图像暗，值越小越暗</li>
<li>当滤波器矩阵中的值相加和为1时，被滤波器处理之后的图像与原始图像的亮度相比几乎一致</li>
<li>当滤波器矩阵中的值相加和大于1时，被滤波器处理之后的图像相对会比原始图像的亮度更亮</li>
</ul>
<hr>
<h1 id="卷积的变种"><a href="#卷积的变种" class="headerlink" title="卷积的变种"></a>卷积的变种</h1><p>在卷积的标准定义基础上，还可以引入滤波器的滑动步长和零填充来增加卷积的多样性，可以更加灵活的提取特征。</p>
<ul>
<li>滤波器的步长（Stride）是指滤波器在滑动时的时间间隔</li>
<li>零填充（Zero Padding）是在输入向量两端进行补零</li>
</ul>
<p>下图展示为步长为2和零填充的示例：<br><img src="https://img-blog.csdnimg.cn/20190904081641651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="步长为2和零填充示例"></p>
<p>假设卷积层的输入神经元个数为n，卷积大小为m，步长为s，输入神经元两端各补p各零，那么该卷积对应的神经元数量为：(n+2p-m)/s + 1。</p>
<p>一般的卷积分为以下三种：</p>
<ul>
<li>窄卷积（Narrow Convolution）：步长s=1，两端不补零即p=0，卷积后输出长度为：n-m + 1</li>
<li>宽卷积（Wide Convolution）：步长s=1，两端补零p=m-1，卷积后输出长度为：n+m-1</li>
<li>等宽卷积（Equal-Width Convolution）：步长s = 1,两端补零p = (m −1)/2,卷积后输出长度 n。</li>
</ul>
<hr>
<h1 id="卷积的数学性质"><a href="#卷积的数学性质" class="headerlink" title="卷积的数学性质"></a>卷积的数学性质</h1><p>卷积有很多比较好的数学性质，这里主要介绍一些二维的数学性质，同样针对一维卷积也同样适用。</p>
<h2 id="交换性"><a href="#交换性" class="headerlink" title="交换性"></a>交换性</h2><p>如果不限制两个卷积的长度，卷积是具有交换性的。即 $x \otimes  y = y \otimes  x$，当输入信息和卷积核有固定长度时，他们的宽卷积依然具有交换性。对于两维图像$X \in R^{M<em>N}$和卷积核$W \in R^{m</em>n}$，对图像X的两个维度进行零填充，两端各补m-1和n-1个零，得到全填充（Full Padding）的图像$\tilde{X} \in R^{(M+2m-2)(N+2n-2)}$。图像X和卷积核W的宽卷积（Wide Convolution）定义为：$W \tilde{\otimes } X \triangleq X \tilde{\otimes } W$<br>，其中$\tilde{\otimes }$为宽卷积操作。宽卷积具有交换性，即：$W \tilde{\otimes } X = X \tilde{\otimes } W$</p>
<h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>假设$Y = W \otimes X$，其中$X \in R^{M<em>N}$，$W \in R^{m</em>n}$，$Y \in R^{(M-m+1)*(N-n+1)}$，函数$f(Y) \in R$为一个标量函数，则(公式1.6)</p>
<script type="math/tex; mode=display">
\frac{\partial f(Y)}{\partial w_{uv}} = \sum_{i=1}^{M-m+1}\sum_{j=1}^{N-n+1} \frac{\partial f(Y)}{\partial y_{ij}} \frac{\partial y_{ij}}{\partial w_{uv}}
\\
= \sum_{i=1}^{M-m+1}\sum_{j=1}^{N-n+1}  \frac{\partial f(Y)}{\partial y_{ij}}x_{ {i+u-1},{j+v-1}}  
\\
= \sum_{i=1}^{M-m+1}\sum_{j=1}^{N-n+1}  \frac{\partial f(Y)}{\partial y_{ij}}x_{ {u+i-1},{v+j-1}}</script><p>从公式1.6可以看出，f(Y)关于W的偏导数为X和$\frac{\partial f(Y)}{\partial Y}$的卷积（公式1.7）</p>
<script type="math/tex; mode=display">
\frac{\partial f(Y)}{\partial W} = \frac{\partial f(Y)}{ \partial Y } \otimes X</script><p>同理得到（公式1.8）：</p>
<script type="math/tex; mode=display">
\frac{\partial f(Y)}{\partial x_{st}} = \sum_{i=1}^{M-m+1}\sum_{j=1}^{N-n+1} \frac{\partial f(Y)}{\partial y_{ij}} \frac{\partial y_{ij}}{\partial x_{st}}
\\
= \sum_{i=1}^{M-m+1}\sum_{j=1}^{N-n+1}  \frac{\partial f(Y)}{\partial y_{ij}}w_{ {s-i+1},{t-j+1}}</script><p>其中当$(s-i+1) &lt; 1$，或$(s-i+1)&gt;m$，或$(t-j+1) <1$，或$(t-j+1)>n$，或$w_{s-i+1,t-j+1}=0$时，即相当于对W进行了 p=(M-m,N-n)的零填充。</1$，或$(t-j+1)></p>
<p>从公式1.8可以看出，f(Y)关于X的偏导数为W和$\frac{\partial f(Y)}{ \partial Y }$，公式1.8中的卷积是真正的卷积而不是互相关，为了一致性，我们用互相关的卷积，即(公式1.9)：</p>
<script type="math/tex; mode=display">
\frac{\partial f(Y)}{\partial X} = rot180(\frac{\partial f(Y)}{\partial X}) \tilde{\otimes }W=rot180(W) \tilde{\otimes }\frac{\partial f(Y)}{\partial X}</script><p>其中rot180(.)表示旋转180度。</p>
<hr>
<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><p>卷积神经网络一般由卷积层，汇聚层和全连接层构成。</p>
<h2 id="用卷积代替全连接"><a href="#用卷积代替全连接" class="headerlink" title="用卷积代替全连接"></a>用卷积代替全连接</h2><p>在全连接前馈神经网络中，如果第$l$层有$n^l$个神经元，第$l-1$层有$n^{l-1}$个神经元，连接边就有$n^l * n^{l-1}$也就是权重参数有这么多个，当m和n都很大时，权重矩阵的参数会非常多，训练的效率会非常低。</p>
<p>如果用卷积代替全连接，第$l$层的净输入$z^l$与$l-1$层活性值$a^{l-1}$和滤波器$w^l \in R^m$的卷积，即$z^l = w^l * a^{l-1} + b^l$,其中滤波器$w^l$<br>为可学习的权重向量，$b^l \in R^{l-1}$为可学习的偏置。</p>
<p>根据卷积的定义，卷积层有两个很重要的性质：</p>
<ul>
<li>局部连接：在卷积层(假设是第$l$层)中的每一个神经元都只和下一层(第$l − 1$层)中某个局部窗口内的神经元相连,构成一个局部连接网络。</li>
<li>全局共享：作为参数的滤波器 $w^l$，对于第 $l$层的所有的神经元都是相同的。</li>
</ul>
<h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>卷积层的作用是提取一个局部区域的特征，不同大小的卷积相当于不同的特征提取器。上文介绍的卷积和神经元都是一维的，但卷积神经网络主要是针对图像处理而言的，而图像通常是二维的，为了充分利用图像的局部特征，通常将神经元组织为三维结构的神经层，其大小 M <em> 宽度 W </em> 深度 D，即D个M*N的特征映射组成。</p>
<p>对于输入层的而言，特征映射就是图像本身，如果是灰色图像，则深度为1，如果为彩色图像（分别是RGB三个通道的颜色特征映射），则深度为3。</p>
<h2 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h2><p>汇聚层（Pooling Layer）也叫子采样层（Subsampling Layer），其作用是进行特征选择，降低特征数量，从而减少参数数量。</p>
<p>卷积层虽然可以明显减少网络中的连接数量，但是特征映射中的神经元个数并未显著减少。如果后边接一个分类器的话，分类器的输入维数依然很高，很容易出现过拟合。因此有了汇聚层的产生，在卷积后边加一个汇聚层，从而降低特征维数，避免过拟合。</p>
<p>假设汇聚层的输入特征映射组为$X \in R^{M <em> N </em> D}$，对于其中每一个映射$X^d$，将其划分为很多区域$R^d_{m,n}$，1 &lt;= m &lt;= M’，1&lt;= n &lt;= N’，这些区域可以重叠，也可以不重叠。汇聚（Pooling）是指对每个区域进行下采样（Down Sampling）得到一个值，作为这个区域的概括。常见的汇聚方式有两种：</p>
<ul>
<li>最大汇聚（Maximum Pooling）：一个区域内所有神经元的最大值</li>
<li>平均汇聚（Mean Pooling）：一个区域内所有神经元的平均值</li>
</ul>
<p>典型的汇聚层是将每个特征映射划分为2<em>2大小的不重叠区域，然后使用最大汇聚的方式进行下采样。汇聚层也可以看作是一个特殊的卷积层，卷积核大小为m </em> m，步长为s * s，卷积核为 max函数或者mean函数。过大的采样区域会急剧减少神经元的数量，会造成过多的信息损失。</p>
<p>下图所示为最大汇聚示例：<br><img src="https://img-blog.csdnimg.cn/20190905133224389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="最大汇聚实例"></p>
<h2 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h2><p>在全连接层中，将最后一层的卷积输出展开，并将当前层的每个节点与下一层的另一个节点连接起来。全连接层只是人工神经网络的另一种说法，如下图所示，全连接层中的操作与一般神经网络中的操作完全相同。</p>
<p><img src="https://img-blog.csdnimg.cn/20190904171044639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>对于output layer中的的每个神经元，其表达式可以记做为(公式1.10)：</p>
<script type="math/tex; mode=display">
y = \sigma (\sum_{i=1}^{m} w_i ^T x_i + b)</script><p>如果outptu有多个神经元，最终可以通过softmax进行最终类别的判断。</p>
<hr>
<h1 id="典型的卷积网络结构"><a href="#典型的卷积网络结构" class="headerlink" title="典型的卷积网络结构"></a>典型的卷积网络结构</h1><p>一个典型的卷积网络是有卷积层，汇聚层，全连接层交叉堆叠而成。目前常用的卷积神经网络结构如下图所示：<br><img src="https://img-blog.csdnimg.cn/2019090413573373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="卷积神经网络"></p>
<p>卷积块是由M个卷积层b个汇聚层（M通常在2～之间，b为0或1），一个卷积网络中可以堆叠N个连续的卷积块，然后再接着K个全连接层（N的取值空间比较大，一般是1～100或者更大，K通常为0～2）。</p>
<p>目前整个网络倾向于使用更小的卷积核（比如1<em>1或者3</em>3）以及更深的结构（比如层数大于50），此外，卷积操作的灵活性越来越大，汇聚层的作用变得越来越小，因此目前流行的卷积网络中，汇聚层的比例也在逐渐降低，倾向于全连接网络。</p>
<hr>
<h1 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h1><p>在卷积神经网络中，参数为卷积核中的权重和偏置，和全连接前馈神经网络一样，使用误差反向传播算法来进行参数学习。梯度主要通过每一层的误差项$\delta$进行反向传播，并进一步计算每一层的梯度。在卷积神经网络中主要有两种功能不同的网络层：卷积层和汇聚层。而参数为卷积核中权重和偏置，因此只需要计算卷积层中参数梯度。</p>
<p>不失一般性，对第$l$层卷积层,第$l-1$层的输入特征映射为$X^{(l-1)} \in R^{M<em>N</em>D}$，通过卷积计算得到第$l$层净输入为$Z^{(l)}\in  R^{M’<em>N’</em>P}$，第$l$层的第p(1&lt;= p &lt;= P)个特征净输入为(公式1.11)</p>
<script type="math/tex; mode=display">
Z^{(l,p)} = \sum_{d=1}^{D} W^{(l,p,d)} \otimes X^{(l-1,d)}+ b^{(l,p)}</script><p>其中$W^{(l,p,d)} ,b^{(l,p)}$为卷积核以及偏置。第$l$层共有P * D 个卷积和P个偏置，可以分别使用链式法则计算其梯度。</p>
<p>根据公式1.7 和 1.11，损失函数关于第$l$层的卷积核$W^{(l,p,d)}$的偏导数为为(公式1.12)：</p>
<script type="math/tex; mode=display">
\frac{\partial L (Y,\hat{Y})}{ \partial W^{(l,p,d)} } = \frac{\partial L (Y,\hat{Y})}{ \partial Z^{(l,p)} } \otimes X^{(l-1,d)}=\delta ^{(l,p)} \otimes X^{(l-1,d)}</script><p>其中为(公式1.13)</p>
<script type="math/tex; mode=display">
\delta ^{(l,p)} = \frac{\partial L (Y,\hat{Y})}{ \partial Z^{(l,p)} }</script><p>为损失函数关于第$l$层的第p个特征映射净输入$Z^{(l,p)}$的偏导数。</p>
<p>同理可得，损失函数关于第$l$层的第p个偏置$b^{(l,p)}$的偏导数为为(公式1.14)：</p>
<script type="math/tex; mode=display">
\frac{ \partial L (Y,\hat{Y}) }{ \partial b^{(l,p)} } = \sum_{i,j} [\delta ^{(l,p)}]_{i,j}</script><p>卷积网络中，每层参数的梯度依赖其所在层的误差项$\delta ^{(l,p)}$</p>
<h2 id="误差项的计算"><a href="#误差项的计算" class="headerlink" title="误差项的计算"></a>误差项的计算</h2><p>卷积层和汇聚层的误差项计算不同。</p>
<h3 id="卷积层-1"><a href="#卷积层-1" class="headerlink" title="卷积层"></a>卷积层</h3><p>当$l+1$层为卷积层时，假设特征映射净输入(公式1.15)</p>
<script type="math/tex; mode=display">
Z^{(l+1,p)} = \sum_{d=1}^{D} W^{(l+1,p,d)} \otimes X^{(l,d)} + b^{(l+1,p)}</script><p>其中$W^{(l+1,p,d)},b^{(l+1,p)}$为第$l$层的卷积核和偏置。第$l+1$层共有 P *D 个卷积核和P个偏置。</p>
<p>第 $l$层的第 $d$个特征映射的误差项$\delta ^{(l,d)}$的具体推导过程如下(公式1.16):</p>
<script type="math/tex; mode=display">
\delta ^{(l,d)} \triangleq  \frac{\partial L (Y,\hat{Y})}{ \partial Z^{(l,d)} }
\\
=\frac{\partial X^{(l,d)} } { \partial Z^{(l,d)}} \cdot \frac{\partial L (Y,\hat{Y})}{ \partial X^{(l,d)} }
 \\
= f'_l (Z^{(l,p)})  \odot \sum_{p=1}^{P}( rot180(W^{(l+1,p,d)} ) \tilde{\otimes  } \frac{\partial L(Y,\hat{Y})}{ \partial Z^{(+1,p)}})
\\
=  f'_l (Z^{(l,p)})  \odot \sum_{p=1}^{P}(rot180(W^{(l+1,p,d)} ) \tilde{\otimes  }\delta ^{(l+1,p)})</script><p>其中$\tilde{\otimes}$表示宽卷积。</p>
<h3 id="汇聚层-1"><a href="#汇聚层-1" class="headerlink" title="汇聚层"></a>汇聚层</h3><p>当第$l+1$层为汇聚层时, 因为汇聚层是下采样操作, $l+1$层的每个神经元的误差项 $\delta$对应于第$l$层的相应特征映射的一个区域。$l$层的第$p$个特征映射中的每个神经元都有一条边和$l+1$层的第$p$个特征映射中的一个神经元相连。</p>
<p>根据链式法则,第$l$层的一个特征映射的误差项$\delta ^{(l,p)}$，只需要将 $l+1$层对应特征映射的误差项$\delta ^{(l+1,p)}$进行上采样操作(和第 $l$层的大小一样) ,再和 $l$层特征映射的激活值偏导数逐元素相乘,就得到了 $\delta ^{ (l,p)}$</p>
<p>第 $l$层的第$p$个特征映射的误差项$\delta ^{(l,p)}$的具体推导过程如下(公式1.17)：</p>
<script type="math/tex; mode=display">
\delta ^{(l,p)} \triangleq  \frac{\partial L (Y,\hat{Y})}{ \partial Z^{(l,p)} }
\\
=\frac{\partial X^{(l,p)} } { \partial Z^{(l,p)}} \cdot \frac{\partial Z^{(l+1,p)} } { \partial X^{(l,p)}} \cdot \frac{\partial L (Y,\hat{Y})}{ \partial Z^{(l+1,p)} }
\\ 
= f'_l (Z^{(l,p)})  \odot up(\delta ^{(l+1,p)})</script><p>其中$f’_l$为第l层使用的激活函数导数，up为上采样函数(upsampling)，与汇聚层中使用的下采样函数刚好相反，如果下采样是最大汇聚（max pooling），误差项$\delta ^{(l+1,p)}$中每个值都会传递到上一层对应区域中的最大值所对应的神经元，该区域中其他位置的神经元的误差都设为0，如果下采样是平均汇聚(mean pooling) ,误差项 $\delta ^{(l+1,p)}$中每个值会被平均分配到上一层对应区域中的所有神经元上。</p>
<hr>
<h1 id="几种典型的卷积神经网络"><a href="#几种典型的卷积神经网络" class="headerlink" title="几种典型的卷积神经网络"></a>几种典型的卷积神经网络</h1><h2 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h2><p>LeNet-5 虽然提出的时间比较早（LeCun et al., 1998），但是一个非常成功的卷积神经网络模型，90年代在许多银行进行使用，用来识别手写数字，其网络结构如下：<br><img src="https://img-blog.csdnimg.cn/20190904141123853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="LeNet-5"></p>
<h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p>AlexNet是第一个现代深度卷积网络模型，其首次使用了现在深度卷积网络的一些技巧，比如GPU并行训练，采用ReLU作为非线性激活函数，使用DropOut防止过拟合，使用数据增强来提高模型准确率。AlexNet获得了2012年ImageNet图像分类比赛的冠军，其网络结构如下：<br><img src="https://img-blog.csdnimg.cn/20190904141502612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="AlexNet"></p>
<h2 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h2><p>在卷积网络中，如何定义一个卷积的大小是一个十分关键的问题，在Inception网络中，一个卷积层包含多个不同大小的卷积操作，称为Inception模块， Inception网络是由多个inception模块和汇聚层堆叠而成。</p>
<p>Inception模块同时使用1<em>1，3</em>3，5<em>5等大小不同的卷积核，并将得到的特征映射在深度上拼接（堆叠）起来作为输出特征映射。下图给出了v1版本的inception模块结构图，采用了4组平行的特征抽取方式，分别为1</em>1，3<em>3，5</em>5的卷积和3<em>3的最大汇聚，同时为了提高计算效率，减少参数数量，inception模块在进行3</em>3，5<em>5的卷积之前，3</em>3的最大汇聚之后，进行一次1*1的卷积来减少特征映射的深度。<br><img src="https://img-blog.csdnimg.cn/20190904142716385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="v1版本的inception模块"></p>
<p>Inception网络最早的v1版本就是非常著名的GoogleNet，获得了2014年ImageNet图像分类竞赛的冠军。其结构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190904142927193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="GoogleLeNet"></p>
<p>当然Inception网络有多个改进版本，比如Inception-v3网络，Inception-ResNet v2网络和改进版的Inception-v4模型。</p>
<h2 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h2><p>残差网络（Residual Network，ResNet）是通过给非先行的卷积层增加直连边的方式来提高信息的传播效率。</p>
<p>假设在一个深度网络中，我们期望一个非线性单元$f(x,\theta)$去逼近一个目标函数为h(x)。如果将目标函数拆分为两部分：恒等函数（Identity）和残差函数（Reside Function）h(x)-x。</p>
<script type="math/tex; mode=display">
h(x) = \underset{IdentityFunc}{\underbrace{x}} +( \underset{ResidueFunc}{\underbrace{h(x)-x}})</script><p>根据通用近似定理，一个由神经网络构成的非线性单元有足够的能力来近似逼近原始目标函数或残差函数，但实际中后者更容易血虚。因此原来的优化问题可以转化为：让非线性单元$f(x,\theta)$去近似残差h(x)-x,并用$f(x,\theta) +x$去逼近h(x)。</p>
<p>下图给出了一个典型的残差单元示例，残差单元由多个级联的（等长）卷积层和一个跨层的直连边组成，再经过ReLU激活后得到输出。残差网络就是将很多个残差单元串联起来构成的一个非常深的网络。<br><img src="https://img-blog.csdnimg.cn/20190904144622317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="残差单元示例"></p>
<hr>
<h1 id="其他卷积方式"><a href="#其他卷积方式" class="headerlink" title="其他卷积方式"></a>其他卷积方式</h1><h2 id="转置卷积"><a href="#转置卷积" class="headerlink" title="转置卷积"></a>转置卷积</h2><p>我们一般通过卷积操作来实战高维特征到低维特征的转换，但在一些任务中需要把低维特征映射到高维特征，并且希望通过卷积操作来实现。</p>
<p>卷积操作可以通过仿射变换的形式。假设一个5维的向量x，经过大小为3的卷积核w=[w1,w2,w2]^T来进行卷积，得到3维向量z，卷积操作可以写为：</p>
<p><img src="https://img-blog.csdnimg.cn/20190904154849239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="5维向量x与大小为3的卷积核进行卷积"></p>
<p>其中C是一个稀疏矩阵，其非零元素来自于卷积核w中的元素。如果实现3维向量z到5维向量x的映射，可以通过仿射矩阵转置来实现。</p>
<p><img src="https://img-blog.csdnimg.cn/20190904155151517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="仿射矩阵转置"></p>
<p>其中rot180(.)表示旋转180度。</p>
<blockquote>
<p>我们将低维特征映射到高维特征的卷积操作称之为转置卷积（Transposed Convolution），也叫反转卷积（Deconvolution）。</p>
</blockquote>
<h2 id="空洞卷积"><a href="#空洞卷积" class="headerlink" title="空洞卷积"></a>空洞卷积</h2><p>对于一个卷积层，如果希望增加输出单元的感受野，一般可以通过三种方式实现：</p>
<ul>
<li>增加卷积核的大小</li>
<li>增加层数</li>
<li>在卷积之前进行汇聚操作</li>
</ul>
<p>前两种会增加参数数量，最后一种会丢失一些信息。</p>
<p>空洞卷积（Atrous Convolution）也成为膨胀卷积（Dilated Convolution），是一种不增加参数数量，同时增加输出单元感受野的一种方法。</p>
<p>空洞卷积通过给卷积核插入“空洞”来变相的增加其大小，如果在卷积核的每两个元素之间插入d-1个空洞，卷积核的有效大小维：<br>$m’=m+ (m-1) * (d-1)$<br>其中d称为膨胀率（Dilation Rate）。当d=1时卷积核维普通的卷积核。<br><img src="https://img-blog.csdnimg.cn/20190904160154440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="不同膨胀率的卷积核"></p>
<hr>
<center>
<img src="http://img.blog.csdn.net/20171231111930492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FtZXJfZ3l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
</center>

<blockquote>
<p>【搜索与推荐Wiki】专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！</p>
</blockquote>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/assets/img/weixin.jpeg">
        <p> 你的支持是我进步的最大动力！ </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/thinkgamer">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="http://weibo.com/5352480017">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        

        
        <li>
            <a target="_blank"  href="https://github.com/thinkgamer">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        


        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        || Created By <a href="https://blog.csdn.net/gamer_gyt">Thinkgamer</a></p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
