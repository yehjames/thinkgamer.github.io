<!DOCTYPE html>
<html lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Thinkgamer的博客">
    <meta name="keyword"  content="Python,Django,爬虫,Hadoop,Maching Learning,数据挖掘,机器学习,云计算,大数据,深度学习,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,用户体验">
    <link rel="shortcut icon" href="/assets/img/favicon.ico">

    <title>
        
        模型的独立学习方式 - Thinkgamer的博客 | Thinkgamer&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> All In CTR、DL、ML、RL、NLP、KG </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/assets/img/head.jpg" />
        </div>
        <div class="name">
            <i>Thinkgamer</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集成学习"><span class="toc-text">集成学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bagging类方法"><span class="toc-text">Bagging类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boosting类方法"><span class="toc-text">Boosting类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AdaBoost算法"><span class="toc-text">AdaBoost算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自训练和协同训练"><span class="toc-text">自训练和协同训练</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自训练"><span class="toc-text">自训练</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协同训练"><span class="toc-text">协同训练</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多任务学习"><span class="toc-text">多任务学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迁移学习"><span class="toc-text">迁移学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#归纳迁移学习"><span class="toc-text">归纳迁移学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转导迁移学习"><span class="toc-text">转导迁移学习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终生学习"><span class="toc-text">终生学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元学习"><span class="toc-text">元学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基于优化器的元学习"><span class="toc-text">基于优化器的元学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模型无关的元学习"><span class="toc-text">模型无关的元学习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> All In CTR、DL、ML、RL、NLP、KG </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        <div class="post-container">
    <div class="post-title">
        模型的独立学习方式
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-11-12 20:53:23</span></span>
        
        <span class="attr">标签：/
            
            <a class="tag" href="/tags/#神经网络" title="神经网络">神经网络</a>
            <span>/</span>
            
            
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span>
        </span>
    </div>
    <div class="post-content no-indent">
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>针对一个给定的任务，通常采取的步骤是：准确一定非规模的数据集，这些数据要和真实数据集的分布一致；然后设定一个优化目标和方法；然后在训练集上训练模型。</p>
<p>不同的模型往往都是从零开始训练的，一切知识都需要从训练集中得到，这就意味着每个任务都需要大量的训练数据。在实际应用中，我们面对的任务很难满足上述需求，比如训练任务和目标任务的数据分布不一致，训练数据集过少等。这时机器学习的任务就会受到限制，因此人们开始关注一些新的任务学习方式。<br>本篇文章主要介绍一些“模型独立的学习方式”，比如：集成学习、协同学习、自学习、多任务学习、迁移学习、终身学习、小样本学习、元学习等。</p>
<h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><p>集成学习（Ensemble Learning）就是通过某种策略将多个模型集成起来，通过群体决策来提高决策准确率。集成学习首要的问题是如何集成多个模型，比较常用的集成策略有直接平均、加权平均等。</p>
<p><strong>集成学习可以分为：Boosting、Bagging、Stacking</strong>，这三种的详细区分和流程可以参考《<a href="https://item.jd.com/12671716.html" target="_blank" rel="external">推荐系统开发实战</a>》一书中第八章 点击率预估部分。本文中主要介绍集成学习中的Boosting学习和AdaBoost算法。</p>
<p>集成学习的思想可以采用一句古老的谚语来描述：“三个臭皮匠，顶个诸葛亮”。但是一个有效的集成需要各个基模型的差异尽可能的大。为了增加模型之间的差异性，可以采取Bagging类和Boosting类两类方法。</p>
<h4 id="Bagging类方法"><a href="#Bagging类方法" class="headerlink" title="Bagging类方法"></a>Bagging类方法</h4><p>Bagging类方法是通过随机构造训练样本、随机选择特征等方法来提高每个基模型的独立性，代表性方法有Bagging和随机森林。</p>
<ul>
<li>Bagging（Bootstrap Aggregating）是一个通过不同模型的训练数据集的独立性来提高不同模型之间的独立性。我们在原始训练集上进行有放回的随机采样，得到M比较小的训练集并训练M个模型，然后通过投票的方法进行模型集成。</li>
<li>随机森林（Random Forest）是在Bagging的基础上再引入了随机特征，进一步提升每个基模型之间的独立性。在随机森林中，每个基模型都是一棵树。</li>
</ul>
<p>随机森林的算法步骤如下：</p>
<ul>
<li>从样本集中通过重采样的方式产生n个样本</li>
<li>假设样本特征数目为a，对n个样本选择a中的k个特征，用建立决策树的方式获得最佳分割点</li>
<li>重复m次，产生m棵决策树<br>-多数投票机制来进行预测<blockquote>
<p>需要注意的一点是，这里m是指循环的次数，n是指样本的数目，n个样本构成训练的样本集，而m次循环中又会产生m个这样的样本集</p>
</blockquote>
</li>
</ul>
<h4 id="Boosting类方法"><a href="#Boosting类方法" class="headerlink" title="Boosting类方法"></a>Boosting类方法</h4><p>Boosting类方法是按照一定的顺序来先后训练不同的基模型，每个模型都针对前续模型的错误进行专门训练。根据前序模型的结果，来提高训练样本的权重，从而增加不同基模型之间的差异性。Boosting类方法的代表性方法有AbaBoost，GBDT，XGB，LightGBM等。</p>
<p>关于GBDT的介绍同样可以参考《<a href="https://item.jd.com/12671716.html" target="_blank" rel="external">推荐系统开发实战</a>》一书。</p>
<p>Boosting类集成模型的目标是学习一个加性模型（additive model） ，其表达式如下：</p>
<script type="math/tex; mode=display">
F(x) = \sum_{m=1}^{M} a_m f_m(x)</script><p>其中$f_m(x)$为弱分类器，或基分类器，$a_m$为弱分类器的集成权重，$F(x)$称为强分类器。</p>
<p>Boosting类方法的关键是如何训练每个弱分类器$f_m(x)$以及对应的权重$a_m$。为了提高集成的效果，应尽可能使得每个弱分类器的差异尽可能大。一种有效的方法是采用迭代的策略来学习每个弱分类器，即按照一定的顺序依次训练每个弱分类器。</p>
<p>在学习了第m个弱分类器之后，增加分错样本的权重，使得第$m+1$个弱分类器“更关注”于前边弱分类器分错的样本。这样增加每个弱分类器的差异，最终提升的集成分类器的准确率。这种方法称为AdaBoost（其实其他的Boost模型采用的也是类似的策略，根据前m-1颗树的误差迭代第m颗树）。</p>
<h4 id="AdaBoost算法"><a href="#AdaBoost算法" class="headerlink" title="AdaBoost算法"></a>AdaBoost算法</h4><p>AdaBoost算法是一种迭代式的训练算法，通过改变数据分布来提高弱分类器的差异。在每一轮训练中，增加分错样本的权重，减少对分对样本的权重，从而得到一个新的数据分布。</p>
<p>以两类分类为例，弱分类器$f_m(x) \in \{ +1, -1\}$，AdaBoost算法的训练过程如下所示，最初赋予每个样本同样的权重。在每一轮迭代中，根据当前的样本权重训练一个新的弱分类器。然后根据这个弱分类器的错误率来计算其集成权重，并调整样本权重。</p>
<p><img src="https://img-blog.csdnimg.cn/20191106144746194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="AdaBoost算法流程"></p>
<p><strong>AdaBoost算法的统计学解释</strong></p>
<p>AdaBoost算法可以看做是一种分步优化的加性模型，其损失函数定义为：</p>
<script type="math/tex; mode=display">
L(F) = exp(-y F(x))
\\
= exp(-y \sum_{m=1}^{M} a_m f_m(x))</script><p>其中$y,f_m(x)\in \{ +1,-1\}$</p>
<p>假设经过$m-1$次迭代，得到：</p>
<script type="math/tex; mode=display">
F_{m-1}(x) = \sum_{t=1}^{T} a_t f_t(x)</script><p>则第$m$次迭代的目标是找一个$a_m$和$f_m(x)$使得下面的损失函数最小。</p>
<script type="math/tex; mode=display">
L(a_m,f_m(x)) = \sum_{n=1}^{N}exp(-y^{(n)} (F_{m-1} (x^{(n)}) + a_m f_m(x^{(n)})))</script><p>令 $w_m^{(n)}=exp(-y^{(n)} F_{m-1}(x^{(n)}))$，则损失函数可以表示为：</p>
<script type="math/tex; mode=display">
L(a_m,f_m(x)) = \sum_{n=1}^{N} w_m^{(n)} exp(-y^{(n)} a_m f_m(x^{(n)}))</script><p>因为$y,f_m(x) \in {+1, -1}$，有：</p>
<script type="math/tex; mode=display">
yf_m(x) = 1-2I(y\neq f_m(x))</script><p>其中$I(x)$为指示函数。</p>
<p>将损失函数在$f_m(x)=0$处进行二阶泰勒展开，有：</p>
<script type="math/tex; mode=display">
L(a_m, f_m(x)) = \sum_{n=1}^{N} w_m^{(n)} (  1 - a_m y^{(n)}f_m(x^{(n)}) + \frac{1}{2}a_m^2  ) 
\\
\propto a_m \sum_{n=1}^{N} w_n^{(n)} I(y^{(n} \neq f_m(x^{(n)})</script><p>从上式可以看出，当$a_m&gt;0$时，最优的分类器$f_m(x)$为使得在样本权重为$w_m^{(n)}, 1 \leq n \leq N$时的加权错误率最小的分类器。</p>
<p>在求解出$f_m(x)$之后，上述的损失函数可以写为：</p>
<script type="math/tex; mode=display">
L(a_m, f_m(x)) = \sum_{y^{(n)}=f_m(x^{(n)})} w_m^{(n)} exp(-a_m) + \sum_{y^{(n)} \neq f_m(x^{(n)})}  w_m^{(n)} exp(a_m) 
\\
\propto (1-\epsilon _m) exp(-a_m) + \epsilon_m exp(a_m)</script><p>其中$\epsilon_m$为分类器$f_m(x)$的加权错误率</p>
<script type="math/tex; mode=display">
\epsilon_m = \frac { \sum_{ y^{(n)} \neq f_m(x^{(n)}) } w_m^{(n)} } {\sum_{n} w_m^{(n)}}</script><p>求上式关于$a_m$的导数并令其为0，得到</p>
<script type="math/tex; mode=display">
a_m = \frac {1}{2} log \frac {1-\epsilon_m}{\epsilon_m}</script><p><strong>AdaBoost算法的优缺点</strong><br>优点：</p>
<ul>
<li>作为分类器精度很高</li>
<li>可以使用各种算法构建子分类器，AdaBoost提供的是一个框架</li>
<li>使用简单分类器时，计算出的结果可理解，且构造简单</li>
<li>不需要做特征筛选</li>
<li>不同担心过拟合</li>
</ul>
<p>缺点：</p>
<ul>
<li>容易收到噪声干扰</li>
<li>训练时间长，因为需要遍历所有特征</li>
<li>执行效果依赖于弱分类器的选择</li>
</ul>
<h3 id="自训练和协同训练"><a href="#自训练和协同训练" class="headerlink" title="自训练和协同训练"></a>自训练和协同训练</h3><p>监督学习虽然准确度上有一定的保证，但往往需要大量的训练数据，但在一些场景中标注数据的成本是非常高的，因此如何利用大量的无标注数据提高监督学习的效率，有着十分重要的意义。这种利用少量样本标注数据和大量样本标注数据进行学习的方式称之为半监督学习（Semi-Supervised Learning，SSL）。</p>
<p>本节介绍两种无监督的学习算法：自训练和协同训练。</p>
<h4 id="自训练"><a href="#自训练" class="headerlink" title="自训练"></a>自训练</h4><p>自训练（Slef-Training）也叫自训练（Self-teaching）或者自举法（boostStrapping）。</p>
<p>自训练的思路是：利用已知的标注数据训练一个模型，利用该模型去预测无标注的样本数据，然后将置信度较高的样本以及其伪标签加入训练集，然后重新训练模型，进行迭代。下图给出了自训练的算法过程。</p>
<p><img src="https://img-blog.csdnimg.cn/20191109150434700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="自训练算法过程"></p>
<p>自训练和密度估计中EM算法有一定的相似之处，通过不断地迭代来提高模型能力。但自训练的缺点是无法保证每次加入训练集的样本的伪标签是正确的。如果选择样本的伪标签是错误的，反而会损害模型的预测能力。因此自训练最关键的步骤是如何设置挑选样本的标准。</p>
<h4 id="协同训练"><a href="#协同训练" class="headerlink" title="协同训练"></a>协同训练</h4><p>协同训练（Co-Training）是自训练的一种改进方法，通过两个基于不同视角的分类器来相互促进。很多数据都有相对独立的不同视角。比如互联网上的每个网页都由两种视角组成：文字内容和指向其他网页的链接。如果要确定一个网页的类别，可以根据文字内容来判断，也可以根据网页之间的链条关系来判断。</p>
<p>假设一个样本$x=[x_1,x_2]$，其中$x_1,x_2$分别表示两种不同视角$V_1,V_2$的特征，并满足下面两个假设：</p>
<ul>
<li>（1）：条件独立性，即给定样本标签y时，两种特征条件独立$p(x_1,x_2|y)=p(x_1|y)p(x_2|y)$</li>
<li>（2）：充足和冗余性，即当数据充分时，每种视角的特征都可以足以单独训练出一个正确的分类器。</li>
</ul>
<p>令$y=g(x)$为需要学习的真实映射函数，$f_1$和$f_2$分别为两个视角的分类器，有：</p>
<script type="math/tex; mode=display">
\exists f_1, f_2,    \forall x \in X,\,\,\,\,\, f_1(x_1) = f_2(x_2) = g(x)</script><p>其中$X$为样本$x$的取值空间。</p>
<p>由于不同视角的条件独立性，在不同视角上训练出来的模型就相当于从不同的视角来理解问题，具有一定的互补性。协同训练就是利用这种互补行来进行自训练的一种方法。首先在训练集上根据不同视角分别训练两个模型$f_1$和$f_2$然后用$f_1$和$f_2$在无标记数据集上进行预测，各选取预测置信度比较高的样本加入到训练集，重新训练两个不同视角的模型，并不断重复这个过程（需要注意的是协同算法要求两种视图时条件独立的，如果两种视图完全一样，则协同训练退化成自训练算法）。</p>
<p>协同训练的算法过程如下：<br><img src="https://img-blog.csdnimg.cn/20191109153310892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="协同训练的算法过程"></p>
<h3 id="多任务学习"><a href="#多任务学习" class="headerlink" title="多任务学习"></a>多任务学习</h3><p>一般的机器学习模型是针对单个任务进行的，不同任务的模型需要在各自的训练集上单独学习得到。而多任务学习（Multi-task learning）是指同时学习多个相关任务，让 这些任务在学习的过程中共享知识，利用多个任务之间的相关性来改进模型的性能和泛化能力。</p>
<p>多任务学习可以看做时一种归纳迁移学习（Inductive Transfer Learning），即通过利用包含在相关任务中的信息作为归纳偏置（Inductive Bias）来提高泛化能力。</p>
<p><strong>多任务学习的主要挑战在于如何设计多任务之间的共享机制</strong>，在传统的机器学习任务中很难引入共享信息，但是在神经网络中就变得简单了许多，常见的以下四种：</p>
<ul>
<li><strong>硬共享模式</strong>：让不同任务的神经网络模型共同使用一些共享模块来提取一些通用的特征，然后再针对每个不同的任务设置一些私有模块来提取一些任务特定的特征。</li>
<li><strong>软共享模式</strong>：不显式设置共享模块，但每个任务都可以从其他任务中“窃取”一些信息来提高自己的能力。窃取的方式包括直接复制使用其他任务的隐状态，或使用注意力机制来主动选择有用的信息。</li>
<li><strong>层次共享模式</strong>：一般神经网络中不同层抽取的特征类型不同，底层一般抽取一些低级的局部特征，高层抽取一些高级的抽象语义特征。因此如果多任务学习中不同任务也有级别高低之分，那么一个合理的共享模式是让低级任务在底层输出，高级任务在高层输出。</li>
<li><strong>共享-私有模式</strong>：一个更加分工明确的方式是将共享模块和任务特定（私有）模块的责任分开。共享模块捕捉一些跨任务的共享特征，而私有模块只捕捉和特点任务相关的特征。最终的表示由共享特征和私有特征共同构成。</li>
</ul>
<p>在多任务学习中，每个任务都可以有自己单独的训练集。为了让所有任务同时学习，我们通常会使用交替训练的方式来“近似”的实现同时学习，下图给出了四种常见的共享模式图</p>
<p><img src="https://img-blog.csdnimg.cn/20191112101743882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="四种常见的共享模式图"></p>
<p>多任务学习的流程可以分为两个阶段：</p>
<ul>
<li>（1）联合训练阶段：每次迭代时，随机挑选一个任务，然后从这个任务中随机选择一些训练样本，计算梯度并更新参数</li>
<li>（2）单任务精调阶段：基于多任务学习到的参数，分别在每个单独任务进行精调，其中单任务精调阶段为可选阶段。当多个任务的差异性比较大时，在每个单任务上继续优化参数可以进一步提升模型能力。</li>
</ul>
<p>假设有M个相关任务，其模型分别为$f_m(x,\theta), 1\leq m \leq M$，多任务学习的联合目标函数为所有任务损失函数的线性加权：</p>
<script type="math/tex; mode=display">
L(\theta) = \sum_{m=1}^{M}\sum_{n=1}^{N_m} \eta_m l_m(f_m(x^{(m,n)}, \theta ), y_{(m,n)})</script><p>其中$l_m$为第m个任务的损失函数，$\eta_m$是第m个任务的权重，$\theta$表示包含了共享模块和私有模块在内的所有参数。</p>
<p>多任务学习中联合训练阶段的具体过程如下所示：<br><img src="https://img-blog.csdnimg.cn/20191112102456841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="多任务学习中联合训练阶段的具体过程"></p>
<p>多任务学习通常比单任务学习获得更好的泛化能力，主要由于以下几个原因：</p>
<ul>
<li>1.多任务学习在多个数据集上进行训练，训练集范围更大，且多任务之间具有一定的相关性，相当于是一种隐式的数据增强，可以提高模型的泛化能力。</li>
<li>2.多任务学习中的共享模块需要兼顾所有任务，在一定程度上避免了模型过拟合到单个任务的训练集，可以看做是一种正则化。</li>
<li>3.多任务学习比单任务学习可以获得更好的表示</li>
<li>4.在多任务学习中，每个任务都可以“选择性”利用其他任务中学习到的隐藏特征，从而提高自身的能力。</li>
</ul>
<h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>标准机器学习的前提假设只训练数据和测试数据的分布是相同的。如果不满足这个假设，在训练集上学习到的模型在测试集上的表现会比较差。如何将相关任务的训练数据中学习到的可泛化知识迁移到目标任务中，就是迁移学习（Transfer Learning）要解决的问题。</p>
<p>迁移学习根据不同的迁移方式又分为两个类型：归纳迁移学习（Inductive Transfer Learning）和推导迁移学习（Transductive Transfer Learning）。这两个类型分别对应两个机器学习的范式：归纳学习（Inductive Learning）和转导学习（Transductive Learning）。一般的机器学习任务都是指归纳学习，即希望再训练集上学习到使得期望风险最小的模型。而转导学习的目标是学习一种在给定测试集上错误率最小的模型，在训练阶段可以利用测试集的信息。</p>
<h4 id="归纳迁移学习"><a href="#归纳迁移学习" class="headerlink" title="归纳迁移学习"></a>归纳迁移学习</h4><p>一般而言，归纳迁移学习要求源领域和目标领域时相关的，并且源领域$D_S$有大量的训练样本，这些样本可以是有标注的样本也可以时无标注的样本。</p>
<ul>
<li>当源领域只有大量无标注数据时，源任务可以转换为无监督学习任务，比如自编码和密度估计，通过无监督任务学习一种可迁移的表示，然后将这些表示迁移到目标任务上。</li>
<li><p>当源领域有大量的标注数据时，可以直接将源领域上训练的模型迁移到目标领域上。<br>归纳迁移学习一般有下面两种迁移方式：</p>
</li>
<li><p>基于特征的方式：将预训练模型的输出或者中间隐藏层的输出作为特征直接加入到目标任务学习模型中。目标任务的学习模型可以时一般的浅层分类器（比如支持向量机等）或一个新的神经网络模型。</p>
</li>
<li>精调的方式：在目标任务上复用预训练模型的部分参数，并对其参数进行精调。</li>
</ul>
<p>假设预训练的模型是一个深层神经网络，不同层的可迁移性也不尽相同。通常来说网络的低层学习一些通用的低层特征，中层或者高层学习抽象的高级语义特征，而最后几层一般学习和特定任务相关的特征。因此根据目标任务的自身特点以及和源任务的相关性，可以针对性的选择预训练模型的不同层来迁移到目标任务中。</p>
<p>将预训练模型迁移到目标任务中通常会比从零开始学习的方式好，主要体现在以下三点：</p>
<ul>
<li>（1）初始模型的性能一般比随机初始化的模型要好</li>
<li>（2）训练时模型的学习速度比从零开始学习要快，收敛性更好</li>
<li>（3）模型的最终性能更好，具有更好的泛化性</li>
</ul>
<p>归纳迁移学习和多任务学习也比较类似，但是有下面两点区别：</p>
<ul>
<li>（1）多任务学习是同时学习多个不同任务，而归纳迁移学习通常分为两个阶段，即源任务上的学习阶段，和目标任务上的迁移学习阶段</li>
<li>（2）归纳迁移学习是单向的知识迁移，希望提高模型在目标任务上的性能，而多任务学习时希望提高所有任务的性能。</li>
</ul>
<h4 id="转导迁移学习"><a href="#转导迁移学习" class="headerlink" title="转导迁移学习"></a>转导迁移学习</h4><p>转导迁移学习是一种从样本到样本的迁移，直接利用源领域和目标领域的样本进行迁移学习。转导迁移学习可以看作是一种特殊的转导学习。转导迁移学习通常假设源领域有大量的标注数据，而目标领域没有（或少量）的标注数据，但是有大量的无标注数据。目标领域的数据在训练阶段是可见的。</p>
<p>转导迁移学习的一个常见子问题时领域适应（Domain Adaptation），在领域适应问题中，一般假设源领域和目标领域有相同的样本空间，但是数据分布不同$p_S(x,y) \neq p_T(x,y)$。</p>
<p>根据贝叶斯公式，$p(x,y)=p(x|y)p(y) = p(y|x)p(x)$，因此数据分布的不一致通常由三种情况造成。</p>
<ul>
<li>（1）协变量偏移（Covariate Shift）：源领域和目标领域的输入边际分布不同$p_S(x) \neq p_T(x)$，但后验分布相同$p_S(y|x) = p_T(y|x)$，即学习任务相同$T_s = T_T$</li>
<li>（2）概念偏移（Concept Shift）：输入边际分布相同$p_S(x) = p_T(x)$，但后验分布不同$p_S(y|x) \ neq p_T(y|x)$，即学习任务不同$T_S \neq T_T$</li>
<li>（3）先验偏移（Prior Shift）：源领域和目标领域中的输出$y$先验分布不同$p_S(y) \neq p_T(y)$，条件分布相同$p_S(x|y) = p_T(x|y)$。在这样的情况下，目标领域必须提供一定数量的标注样本。</li>
</ul>
<h3 id="终生学习"><a href="#终生学习" class="headerlink" title="终生学习"></a>终生学习</h3><p>终生学习（Lifelong Learning）也叫持续学习（Continuous Learning）是指像人类一样具有持续不断的学习能力，根据历史任务中学到的经验和知识来帮助学习不断出现的新任务，并且这些经验和知识是持续累积的，不会因为新的任务而忘记旧的知识。</p>
<p>在终生学习中，假设一个终生学习算法已经在历史人任务$T_1, T_2, …$上学习到一个模型，当出现一个新任务$T_{m+1}$时，这个算法可以根据过去在$m$个任务上学习到的知识来帮助第$m+1$个任务，同时积累所有的$m+1$个任务上的知识。</p>
<p>在终生学习中，一个关键的问题是如何避免<strong>灾难性遗忘（Catastrophic Forgetting）</strong>，即按照一定顺序学习多个任务时，在学习新任务的同时不忘记先前学习到的历史知识。比如在神经网络模型中，一些参数对任务$T_A$非常重要，如果在学习任务$T_B$时被改变了，就可能给任务$T_A$造成不好的影响。</p>
<p>解决灾难性遗忘的方法有很多，比如弹性权重巩固方法（Elastic Weight Coonsolidation）。</p>
<h3 id="元学习"><a href="#元学习" class="headerlink" title="元学习"></a>元学习</h3><p>根据没有免费午餐定理，没有一种通用的学习算法在所有任务上都有效。因此当使用机器学习算法实现某个任务时，我们通常需要“就事论事”，根据任务的特定来选择合适的模型、损失函数、优化算法以及超参数。</p>
<p>而这种动态调整学习方式的能力，称为元学习（Meta-Learning），也称为学习的学习（Learning to Learn）。</p>
<p>元学习的目的时从已有的任务中学习一种学习方法或元知识，可以加速新任务的学习。从这个角度来说，元学习十分类似于归纳迁移学习，但元学习更侧重从多种不同的任务中归纳出一种学习方法。</p>
<p>这里主要介绍两种典型的元学习方法：基于优化器的元学习和模型无关的元学习。</p>
<h4 id="基于优化器的元学习"><a href="#基于优化器的元学习" class="headerlink" title="基于优化器的元学习"></a>基于优化器的元学习</h4><p>目前神经网络的的学习方法主要是定义一个目标损失函数$L(\theta)$，并通过梯度下降算法来最小化$L(\theta)$</p>
<script type="math/tex; mode=display">
\theta_t \leftarrow \theta_{t-1} - \alpha \bigtriangledown L(\theta_{t-1})</script><p>其中$\theta_t$为第$t$步时的模型参数，$\bigtriangledown L(\theta_{t-1})$为梯度，$\alpha$为学习率。在不同的任务上，通常选择不同的学习绿以及不同的优化方法，比如动量法，Adam等。这些优化算法的本质区别在于更新参数的规则不同，因此一种很自然的元学习就是自动学习一种更新参数的规则，即通过另一个神经网络（比如循环神经网络）来建模梯度下降的过程。下图给出了基于优化器的元学习示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20191112151007633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="基于优化器的元学习示例"></p>
<p>我们用函数$g_t(.)$来预测第$t$步时参数更新的差值$\Delta \theta_t = \theta_t - \theta_{t-1}$，函数$g_t(.)$称为优化器，输入是当前时刻的梯度值，输出时参数的更新差值$\Delta \theta_t$，这样第$t$步的更新规则可以写为：</p>
<script type="math/tex; mode=display">
\theta_{t+1} = \theta_t + g_t(\bigtriangledown L(\theta_{t}), \phi )</script><p>其中$\phi$为优化器$g_t(.)$的参数。</p>
<p>学习优化器$g_t(.)$的过程可以看做是一种元学习过程，其目标是找到一个适用于多个不同任务的优化器。在标准的梯度下降中，每步迭代的目标是使得$L(\theta)$下降。而在优化器的元学习中，我们希望在每步迭代的目标是$L(\theta)$最小，具体的目标函数为：</p>
<script type="math/tex; mode=display">
L(\phi) = E_f [ \sum_{t=1}^{T} w_t L(\theta_t) ]
\\
\theta_t = \theta_{t-1} + g_t
\\
[g_t: h_t] = LSTM( \bigtriangledown L(\theta_{t-1}), h_{t-1}, \phi)</script><p>其中$T$为最大迭代次数，$w_t&gt;0$为每一步的权重，一般可以设置$w_t=1,\forall t$。由于LSTM网络可以记忆梯度的历史信息，学习到的优化器可以看做是一个高阶的优化方法。</p>
<h4 id="模型无关的元学习"><a href="#模型无关的元学习" class="headerlink" title="模型无关的元学习"></a>模型无关的元学习</h4><p>模型无关的元学习（Model-Agnostic Meta-Learning， MAML）是一个简单的模型无关、任务无关的元学习算法。假设所有的任务都来自一个任务空间，其分布为$p(T)$，我们可以在这个任务空间的所有任务上学习一种通用的表示，这种表示可以经过梯度下降方法在一个特定的单任务上进行精调。假设一个模型为$f(\theta)$，如果我们让这个模型适应到一个新任务$T_m$上，通过一步或多步的梯度下降更新，学习到的任务适配参数为：</p>
<script type="math/tex; mode=display">
\theta_m ' = \theta- \alpha \bigtriangledown _\theta L_{T_m}(f_\theta)</script><p>其中$\alpha$为学习率，这里的$\theta_m’$可以理解为关于$\theta$的函数，而不是真正的参数更新。</p>
<p>MAML的目标是学习一个参数$\theta$使得其经过一个梯度迭代就可以在新任务上达到最好的性能。</p>
<script type="math/tex; mode=display">
\underset{ \theta }{ min } \sum_{T_m \sim  p(T)} L_{T_m}(f(\theta'_m)) = \sum_{T_m \sim  p(T)} L_{T_m} ( f(\theta - \alpha \bigtriangledown _\theta L_{T_m} (f_\theta )) )</script><p>即在所有任务上的元优化（Meta-Optimization）也采用梯度下降来进行优化，即：</p>
<script type="math/tex; mode=display">
\theta \leftarrow \theta - \beta \bigtriangledown _\theta \sum_{m=1}^{M} L_{T_m}(f_{\theta_m'})</script><p>其中$\beta$为元学习率，这里为一个真正的参数更新步骤。需要计算关于$\theta$的二阶梯度，但用一级近似通常也可以达到比较好的性能。</p>
<p>MAML的具体过程算法如下：<br><img src="https://img-blog.csdnimg.cn/20191112155840241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="MAML的具体过程算法"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前神经网路的学习机制主要是以监督学习为主，这种学习方式得到的模型往往是定向的，也是孤立的，每个任务的模型都是从零开始训练的，一切知识都需要从训练数据中得到，导致每个任务都需要大量的训练数据。本章主要介绍了一些和模型无关的学习方式，包括集成学习、自训练和协同训练、多任务学习、迁移学习、元学习，这些都是深度学习中研究的重点。</p>
<hr>
<center>
【技术服务】，详情点击查看：
<a href="https://mp.weixin.qq.com/s/PtX9ukKRBmazAWARprGIAg" target="_blank" rel="external">https://mp.weixin.qq.com/s/PtX9ukKRBmazAWARprGIAg</a>
</center>

<hr>
<center>
<img src="https://img-blog.csdnimg.cn/20191108184219834.jpeg">
<br>
扫一扫 关注微信公众号！号主 专注于搜索和推荐系统，尝试使用算法去更好的服务于用户，包括但不局限于机器学习，深度学习，强化学习，自然语言理解，知识图谱，还不定时分享技术，资料，思考等文章！
</center>

<hr>
<center><img src="https://img-blog.csdnimg.cn/20191105121139935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" width="80%"></center>

<center><img src="https://img-blog.csdnimg.cn/20191105121309716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua2dhbWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" width="80%"></center>
        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/assets/img/weixin.jpeg">
        <p> 你的支持是我进步的最大动力！ </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/thinkgamer">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="http://weibo.com/5352480017">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        

        
        <li>
            <a target="_blank"  href="https://github.com/thinkgamer">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        


        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://item.jd.com/12671716.html">处女作：推荐系统开发实战</a></span>
        <span>/</span>
        
        <span><a href="https://mp.weixin.qq.com/s/vkDfg3v5C7QPrLOTvTRH2w">搜索与推荐Wiki</a></span>
        <span>/</span>
        
        <span><a href="https://blog.csdn.net/gamer_gyt">CSDN博客</a></span>
        <span>/</span>
        
        <span><a href="https://mp.weixin.qq.com/s/PtX9ukKRBmazAWARprGIAg">商务合作</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        || Created By <a href="https://blog.csdn.net/gamer_gyt">Thinkgamer</a></p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
