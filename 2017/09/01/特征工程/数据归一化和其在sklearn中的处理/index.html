<!DOCTYPE html>
<html lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Thinkgamer的博客">
    <meta name="keyword"  content="Python,Django,爬虫,Hadoop,Maching Learning,数据挖掘,机器学习,云计算,大数据,深度学习,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,用户体验">
    <link rel="shortcut icon" href="/assets/img/favicon.ico">

    <title>
        
        数据归一化和其在sklearn中的处理 - Thinkgamer的博客 | Thinkgamer&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> All In CTR、DL、ML、RL、NLP、KG </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/assets/img/head.jpg" />
        </div>
        <div class="name">
            <i>Thinkgamer</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一：数据归一化"><span class="toc-text">一：数据归一化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1）min-max标准化"><span class="toc-text">1）min-max标准化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2）z-score标准化"><span class="toc-text">2）z-score标准化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3）改进的z-score标准化"><span class="toc-text">3）改进的z-score标准化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二：sklearn中的归一化"><span class="toc-text">二：sklearn中的归一化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1）均值-标准差缩放"><span class="toc-text">1）均值-标准差缩放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2）min-max标准化"><span class="toc-text">2）min-max标准化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3）最大值标准化"><span class="toc-text">3）最大值标准化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4）规范化"><span class="toc-text">4）规范化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5）二值化"><span class="toc-text">5）二值化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6）编码的分类特征"><span class="toc-text">6）编码的分类特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7）填补缺失值"><span class="toc-text">7）填补缺失值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8）生成多项式特征"><span class="toc-text">8）生成多项式特征</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> All In CTR、DL、ML、RL、NLP、KG </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        <div class="post-container">
    <div class="post-title">
        数据归一化和其在sklearn中的处理
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2017-09-01 11:33:50</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#特征工程" title="特征工程">特征工程</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#数据归一化" title="数据归一化">数据归一化</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <blockquote>
<p>本文主要介绍数据归一化和其在sklearn中的处理。</p>
</blockquote>
<a id="more"></a>
<h1 id="一：数据归一化"><a href="#一：数据归一化" class="headerlink" title="一：数据归一化"></a>一：数据归一化</h1><p>数据归一化（标准化）处理是数据挖掘的一项基础工作，不同评价指标往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。</p>
<p>归一化方法有两种形式，一种是把数变为（0，1）之间的小数，一种是把有量纲表达式变为无量纲表达式。在机器学习中我们更关注的把数据变到0～1之间，接下来我们讨论的也是第一种形式。</p>
<h2 id="1）min-max标准化"><a href="#1）min-max标准化" class="headerlink" title="1）min-max标准化"></a>1）min-max标准化</h2><p>min-max标准化也叫做离差标准化，是对原始数据的线性变换，使结果落到[0,1]区间，其对应的数学公式如下：</p>
<script type="math/tex; mode=display">
X_{scale} = \frac{x-min}{max-min}</script><p>对应的python实现为<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># x为数据 比如说 [1,2,1,3,2,4,1]</span></span><br><span class="line">def Normalization(x):</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">float</span>(i)-<span class="built_in">min</span>(x))/<span class="type">float</span>(<span class="built_in">max</span>(x)-<span class="built_in">min</span>(x)) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br></pre></td></tr></table></figure></p>
<p>如果要将数据转换到[-1,1]之间，可以修改其数学公式为：</p>
<script type="math/tex; mode=display">
X_{scale} = \frac{x-x_{mean}}{max-min}</script><p>x_mean 表示平均值。</p>
<p>对应的python实现为<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as <span class="built_in">np</span></span><br><span class="line"></span><br><span class="line"># x为数据 比如说 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">def Normalization(x):</span><br><span class="line">    <span class="built_in">return</span> [(<span class="built_in">float</span>(i)-<span class="built_in">np</span>.<span class="built_in">mean</span>(x))/<span class="built_in">float</span>(<span class="built_in">max</span>(x)-<span class="built_in">min</span>(x)) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br></pre></td></tr></table></figure></p>
<p>其中max为样本数据的最大值，min为样本数据的最小值。这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。</p>
<p>该标准化方法有一个缺点就是，如果数据中有一些偏离正常数据的异常点，就会导致标准化结果的不准确性。比如说一个公司员工（A，B，C，D）的薪水为6k,8k,7k,10w,这种情况下进行归一化对每个员工来讲都是不合理的。</p>
<p>当然还有一些其他的办法也能实现数据的标准化。</p>
<h2 id="2）z-score标准化"><a href="#2）z-score标准化" class="headerlink" title="2）z-score标准化"></a>2）z-score标准化</h2><p>z-score标准化也叫标准差标准化，代表的是分值偏离均值的程度，经过处理的数据符合标准正态分布，即均值为0，标准差为1。其转化函数为</p>
<script type="math/tex; mode=display">
X_{scale} = \frac{x-\mu }{\sigma }</script><p>其中μ为所有样本数据的均值，σ为所有样本数据的标准差。</p>
<p>其对应的python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">z_score</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x - np.mean(x) )/np.std(x, ddof = <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>z-score标准化方法同样对于离群异常值的影响。接下来看一种改进的z-score标准化方法。</p>
<h2 id="3）改进的z-score标准化"><a href="#3）改进的z-score标准化" class="headerlink" title="3）改进的z-score标准化"></a>3）改进的z-score标准化</h2><p>将标准分公式中的均值改为中位数，将标准差改为绝对偏差。</p>
<script type="math/tex; mode=display">
X_{scale} = \frac{x-x_{center} }{\sigma_{1} }</script><p>中位数是指将所有数据进行排序，取中间的那个值，如数据量是偶数，则取中间两个数据的平均值。</p>
<p>σ1为所有样本数据的绝对偏差,其计算公式为：</p>
<script type="math/tex; mode=display">
\frac{1}{N} \sum_{1}^{n}|x_{i} - x_{center}|</script><hr>
<h1 id="二：sklearn中的归一化"><a href="#二：sklearn中的归一化" class="headerlink" title="二：sklearn中的归一化"></a>二：sklearn中的归一化</h1><p>sklearn.preprocessing 提供了一些实用的函数 用来处理数据的维度，以供算法使用。</p>
<h2 id="1）均值-标准差缩放"><a href="#1）均值-标准差缩放" class="headerlink" title="1）均值-标准差缩放"></a>1）均值-标准差缩放</h2><p>即我们上边对应的z-score标准化。<br>在sklearn的学习中，数据集的标准化是很多机器学习模型算法的常见要求。如果个别特征看起来不是很符合正态分布，那么他们可能为表现不好。</p>
<p>实际上，我们经常忽略分布的形状，只是通过减去整组数据的平均值，使之更靠近数据中心分布，然后通过将非连续数特征除以其标准偏差进行分类。</p>
<p>例如，用于学习算法（例如支持向量机的RBF内核或线性模型的l1和l2正则化器）的目标函数中使用的许多元素假设所有特征都以零为中心并且具有相同顺序的方差。如果特征的方差大于其他数量级，则可能主导目标函数，使估计器无法按预期正确地学习其他特征。</p>
<p>例子：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn import preprocessing</span><br><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line">...                     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">...                     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">&gt;&gt;&gt; X_scaled = preprocessing.scale(X_train)</span><br><span class="line">&gt;&gt;&gt; X_scaled</span><br><span class="line">array([[ <span class="number">0.</span>        , <span class="number">-1.22474487</span>,  <span class="number">1.33630621</span>],</span><br><span class="line">       [ <span class="number">1.22474487</span>,  <span class="number">0.</span>        , <span class="number">-0.26726124</span>],</span><br><span class="line">       [<span class="number">-1.22474487</span>,  <span class="number">1.22474487</span>, <span class="number">-1.06904497</span>]])</span><br></pre></td></tr></table></figure></p>
<p>标准化后的数据符合标准正太分布<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X_scaled.mean(axis=<span class="number">0</span>)</span><br><span class="line">array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</span><br><span class="line">&gt;&gt;&gt; X_scaled.std(axis=<span class="number">0</span>)</span><br><span class="line">array([ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])</span><br></pre></td></tr></table></figure></p>
<p>预处理模块还提供了一个实用程序级StandardScaler，它实现了Transformer API来计算训练集上的平均值和标准偏差，以便能够稍后在测试集上重新应用相同的变换。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; scaler = preprocessing.StandardScaler().fit(X_train)</span><br><span class="line">&gt;&gt;&gt; scaler</span><br><span class="line">StandardScaler(copy=True, with_mean=True, with_std=True)</span><br><span class="line">&gt;&gt;&gt; scaler.mean_</span><br><span class="line">array([ <span class="number">1.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.33333333</span>])</span><br><span class="line">&gt;&gt;&gt; scaler.scale_</span><br><span class="line">array([ <span class="number">0.81649658</span>,  <span class="number">0.81649658</span>,  <span class="number">1.24721913</span>])</span><br><span class="line">&gt;&gt;&gt; scaler.transform(X_train)</span><br><span class="line">array([[ <span class="number">0.</span>        , <span class="number">-1.22474487</span>,  <span class="number">1.33630621</span>],</span><br><span class="line">       [ <span class="number">1.22474487</span>,  <span class="number">0.</span>        , <span class="number">-0.26726124</span>],</span><br><span class="line">       [<span class="number">-1.22474487</span>,  <span class="number">1.22474487</span>, <span class="number">-1.06904497</span>]])</span><br></pre></td></tr></table></figure></p>
<p>使用转换器可以对新数据进行转换<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X_test = <span class="string">[[-1., 1., 0.]]</span></span><br><span class="line">&gt;&gt;&gt; scaler.transform(X_test)</span><br><span class="line">array(<span class="string">[[-2.44948974,  1.22474487, -0.26726124]]</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="2）min-max标准化"><a href="#2）min-max标准化" class="headerlink" title="2）min-max标准化"></a>2）min-max标准化</h2><p>X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line">...                      [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">...                      [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">&gt;&gt;&gt; min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line">&gt;&gt;&gt; X_train_minmax = min_max_scaler.fit_transform(X_train)</span><br><span class="line">&gt;&gt;&gt; X_train_minmax</span><br><span class="line">array([[ <span class="number">0.5</span>       ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ],</span><br><span class="line">       [ <span class="number">1.</span>        ,  <span class="number">0.5</span>       ,  <span class="number">0.33333333</span>],</span><br><span class="line">       [ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">0.</span>        ]])</span><br></pre></td></tr></table></figure>
<p>上边我们创建的min_max_scaler 同样适用于新的测试数据<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X_test = np.array(<span class="string">[[ -3., -1.,  4.]]</span>)</span><br><span class="line">&gt;&gt;&gt; X_test_minmax = min_max_scaler.transform(X_test)</span><br><span class="line">&gt;&gt;&gt; X_test_minmax</span><br><span class="line">array(<span class="string">[[-1.5       ,  0.        ,  1.66666667]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以通过scale_和min方法查看标准差和最小值<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; min_max_scaler<span class="selector-class">.scale_</span> </span><br><span class="line"><span class="function"><span class="title">array</span><span class="params">([ <span class="number">0.5</span>       ,  <span class="number">0.5</span>       ,  <span class="number">0.33333333</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; min_max_scaler.min_</span><br><span class="line"><span class="function"><span class="title">array</span><span class="params">([ <span class="number">0</span>.        ,  <span class="number">0.5</span>       ,  <span class="number">0.33333333</span>])</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="3）最大值标准化"><a href="#3）最大值标准化" class="headerlink" title="3）最大值标准化"></a>3）最大值标准化</h2><p>对于每个数值／每个维度的最大值</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X_train</span><br><span class="line">array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">&gt;&gt;&gt; max_abs_scaler = preprocessing.MaxAbsScaler()</span><br><span class="line">&gt;&gt;&gt; X_train_maxabs = max_abs_scaler.fit_transform(X_train)</span><br><span class="line">&gt;&gt;&gt; X_train_maxabs</span><br><span class="line">array([[ <span class="number">0.5</span>, <span class="number">-1.</span> ,  <span class="number">1.</span> ],</span><br><span class="line">       [ <span class="number">1.</span> ,  <span class="number">0.</span> ,  <span class="number">0.</span> ],</span><br><span class="line">       [ <span class="number">0.</span> ,  <span class="number">1.</span> , <span class="number">-0.5</span>]])</span><br><span class="line">&gt;&gt;&gt; X_test = np.array([[ <span class="number">-3.</span>, <span class="number">-1.</span>,  <span class="number">4.</span>]])</span><br><span class="line">&gt;&gt;&gt; X_test_maxabs = max_abs_scaler.transform(X_test)</span><br><span class="line">&gt;&gt;&gt; X_test_maxabs                 </span><br><span class="line">array([[<span class="number">-1.5</span>, <span class="number">-1.</span> ,  <span class="number">2.</span> ]])</span><br><span class="line">&gt;&gt;&gt; max_abs_scaler.scale_         </span><br><span class="line">array([ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>])</span><br></pre></td></tr></table></figure>
<h2 id="4）规范化"><a href="#4）规范化" class="headerlink" title="4）规范化"></a>4）规范化</h2><p>规范化是文本分类和聚类中向量空间模型的基础</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line">...      [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">...      [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</span><br><span class="line">&gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm='l2')</span><br><span class="line">&gt;&gt;&gt; X_normalized</span><br><span class="line">array([[ <span class="number">0.40824829</span>, <span class="number">-0.40824829</span>,  <span class="number">0.81649658</span>],</span><br><span class="line">       [ <span class="number">1.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ],</span><br><span class="line">       [ <span class="number">0.</span>        ,  <span class="number">0.70710678</span>, <span class="number">-0.70710678</span>]])</span><br></pre></td></tr></table></figure>
<p>解释：norm 该参数是可选的，默认值是l2（向量各元素的平方和然后求平方根），用来规范化每个非零向量，如果axis参数设置为0，则表示的是规范化每个非零的特征维度。</p>
<p>机器学习中的范数规则：<a href="http://blog.csdn.net/zouxy09/article/details/24971995/" target="_blank" rel="external">点击阅读</a><br><br>其他对应参数：<a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" target="_blank" rel="external">点击查看</a></p>
<p>preprocessing模块提供了训练种子的功能，我们可通过以下方式得到一个新的种子，并对新数据进行规范化处理。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; normalizer = preprocessing.Normalizer().fit(X)</span><br><span class="line">&gt;&gt;&gt; normalizer</span><br><span class="line">Normalizer(copy=True, norm=<span class="string">'l2'</span>)</span><br><span class="line">&gt;&gt;&gt; normalizer.transform(X)</span><br><span class="line">array(<span class="string">[[ 0.40824829, -0.40824829,  0.81649658],</span></span><br><span class="line"><span class="string">       [ 1.        ,  0.        ,  0.        ],</span></span><br><span class="line"><span class="string">       [ 0.        ,  0.70710678, -0.70710678]]</span>)</span><br><span class="line">&gt;&gt;&gt; normalizer.transform(<span class="string">[[-1,1,0]]</span>)</span><br><span class="line">array(<span class="string">[[-0.70710678,  0.70710678,  0.        ]]</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="5）二值化"><a href="#5）二值化" class="headerlink" title="5）二值化"></a>5）二值化</h2><p>将数据转换到0-1 之间<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X</span><br><span class="line">[[<span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">2.0</span>], [<span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>]]</span><br><span class="line">&gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X)</span><br><span class="line">&gt;&gt;&gt; binarizer</span><br><span class="line">Binarizer(copy=True, threshold=<span class="number">0.0</span>)</span><br><span class="line">&gt;&gt;&gt; binarizer.transform(X)</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></p>
<p>可以调整二值化的门阀<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; binarizer = preprocessing.Binarizer(threshold=<span class="number">1.1</span>)</span><br><span class="line">&gt;&gt;&gt; binarizer.transform(X)</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></p>
<h2 id="6）编码的分类特征"><a href="#6）编码的分类特征" class="headerlink" title="6）编码的分类特征"></a>6）编码的分类特征</h2><p>通常情况下，特征不是作为连续值给定的。例如一个人可以有<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"male"</span>, <span class="string">"female"</span>], [<span class="string">"from Europe"</span>, <span class="string">"from US"</span>, <span class="string">"from Asia"</span>], [<span class="string">"uses Firefox"</span>, <span class="string">"uses Chrome"</span>, <span class="string">"uses Safari"</span>, <span class="string">"uses Internet Explorer"</span>]</span><br></pre></td></tr></table></figure></p>
<p>这些特征可以被有效的编码为整数，例如<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"male"</span>, <span class="string">"from US"</span>, <span class="string">"uses Internet Explorer"</span>] =&gt; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="string">"female"</span>, <span class="string">"from Asia"</span>, <span class="string">"uses Chrome"</span>] would be [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure></p>
<p>这样的整数不应该直接应用到scikit的算法中，可以通过one-of-k或者独热编码（OneHotEncorder），该种处理方式会把每个分类特征的m中可能值转换成m个二进制值。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder()</span><br><span class="line">&gt;&gt;&gt; enc.fit([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line">OneHotEncoder(categorical_features='all', dtype=&lt;class 'numpy.float64'&gt;,</span><br><span class="line">       handle_unknown='error', n_values='auto', sparse=True)</span><br><span class="line">&gt;&gt;&gt; enc.transform([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]]).toarray()</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
<p>默认情况下，从数据集中自动推断出每个特征可以带多少个值。可以明确指定使用的参数n_values。在我们的数据集中有两种性别，三种可能的大陆和四种Web浏览器。然后，我们拟合估计量，并转换一个数据点。在结果中，前两个数字编码性别，下一组三个数字的大陆和最后四个Web浏览器。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(n_values=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">&gt;&gt;&gt; enc.fit([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>]])</span><br><span class="line">OneHotEncoder(categorical_features='all', dtype=&lt;class 'numpy.float64'&gt;,</span><br><span class="line">       handle_unknown='error', n_values=[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], sparse=True)</span><br><span class="line">&gt;&gt;&gt; enc.transform([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]).toarray()</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></p>
<h2 id="7）填补缺失值"><a href="#7）填补缺失值" class="headerlink" title="7）填补缺失值"></a>7）填补缺失值</h2><p>由于各种原因，真实数据中存在大量的空白值，这样的数据集，显然是不符合scikit的要求的，那么preprocessing模块提供这样一个功能，利用已知的数据来填补这些空白。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import Imputer</span><br><span class="line">&gt;&gt;&gt; imp = Imputer(missing_values=<span class="string">'NaN'</span>,strategy=<span class="string">'mean'</span>,verbose=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; imp.fit(<span class="string">[[1, 2], [np.nan, 3], [7, 6]]</span>)</span><br><span class="line">Imputer(axis=<span class="number">0</span>, copy=True, missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; X = <span class="string">[[np.nan, 2], [6, np.nan], [7, 6]]</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(imp.transform(X))                           </span><br><span class="line"><span class="string">[[ 4.          2.        ]</span></span><br><span class="line"><span class="string"> [ 6.          3.66666667]</span></span><br><span class="line"><span class="string"> [ 7.          6.        ]]</span></span><br></pre></td></tr></table></figure></p>
<p>Imputer同样支持稀疏矩阵<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import scipy.sparse as sp</span><br><span class="line">&gt;&gt;&gt; X = sp.csc_matrix([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">7</span>,<span class="number">6</span>]])</span><br><span class="line">&gt;&gt;&gt; imp = Imputer(missing_values=<span class="number">0</span>,strategy='mean',axis=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; imp.fit(X)</span><br><span class="line">Imputer(axis=<span class="number">0</span>, copy=True, missing_values=<span class="number">0</span>, strategy='mean', verbose=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; X_test = sp.csc</span><br><span class="line">sp.csc          sp.csc_matrix(  </span><br><span class="line">&gt;&gt;&gt; X_test = sp.csc_matrix([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">6</span>]])</span><br><span class="line">&gt;&gt;&gt; print(imp.transform(X_test))</span><br><span class="line">[[ <span class="number">4.</span>          <span class="number">2.</span>        ]</span><br><span class="line"> [ <span class="number">6.</span>          <span class="number">3.66666667</span>]</span><br><span class="line"> [ <span class="number">7.</span>          <span class="number">6.</span>        ]]</span><br></pre></td></tr></table></figure></p>
<h2 id="8）生成多项式特征"><a href="#8）生成多项式特征" class="headerlink" title="8）生成多项式特征"></a>8）生成多项式特征</h2><p>通常，通过考虑输入数据的非线性特征来增加模型的复杂度是很有用的。一个简单而常用的方法是多项式特征，它可以得到特征的高阶和相互作用项。</p>
<p>其遵循的原则是 </p>
<script type="math/tex; mode=display">
(X_1, X_2) -> (1, X_1, X_2, X_1^2, X_1X_2, X_2^2)</script><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures</span><br><span class="line">&gt;&gt;&gt; X = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; X                                                 </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">&gt;&gt;&gt; poly = PolynomialFeatures(<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; poly.fit_transform(X)                             </span><br><span class="line">array([[  <span class="number">1.</span>,   <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">0.</span>,   <span class="number">0.</span>,   <span class="number">1.</span>],</span><br><span class="line">       [  <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>,   <span class="number">4.</span>,   <span class="number">6.</span>,   <span class="number">9.</span>],</span><br><span class="line">       [  <span class="number">1.</span>,   <span class="number">4.</span>,   <span class="number">5.</span>,  <span class="number">16.</span>,  <span class="number">20.</span>,  <span class="number">25.</span>]])</span><br></pre></td></tr></table></figure>
<p>有些情况下，有相互关系的标签才是必须的，这个时候可以通过设置 interaction_only=True 来进行多项式特征的生成<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; X                                                 </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">&gt;&gt;&gt; poly = PolynomialFeatures(degree=<span class="number">3</span>, interaction_only=True)</span><br><span class="line">&gt;&gt;&gt; poly.fit_transform(X)                             </span><br><span class="line">array([[   <span class="number">1.</span>,    <span class="number">0.</span>,    <span class="number">1.</span>,    <span class="number">2.</span>,    <span class="number">0.</span>,    <span class="number">0.</span>,    <span class="number">2.</span>,    <span class="number">0.</span>],</span><br><span class="line">       [   <span class="number">1.</span>,    <span class="number">3.</span>,    <span class="number">4.</span>,    <span class="number">5.</span>,   <span class="number">12.</span>,   <span class="number">15.</span>,   <span class="number">20.</span>,   <span class="number">60.</span>],</span><br><span class="line">       [   <span class="number">1.</span>,    <span class="number">6.</span>,    <span class="number">7.</span>,    <span class="number">8.</span>,   <span class="number">42.</span>,   <span class="number">48.</span>,   <span class="number">56.</span>,  <span class="number">336.</span>]])</span><br></pre></td></tr></table></figure></p>
<p>其遵循的规则是：</p>
<script type="math/tex; mode=display">
(X_1, X_2, X_3) -> (1, X_1, X_2, X_3, X_1X_2, X_1X_3, X_2X_3, X_1X_2X_3)</script><hr>
<p>对应的scikit-learn资料为： <a href="http://scikit-learn.org/stable/modules/preprocessing.html" target="_blank" rel="external">http://scikit-learn.org/stable/modules/preprocessing.html</a></p>
<hr>
<center>
<img src="http://img.blog.csdn.net/20171231111930492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FtZXJfZ3l0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
</center>
<center>打开微信扫一扫，关注微信公众号【搜索与推荐Wiki】 </center>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/assets/img/weixin.jpeg">
        <p> 你的支持是我进步的最大动力！ </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/thinkgamer">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="http://weibo.com/5352480017">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        

        
        <li>
            <a target="_blank"  href="https://github.com/thinkgamer">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        


        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        || Created By <a href="https://blog.csdn.net/gamer_gyt">Thinkgamer</a></p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
